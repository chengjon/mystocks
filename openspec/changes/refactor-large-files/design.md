# 设计决策：超长文件重构

## 背景与约束

### 背景

MyStocks项目中存在38个超过1200行的大型文件，这些文件难以维护、测试和协作开发。重构目标是：

- 减少超长文件数至10个以内
- 提升代码可测试性
- 改善团队协作效率
- 遵循单一职责原则

### 约束

1. **时间约束**：需要在2个月内完成所有拆分
2. **兼容性约束**：重构期间功能不能中断
3. **资源约束**：团队成员需要同时进行新功能开发
4. **技术约束**：需要保持与现有系统的兼容性

## 目标与非目标

### 目标

1. **可维护性**：每个文件≤500行，职责单一
2. **可测试性**：每个模块可独立单元测试
3. **可协作性**：多人可并行修改不同模块
4. **可扩展性**：新功能有清晰的放置位置

### 非目标

1. ❌ 不改变业务逻辑
2. ❌ 不改变API接口契约
3. ❌ 不引入新的外部依赖（除非必要）
4. ❌ 不进行性能优化（保持现有性能水平）

## 决策

### D1: Python API按领域(Domain)拆分

**决策**：将 `mystocks_complete.py` 按业务领域拆分为 `system/`, `strategy/`, `trading/`, `admin/`, `analysis/` 子目录

**选项**：
- A) 按Phase拆分：`phase1/`, `phase2/`, `phase3/`, `phase4/`, `phase5/`
- B) 按领域拆分：`system/`, `strategy/`, `trading/`, `admin/`, `analysis/`
- C) 按功能类型拆分：`core/`, `ml/`, `trading/`, `enterprise/`, `advanced/`

**选择**：B

**理由**：
- 代码结构应反映业务领域，而非开发时间线
- 新开发者不需要了解"Phase 2"代表什么
- 领域名称具有自描述性

**权衡**：
- 优点：语义清晰，易于理解
- 缺点：需要重新映射现有功能到新领域

### D2: 层级依赖规则

**决策**：严格遵循单向依赖规则

```
API (路由层) → Services (业务逻辑) → Models (数据模型) → Utils (工具函数)
```

**选项**：
- A) 无限制依赖
- B) 单向依赖规则
- C) 完全禁止依赖

**选择**：B

**理由**：
- 避免循环依赖
- 保持代码模块化
- 便于测试

**详细规则**：
1. Models 不能依赖 Services
2. Services 不能依赖 API
3. API 只能调用 Services
4. Utils 可被所有层引用

**循环依赖解决**：
- 首选：抽取到第三方 CommonService 或 Utils
- 次选：使用局部导入（函数内部导入）

### D3: Vue组件状态管理

**决策**：根据组件层级选择状态管理方案

**选项**：
- A) 统一使用Props/Emit
- B) 统一使用Pinia Store
- C) 分层策略：≤2层用Props/Emit，>2层用Provide/Inject或Pinia

**选择**：C

**理由**：
- 简单场景不需要过度设计
- 深层嵌套需要避免Props Drilling
- Provide/Inject比Pinia更轻量

**具体方案**：
```vue
<!-- 层级≤2层：Props + Emit -->
<Parent :data="data" @event="handler" />

<!-- 层级>2层：Provide/Inject -->
<!-- Parent.vue -->
const data = provide('data', reactiveData)

<!-- DeepChild.vue -->
const data = inject('data')
```

### D4: TypeScript类型文件处理

**决策**：先修改生成脚本，后手动拆分

**选项**：
- A) 手动拆分generated-types.ts
- B) 修改生成脚本支持多文件输出
- C) 保持现状，只做必要修改

**选择**：B

**理由**：
- 手动拆分会被下次生成覆盖
- 修改生成脚本是治本之策
- 自动化维护减少人工干预

**实施步骤**：
1. 检查 `scripts/generate_frontend_types.py`
2. 修改生成脚本，按Pydantic模型模块生成多文件
3. 生成多文件类型定义
4. 创建统一导出index.ts

### D5: 拆分粒度控制

**决策**：目标文件≤500行，但允许适度灵活

**选项**：
- A) 严格≤300行
- B) 灵活≤500行
- C) 无限制

**选择**：B

**理由**：
- 300行限制可能过度拆分
- 500行是合理的可维护上限
- 允许特殊情况适度放宽

**指导原则**：
- 模板+脚本+样式总和≤500行
- 特殊情况可放宽至600行
- 超过600行必须进一步拆分

## 风险与缓解

### R1: 循环依赖

**风险等级**：高

**缓解措施**：
1. 实施前绘制依赖图
2. 拆分过程中持续检查
3. 使用局部导入作为最后手段

### R2: 功能回归

**风险等级**：高

**缓解措施**：
1. 每个阶段完成后运行完整测试
2. 保持API接口契约不变
3. 逐步迁移而非一次性替换

### R3: 开发效率下降

**风险等级**：中

**缓解措施**：
1. 并行拆分不同模块
2. 优先拆分影响最大的文件
3. 在低峰期进行高风险拆分

### R4: 团队协作冲突

**风险等级**：低

**缓解措施**：
1. 分工明确，每人负责特定模块
2. 使用feature branch进行拆分
3. 频繁提交，小步前进

## 迁移计划

### 阶段1：基础设施准备

1. 创建新目录结构
2. 设置导入路径
3. 配置构建工具

### 阶段2：核心文件拆分

1. 拆分quant_strategy_validation.py
2. 拆分mystocks_complete.py
3. 拆分ArtDecoTradingManagement.vue

### 阶段3：扩展拆分

1. 拆分其他Python文件
2. 拆分Vue组件
3. 拆分测试文件

### 阶段4：清理与验证

1. 删除旧文件
2. 运行完整测试
3. 更新文档

## 开放问题

1. [待定] 是否需要在拆分后进行性能基准测试？
2. [待定] 如何处理拆分过程中的废弃代码？
3. [待定] 是否需要创建迁移指南文档？
