"""
故障恢复队列

基于SQLite的Outbox持久化队列,用于数据库故障时的数据缓冲和重试。

创建日期: 2025-10-11
版本: 1.0.0
"""

import sqlite3
import json
from datetime import datetime
from typing import Optional, Dict, Any


class FailureRecoveryQueue:
    """
    故障恢复队列
    
    当目标数据库不可用时,将数据持久化到本地SQLite队列,
    待数据库恢复后自动重试。
    """
    
    def __init__(self, db_path: str = "/tmp/mystocks_recovery_queue.db"):
        """
        初始化队列

        Args:
            db_path: SQLite数据库文件路径
        """
        import os
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        self.db_path = db_path
        self._init_db()
    
    def _init_db(self):
        """初始化SQLite数据库表"""
        conn = sqlite3.connect(self.db_path, timeout=10.0, isolation_level='IMMEDIATE')
        cursor = conn.cursor()

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS outbox_queue (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                classification TEXT NOT NULL,
                target_database TEXT NOT NULL,
                data_json TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                retry_count INTEGER DEFAULT 0,
                status TEXT DEFAULT 'pending'
            )
        ''')

        conn.commit()
        conn.close()
    
    def enqueue(self, classification: str, target_database: str, data: Dict[str, Any]):
        """
        将失败的数据操作加入队列
        
        Args:
            classification: 数据分类
            target_database: 目标数据库
            data: 数据内容 (将转为JSON)
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO outbox_queue (classification, target_database, data_json)
            VALUES (?, ?, ?)
        ''', (classification, target_database, json.dumps(data)))
        
        conn.commit()
        conn.close()
    
    def get_pending_items(self, limit: int = 100):
        """
        获取待重试的队列项
        
        Args:
            limit: 最大返回数量
            
        Returns:
            待处理的队列项列表
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT id, classification, target_database, data_json
            FROM outbox_queue
            WHERE status = 'pending'
            ORDER BY created_at ASC
            LIMIT ?
        ''', (limit,))
        
        items = cursor.fetchall()
        conn.close()
        
        return items

    def mark_item_processed(self, item_id: int):
        """
        标记队列项为已处理

        Args:
            item_id: 队列项ID
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            UPDATE outbox_queue
            SET status = 'processed', processed_at = CURRENT_TIMESTAMP
            WHERE id = ?
        ''', (item_id,))

        conn.commit()
        conn.close()

    def mark_item_failed(self, item_id: int, error_message: str = ""):
        """
        标记队列项为失败并增加重试次数

        Args:
            item_id: 队列项ID
            error_message: 错误信息
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            UPDATE outbox_queue
            SET status = 'failed',
                retry_count = retry_count + 1,
                last_error = ?,
                last_attempt_at = CURRENT_TIMESTAMP
            WHERE id = ?
        ''', (error_message, item_id))

        conn.commit()
        conn.close()

    def retry_failed_items(self, max_retries: int = 3):
        """
        重试失败的队列项

        Args:
            max_retries: 最大重试次数

        Returns:
            重置为pending状态的队列项数量
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            UPDATE outbox_queue
            SET status = 'pending'
            WHERE status = 'failed' AND retry_count < ?
        ''', (max_retries,))

        count = cursor.rowcount
        conn.commit()
        conn.close()

        return count

    def cleanup_old_items(self, days_old: int = 30):
        """
        清理旧的已处理项

        Args:
            days_old: 保留天数

        Returns:
            清理的项数量
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            DELETE FROM outbox_queue
            WHERE status = 'processed'
            AND processed_at < datetime('now', '-{} days')
        '''.format(days_old))

        count = cursor.rowcount
        conn.commit()
        conn.close()

        return count

    def get_queue_stats(self) -> Dict[str, Any]:
        """
        获取队列统计信息

        Returns:
            队列统计信息
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # 获取各状态的计数
        cursor.execute('''
            SELECT status, COUNT(*) as count
            FROM outbox_queue
            GROUP BY status
        ''')

        status_counts = {row[0]: row[1] for row in cursor.fetchall()}

        # 获取最老的未处理项时间
        cursor.execute('''
            SELECT MIN(created_at) as oldest_pending
            FROM outbox_queue
            WHERE status = 'pending'
        ''')

        oldest_pending = cursor.fetchone()[0]

        conn.close()

        return {
            'total_items': sum(status_counts.values()),
            'pending_items': status_counts.get('pending', 0),
            'failed_items': status_counts.get('failed', 0),
            'processed_items': status_counts.get('processed', 0),
            'oldest_pending_item': oldest_pending
        }

    def get_failed_items_with_high_retry_count(self, min_retries: int = 5) -> list:
        """
        获取重试次数过多的失败项

        Args:
            min_retries: 最小重试次数

        Returns:
            高重试次数的失败项列表
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            SELECT id, classification, target_database, retry_count, last_error, created_at
            FROM outbox_queue
            WHERE status = 'failed' AND retry_count >= ?
            ORDER BY retry_count DESC, created_at ASC
        ''', (min_retries,))

        items = cursor.fetchall()
        conn.close()

        return [
            {
                'id': item[0],
                'classification': item[1],
                'target_database': item[2],
                'retry_count': item[3],
                'last_error': item[4],
                'created_at': item[5]
            }
            for item in items
        ]
