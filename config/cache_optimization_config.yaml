# 后端缓存逻辑优化配置文件
# 基于用户需求的Redis-free缓存优化方案

version: "1.0"
created: "2025-11-17"
optimization_focus: "Redis-free缓存性能优化"

# 内存缓存配置 (替代Redis)
memory_cache:
  max_entries: 10000              # 最大缓存条目数
  default_ttl: 300                # 默认TTL (秒)
  eviction_policy: "LRU"          # 淘汰策略: LRU, LFU, FIFO
  
  # 分层TTL策略 (按数据重要性设置不同过期时间)
  tiered_ttl:
    tick_data: 30                 # Tick数据: 30秒
    realtime_quote: 60            # 实时行情: 1分钟  
    minute_kline: 300             # 分钟K线: 5分钟
    fund_flow: 600                # 资金流向: 10分钟
    etf: 1800                     # ETF数据: 30分钟
    daily_kline: 7200             # 日线数据: 2小时
    default: 300                  # 默认: 5分钟

# 缓存层级配置
cache_tiers:
  # 一级缓存: 内存缓存 (最高性能)
  level_1_memory:
    enabled: true
    capacity_percentage: 60       # 占用60%的内存缓存容量
    
  # 二级缓存: TDengine缓存 (持久化存储)
  level_2_tdengine:
    enabled: true
    capacity_percentage: 40       # 占用40%的内存缓存容量
    async_write: true             # 异步写入
    write_buffer_size: 500        # 写入缓冲区大小

# 性能优化策略
performance_optimization:
  # 批量操作优化
  batch_operations:
    enabled: true
    max_batch_size: 100           # 最大批处理大小
    concurrent_threshold: 10      # 并发查询阈值
    
  # 异步写入
  async_writes:
    enabled: true
    max_concurrent: 5             # 最大并发写操作
    write_queue_size: 1000        # 写入队列大小
    
  # 预热策略
  prewarming:
    enabled: true
    hot_symbols: ["600000", "000001", "000858"]  # 预热热门股票
    prewarm_on_start: true        # 启动时预热

# 监控和告警配置
monitoring:
  # 性能指标
  performance_thresholds:
    hit_rate_warning: 50          # 命中率警告阈值 (%)
    hit_rate_critical: 30         # 命中率严重阈值 (%)
    response_time_warning: 1000   # 响应时间警告阈值 (毫秒)
    response_time_critical: 2000  # 响应时间严重阈值 (毫秒)
    
  # 内存使用监控
  memory_thresholds:
    usage_warning: 80             # 内存使用警告阈值 (%)
    usage_critical: 95            # 内存使用严重阈值 (%)
    
  # 自动优化触发条件
  auto_optimization:
    enabled: true
    low_hit_rate_trigger: 40      # 低命中率触发自动优化
    high_memory_trigger: 90       # 高内存使用触发优化

# 数据一致性配置
consistency:
  # 写入策略
  write_strategy: "write_back"    # write_back, write_through
  consistency_level: "eventual"   # strong, eventual
  
  # 缓存失效策略
  invalidation:
    time_based: true              # 基于时间的失效
    dependency_based: false       # 基于依赖的失效 (暂不启用)
    manual_invalidation: true     # 手动失效

# 应用程序集成配置
application_integration:
  # API缓存配置
  api_cache:
    enabled: true
    cache_key_format: "{symbol}:{data_type}:{timeframe}"
    include_metadata: true        # 包含缓存元数据
    
  # 装饰器配置
  decorators:
    enabled: true
    default_ttl: 300              # 装饰器默认TTL
    include_timing: true          # 包含性能计时

# 优化后的缓存操作参数
optimized_parameters:
  # 读取优化
  read_optimization:
    concurrent_memory_read: true  # 并发内存读取
    prefetch_hot_data: true       # 预取热点数据
    cache_prediction: true        # 缓存预测
    
  # 写入优化
  write_optimization:
    batch_write_threshold: 10     # 批写阈值
    async_write_threshold: 100    # 异步写阈值
    write_combining: true         # 写合并
    
  # 内存管理优化
  memory_management:
    gc_frequency: 300             # 垃圾回收频率 (秒)
    compression_enabled: true     # 内存压缩
    lazy_cleanup: true            # 懒清理

# 适配器优先级配置
adapter_priority:
  data_types:
    - name: "fund_flow"
      cache_priority: "high"
      memory_cache_weight: 0.8
      tdengine_cache_weight: 0.2
      
    - name: "realtime_quote"
      cache_priority: "high"
      memory_cache_weight: 0.9
      tdengine_cache_weight: 0.1
      
    - name: "etf"
      cache_priority: "medium"
      memory_cache_weight: 0.6
      tdengine_cache_weight: 0.4
      
    - name: "daily_kline"
      cache_priority: "low"
      memory_cache_weight: 0.3
      tdengine_cache_weight: 0.7

# 实施建议
implementation_notes:
  - "采用三级缓存策略：内存缓存 -> TDengine缓存 -> 数据源"
  - "内存缓存使用LRU淘汰策略，最大10000条记录"
  - "分层TTL：Tick数据30秒，实时行情1分钟，日线数据2小时"
  - "批量操作优化：并发读取，异步写入，批处理合并"
  - "性能监控：命中率>50%，响应时间<1秒"
  - "自动优化：命中率<40%时触发预热和清理"
  - "无Redis依赖：完全基于内存+TDengine的缓存架构"

# 性能目标
performance_targets:
  cache_hit_rate: ">60%"          # 目标缓存命中率
  avg_response_time: "<500ms"     # 平均响应时间
  memory_efficiency: ">80%"       # 内存使用效率
  throughput_improvement: "+200%" # 吞吐量提升目标
