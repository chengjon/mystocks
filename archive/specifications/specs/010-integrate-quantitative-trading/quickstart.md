# Quick Start: Quantitative Trading Integration

**Feature**: 010-integrate-quantitative-trading
**Date**: 2025-10-18
**Phase**: 1 - Design & Contracts

## Overview

This guide provides a quick start for developers implementing the quantitative trading feature. It covers setup, architecture overview, and key implementation patterns.

---

## Prerequisites

### 1. System Dependencies

```bash
# Update system packages
sudo apt update && sudo apt upgrade -y

# Python 3.12 should already be installed (MyStocks standard)
python3 --version  # Should show 3.12.x

# Install TA-Lib 0.6.7 (no system dependencies needed with binary wheels)
pip install --upgrade TA-Lib==0.6.7

# Install new visualization and backtesting libraries
pip install mplfinance==0.12.10b0
pip install pandas numpy scipy

# Optional: Interactive charts
pip install plotly==5.14.1 kaleido==0.2.1

# Verify installations
python -c "import talib; print(f'TA-Lib {talib.__version__}')"
python -c "import mplfinance; print('mplfinance OK')"
```

### 2. Environment Configuration

Add to `.env` file:

```bash
# TDX Data Configuration
TDX_DATA_PATH=/mnt/d/ProgramData/tdx_new/vipdoc
TDX_MARKETS=sh,sz,bj,cw,ds,ot

# Strategy Configuration
STRATEGY_EXECUTION_TIMEOUT=600
STRATEGY_MAX_WORKERS=4

# Backtest Configuration
BACKTEST_DEFAULT_CAPITAL=100000
BACKTEST_COMMISSION_RATE=0.0003
BACKTEST_SLIPPAGE_RATE=0.0001
BACKTEST_BENCHMARK=000300.XSHG

# Visualization Configuration
CHART_DEFAULT_DPI=150
CHART_OUTPUT_DIR=/opt/claude/mystocks_spec/charts
```

### 3. Database Setup

Update `table_config.yaml` (add to existing file):

```yaml
tables:
  # ... existing tables ...

  # NEW: Strategy metadata table
  - name: strategy
    database: mysql
    classification: meta_data
    comment: Custom stock screening strategies
    columns:
      - {name: id, type: bigint, auto_increment: true, primary_key: true}
      - {name: name, type: varchar(100), not_null: true, unique: true}
      - {name: version, type: varchar(20), not_null: true}
      - {name: description, type: text}
      - {name: parameters, type: json, not_null: true}
      - {name: code_hash, type: varchar(64), not_null: true}
      - {name: created_at, type: timestamp, default: CURRENT_TIMESTAMP}
      - {name: updated_at, type: timestamp, default: CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP}
      - {name: created_by, type: varchar(50), not_null: true}
      - {name: is_active, type: boolean, default: true}
      - {name: tags, type: json}
    indexes:
      - {columns: [created_at], unique: false}
      - {columns: [is_active], unique: false}

  # NEW: Strategy signals table
  - name: strategy_signals
    database: postgresql
    classification: derived_data
    comment: Buy/sell signals generated by strategies
    columns:
      - {name: id, type: bigserial, primary_key: true}
      - {name: strategy_id, type: bigint, not_null: true}
      - {name: symbol, type: varchar(20), not_null: true}
      - {name: signal_date, type: date, not_null: true}
      - {name: signal_type, type: varchar(10), not_null: true}
      - {name: signal_strength, type: float}
      - {name: entry_price, type: decimal(10,3), not_null: true}
      - {name: indicators, type: jsonb}
      - {name: metadata, type: jsonb}
      - {name: created_at, type: timestamp, default: now()}
    indexes:
      - {columns: [strategy_id, symbol, signal_date], unique: false}
      - {columns: [signal_date], unique: false}
      - {columns: [symbol, signal_date], unique: false}
    constraints:
      - type: check
        name: signal_type_check
        definition: signal_type IN ('buy', 'sell')
      - type: check
        name: signal_strength_check
        definition: signal_strength >= 0.0 AND signal_strength <= 1.0
      - type: check
        name: entry_price_positive
        definition: entry_price > 0

  # NEW: Backtest results table
  - name: backtest_results
    database: postgresql
    classification: derived_data
    comment: Historical strategy backtest performance metrics
    columns:
      - {name: id, type: bigserial, primary_key: true}
      - {name: strategy_id, type: bigint, not_null: true}
      - {name: start_date, type: date, not_null: true}
      - {name: end_date, type: date, not_null: true}
      - {name: initial_capital, type: decimal(15,2), not_null: true}
      - {name: final_capital, type: decimal(15,2), not_null: true}
      - {name: total_return, type: float, not_null: true}
      - {name: annualized_return, type: float, not_null: true}
      - {name: max_drawdown, type: float, not_null: true}
      - {name: sharpe_ratio, type: float}
      - {name: win_rate, type: float}
      - {name: total_trades, type: int, not_null: true}
      - {name: benchmark_return, type: float}
      - {name: commission_rate, type: float, not_null: true}
      - {name: slippage_rate, type: float, not_null: true}
      - {name: metrics_json, type: jsonb, not_null: true}
      - {name: equity_curve, type: jsonb}
      - {name: trade_log, type: jsonb}
      - {name: created_at, type: timestamp, default: now()}
    indexes:
      - {columns: [strategy_id, start_date, end_date], unique: false}
      - {columns: [created_at], unique: false}
    constraints:
      - type: check
        name: date_range_check
        definition: end_date > start_date

  # NEW: TDX import jobs table
  - name: tdx_import_jobs
    database: mysql
    classification: meta_data
    comment: TDX data import job tracking
    columns:
      - {name: id, type: bigint, auto_increment: true, primary_key: true}
      - {name: job_type, type: varchar(20), not_null: true}
      - {name: market, type: varchar(10), not_null: true}
      - {name: start_time, type: timestamp, not_null: true}
      - {name: end_time, type: timestamp}
      - {name: status, type: varchar(20), not_null: true}
      - {name: total_files, type: int, not_null: true}
      - {name: processed_files, type: int, not_null: true}
      - {name: failed_files, type: int, not_null: true}
      - {name: total_records, type: bigint, not_null: true}
      - {name: error_log, type: json}
      - {name: import_config, type: json, not_null: true}
      - {name: created_by, type: varchar(50), not_null: true}
    indexes:
      - {columns: [start_time], unique: false}
      - {columns: [status], unique: false}
```

Create tables:

```bash
cd /opt/claude/mystocks_spec
python -c "from db_manager.database_manager import ConfigDrivenTableManager; mgr = ConfigDrivenTableManager(); mgr.batch_create_tables('table_config.yaml')"
```

---

## Architecture Overview

### Directory Structure

```
mystocks_spec/
├── strategy/                   # Strategy engine
│   ├── base_strategy.py       # Abstract base class
│   ├── strategy_executor.py   # Multi-process execution
│   ├── signal_manager.py      # Signal CRUD operations
│   └── templates/              # Strategy templates
│
├── backtest/                   # Backtesting system
│   ├── vectorized_backtester.py  # Custom backtest engine
│   ├── performance_metrics.py    # Metrics calculation
│   └── risk_metrics.py           # Risk analysis
│
├── indicators/                 # Technical indicators
│   ├── tdx_functions.py       # TDX-compatible functions
│   ├── talib_wrapper.py       # TA-Lib integration
│   └── indicator_cache.py     # Caching layer
│
├── visualization/              # Chart generation
│   ├── kline_chart.py         # K-line charts
│   ├── signal_plot.py         # Signal markers
│   └── backtest_plot.py       # Performance charts
│
├── adapters/
│   └── tdx_adapter.py         # TDX binary file reader
│
└── config/
    └── strategy_config.yaml   # Strategy configuration
```

### Data Flow

```
1. TDX Data Import (One-time/Daily)
   ┌─────────────────┐
   │ TDX .day files  │
   │ /mnt/d/.../vipdoc│
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ TDXDataAdapter  │
   │ (Parse binary)  │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ UnifiedManager  │
   │ (Auto-routing)  │
   └────────┬────────┘
            │
            ▼
   PostgreSQL/TDengine (Daily K-lines)

2. Strategy Execution
   ┌─────────────────┐
   │ User Strategy   │
   │ (Python code)   │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ StrategyExecutor│
   │ (Multi-process) │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ Load Data       │
   │ (UnifiedManager)│
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ Calculate       │
   │ Indicators      │
   │ (TA-Lib/TDX)    │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ Generate Signals│
   └────────┬────────┘
            │
            ▼
   PostgreSQL (strategy_signals table)

3. Backtesting
   ┌─────────────────┐
   │ Signals         │
   │ (PostgreSQL)    │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ Price Data      │
   │ (PostgreSQL)    │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ Vectorized      │
   │ Backtester      │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ Performance     │
   │ Metrics         │
   └────────┬────────┘
            │
            ▼
   PostgreSQL (backtest_results table)

4. Visualization
   ┌─────────────────┐
   │ Price Data +    │
   │ Signals         │
   └────────┬────────┘
            │
            ▼
   ┌─────────────────┐
   │ KLineChart      │
   │ (mplfinance)    │
   └────────┬────────┘
            │
            ▼
   PNG/JPG/HTML files
```

---

## Key Implementation Patterns

### 1. Creating a Custom Strategy

```python
# strategy/templates/my_strategy.py
from strategy.base_strategy import BaseStrategy
from indicators.tdx_functions import MA, SMA, CROSS
from indicators.talib_wrapper import TALibIndicators
import pandas as pd

class MyMomentumStrategy(BaseStrategy):
    """Example momentum strategy using MA crossover"""

    def __init__(self, params=None):
        super().__init__(params)
        self.ma_short = params.get('ma_short', 5)
        self.ma_long = params.get('ma_long', 20)
        self.rsi_period = params.get('rsi_period', 14)

    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """
        Generate buy/sell signals from price data

        Args:
            data: DataFrame with OHLCV columns and DatetimeIndex

        Returns:
            Series with 'buy' boolean column
        """
        close = data['close'].values

        # Calculate indicators using TDX functions
        ma_short = MA(close, self.ma_short)
        ma_long = MA(close, self.ma_long)

        # Calculate RSI using TA-Lib
        rsi = TALibIndicators.calculate_rsi(close, self.rsi_period)

        # Generate buy signals
        buy_signal = (
            CROSS(ma_short, ma_long) &  # MA crossover
            (rsi < 30)                   # Oversold condition
        )

        return pd.Series(buy_signal, index=data.index, name='buy')

    def filter_stocks(self, stock_pool: list) -> list:
        """
        Pre-filter stocks before strategy execution

        Args:
            stock_pool: List of stock symbols

        Returns:
            Filtered list of symbols
        """
        # Example: Filter out ST stocks, banks, etc.
        filtered = [s for s in stock_pool if not s.startswith('ST')]
        return filtered
```

### 2. Executing a Strategy

```python
# Example: Execute strategy
from strategy.strategy_executor import StrategyExecutor
from unified_manager import MyStocksUnifiedManager
from strategy.templates.my_strategy import MyMomentumStrategy

# Initialize
manager = MyStocksUnifiedManager()
executor = StrategyExecutor(manager)

# Define strategy
strategy = MyMomentumStrategy(params={
    'ma_short': 5,
    'ma_long': 20,
    'rsi_period': 14
})

# Execute against stock pool
stock_pool = ["000001", "000002", "600000", ...]
results = executor.run_screening(
    strategy=strategy,
    stock_pool=stock_pool,
    parallel=True,
    execution_mode='full',
    start_date='2024-01-01',
    end_date='2024-12-31'
)

# Results saved to PostgreSQL automatically
print(f"Generated {results['signals_count']} signals")
print(f"Matched {len(results['stocks_matched'])} stocks")
```

### 3. Running a Backtest

```python
# Example: Backtest a strategy
from backtest.vectorized_backtester import VectorizedBacktester
from signal_manager import SignalManager

# Load signals from database
signal_mgr = SignalManager(manager)
signals = signal_mgr.get_signals(
    strategy_id=1,
    start_date='2020-01-01',
    end_date='2024-12-31'
)

# Run backtest
backtester = VectorizedBacktester(
    signals_df=signals,
    initial_capital=100000,
    commission_rate=0.0003,
    slippage_rate=0.0001
)

result = backtester.run()

# Display metrics
print(f"Total Return: {result['total_return']:.2%}")
print(f"Annualized Return: {result['annualized_return']:.2%}")
print(f"Max Drawdown: {result['max_drawdown']:.2%}")
print(f"Sharpe Ratio: {result['sharpe_ratio']:.2f}")
print(f"Win Rate: {result['win_rate']:.2%}")

# Save to database
backtester.save_result(strategy_id=1)
```

### 4. Generating K-Line Charts

```python
# Example: Generate chart with signals
from visualization.kline_chart import KLineChartGenerator

# Initialize chart generator
chart_gen = KLineChartGenerator(manager)

# Generate chart
chart_path = chart_gen.generate_chart(
    symbol='000001',
    start_date='2024-01-01',
    end_date='2024-12-31',
    strategy_id=1,
    show_signals=True,
    show_holding_periods=True,
    moving_averages=[5, 20, 60],
    output_format='png',
    dpi=150
)

print(f"Chart saved to: {chart_path}")
```

### 5. Importing TDX Data

```python
# Example: Import TDX data
from adapters.tdx_adapter import TDXDataAdapter

# Initialize adapter
adapter = TDXDataAdapter(
    tdx_root="/mnt/d/ProgramData/tdx_new/vipdoc",
    unified_manager=manager
)

# Discover and import all markets
job_id = adapter.import_market_data(
    market='all',  # sh, sz, bj, or 'all'
    import_type='incremental',  # 'full' or 'incremental'
    apply_adjustment=True  # Forward adjust for splits/dividends
)

# Monitor progress
status = adapter.get_import_status(job_id)
print(f"Progress: {status['processed_files']}/{status['total_files']}")
print(f"Records imported: {status['total_records']}")
```

---

## Testing

### Unit Tests

```bash
# Run strategy execution tests
pytest tests/test_strategy_executor.py

# Run backtest tests
pytest tests/test_backtest_engine.py

# Run TDX adapter tests
pytest tests/test_tdx_adapter.py

# Run indicator tests
pytest tests/test_indicators.py

# Run visualization tests
pytest tests/test_visualization.py

# Run all tests
pytest tests/ -v
```

### Integration Tests

```bash
# Test end-to-end strategy workflow
python examples/example_strategy_execution.py

# Test end-to-end backtest workflow
python examples/example_backtest.py

# Test visualization
python examples/example_visualization.py
```

---

## Performance Optimization

### 1. Indicator Caching

```python
# indicators/indicator_cache.py usage
from indicators.indicator_cache import IndicatorCache

cache = IndicatorCache(ttl=3600)  # 1-hour cache

# Cache automatically used by indicator functions
rsi = TALibIndicators.calculate_rsi(close, period=14)  # Cached internally
```

### 2. Multi-Process Strategy Execution

```python
# Configure worker processes
import os
cpu_count = os.cpu_count()

# Set in .env or config
STRATEGY_MAX_WORKERS = max(1, cpu_count - 2)  # Leave 2 cores for system
```

### 3. Database Query Optimization

```python
# Use composite indexes for fast queries
# Already defined in table_config.yaml:
# - (strategy_id, symbol, signal_date) for strategy signals
# - (strategy_id, start_date, end_date) for backtests

# Batch insert signals for performance
signal_mgr.batch_insert_signals(signals_list, batch_size=1000)
```

---

## Troubleshooting

### TA-Lib Installation Issues

If `pip install TA-Lib==0.6.7` fails:

```bash
# Check Python version (must be 3.12)
python3 --version

# Update pip
pip install --upgrade pip

# Try with --no-cache-dir
pip install --no-cache-dir TA-Lib==0.6.7

# If still failing, check platform
python -c "import platform; print(platform.platform())"
# Binary wheels available for: linux_x86_64, win_amd64, macosx_*
```

### TDX Data Path Issues

```bash
# Verify path exists
ls -la /mnt/d/ProgramData/tdx_new/vipdoc/

# Check subdirectories
ls /mnt/d/ProgramData/tdx_new/vipdoc/sh/  # Should show .day files

# Test with single file
python -c "
from adapters.tdx_adapter import TDXDataAdapter
adapter = TDXDataAdapter('/mnt/d/ProgramData/tdx_new/vipdoc')
df = adapter.read_day_file('/mnt/d/ProgramData/tdx_new/vipdoc/sh/sh600000.day')
print(df.head())
"
```

### Multi-Process Execution Issues

```bash
# If processes hang, check CPU/memory
htop

# Reduce worker count in .env
STRATEGY_MAX_WORKERS=2

# Test single-process first
executor.run_screening(..., parallel=False)
```

---

## Next Steps

1. **Read Documentation**:
   - `plan.md` - Implementation plan and architecture
   - `research.md` - Technology decisions and rationale
   - `data-model.md` - Entity definitions and database schemas
   - `contracts/strategy_api.yaml` - API specifications

2. **Implement Phase by Phase**:
   - Phase 1: TDX adapter + database setup
   - Phase 2: Strategy engine + signal generation
   - Phase 3: Vectorized backtester
   - Phase 4: Visualization module
   - Phase 5: Integration testing

3. **Follow Best Practices**:
   - Use `UnifiedDataManager` for all data access
   - Follow 5-tier data classification
   - Log all operations to monitoring database
   - Write comprehensive unit tests

4. **Monitor Performance**:
   - Track strategy execution time
   - Monitor backtest performance
   - Optimize indicator caching
   - Profile multi-process execution

---

## References

- MyStocks Constitution: `.specify/memory/constitution.md`
- Feature Specification: `specs/010-integrate-quantitative-trading/spec.md`
- Implementation Plan: `specs/010-integrate-quantitative-trading/plan.md`
- TA-Lib Documentation: https://ta-lib.github.io/ta-lib-python/
- mplfinance Documentation: https://github.com/matplotlib/mplfinance
