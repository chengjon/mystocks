"""
自选股管理服务模块
基于 PostgreSQL 实现用户自选股列表的管理功能
迁移自 OpenStock 项目，适配 PostgreSQL 数据库
"""

from typing import List, Dict, Optional
from datetime import datetime
import psycopg2
from psycopg2.extras import RealDictCursor
import os


class WatchlistError(Exception):
    """自选股操作错误"""
    pass


class WatchlistService:
    """自选股管理服务"""

    def __init__(self, db_config: Dict[str, str] = None):
        """
        初始化自选股管理服务

        Args:
            db_config: 数据库配置，如果未提供则从环境变量读取
        """
        if db_config:
            self.db_config = db_config
        else:
            self.db_config = {
                'host': os.getenv('POSTGRESQL_HOST', 'localhost'),
                'port': int(os.getenv('POSTGRESQL_PORT', 5432)),
                'database': os.getenv('POSTGRESQL_DATABASE', 'mystocks'),
                'user': os.getenv('POSTGRESQL_USER', 'postgres'),
                'password': os.getenv('POSTGRESQL_PASSWORD', '')
            }

        self._ensure_table_exists()

    def _get_connection(self):
        """
        获取数据库连接

        Returns:
            Connection: 数据库连接对象
        """
        try:
            return psycopg2.connect(**self.db_config)
        except psycopg2.Error as e:
            raise WatchlistError(f"数据库连接失败: {e}")

    def _ensure_table_exists(self):
        """确保自选股表和分组表存在"""
        create_table_sql = """
        -- 创建自选股分组表
        CREATE TABLE IF NOT EXISTS watchlist_groups (
            id SERIAL PRIMARY KEY,
            user_id INTEGER NOT NULL,
            group_name VARCHAR(100) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            sort_order INTEGER DEFAULT 0,
            UNIQUE(user_id, group_name)
        );

        CREATE INDEX IF NOT EXISTS idx_groups_user_id ON watchlist_groups(user_id);

        -- 创建自选股表（带分组支持）
        CREATE TABLE IF NOT EXISTS user_watchlist (
            id SERIAL PRIMARY KEY,
            user_id INTEGER NOT NULL,
            group_id INTEGER REFERENCES watchlist_groups(id) ON DELETE CASCADE,
            symbol VARCHAR(20) NOT NULL,
            display_name VARCHAR(100),
            exchange VARCHAR(50),
            market VARCHAR(10),
            added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            notes TEXT,
            sort_order INTEGER DEFAULT 0,
            UNIQUE(user_id, group_id, symbol)
        );

        CREATE INDEX IF NOT EXISTS idx_watchlist_user_id ON user_watchlist(user_id);
        CREATE INDEX IF NOT EXISTS idx_watchlist_group_id ON user_watchlist(group_id);
        CREATE INDEX IF NOT EXISTS idx_watchlist_symbol ON user_watchlist(symbol);

        -- 为每个用户创建默认分组（如果不存在）
        INSERT INTO watchlist_groups (user_id, group_name, sort_order)
        SELECT DISTINCT user_id, '默认分组', 0
        FROM user_watchlist
        WHERE user_id NOT IN (
            SELECT user_id FROM watchlist_groups WHERE group_name = '默认分组'
        )
        ON CONFLICT DO NOTHING;
        """

        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute(create_table_sql)
                conn.commit()
        except psycopg2.Error as e:
            print(f"创建自选股表时警告: {e}")

    def add_to_watchlist(self, user_id: int, symbol: str,
                        display_name: str = None, exchange: str = None,
                        notes: str = None) -> bool:
        """
        添加股票到自选股列表

        Args:
            user_id: 用户ID
            symbol: 股票代码
            display_name: 显示名称
            exchange: 交易所
            notes: 备注

        Returns:
            bool: 添加是否成功
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    # 使用 ON CONFLICT 来处理重复插入
                    insert_sql = """
                    INSERT INTO user_watchlist
                    (user_id, symbol, display_name, exchange, notes, added_at)
                    VALUES (%s, %s, %s, %s, %s, %s)
                    ON CONFLICT (user_id, symbol)
                    DO UPDATE SET
                        display_name = EXCLUDED.display_name,
                        exchange = EXCLUDED.exchange,
                        notes = EXCLUDED.notes,
                        added_at = EXCLUDED.added_at
                    """
                    cur.execute(insert_sql, (
                        user_id, symbol, display_name, exchange, notes, datetime.now()
                    ))
                conn.commit()
                return True
        except psycopg2.Error as e:
            print(f"添加自选股时发生错误: {e}")
            return False

    def remove_from_watchlist(self, user_id: int, symbol: str) -> bool:
        """
        从自选股列表中删除股票

        Args:
            user_id: 用户ID
            symbol: 股票代码

        Returns:
            bool: 删除是否成功
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    delete_sql = """
                    DELETE FROM user_watchlist
                    WHERE user_id = %s AND symbol = %s
                    """
                    cur.execute(delete_sql, (user_id, symbol))
                    deleted_count = cur.rowcount
                conn.commit()
                return deleted_count > 0
        except psycopg2.Error as e:
            print(f"删除自选股时发生错误: {e}")
            return False

    def get_user_watchlist(self, user_id: int) -> List[Dict]:
        """
        获取用户的自选股列表

        Args:
            user_id: 用户ID

        Returns:
            List[Dict]: 自选股列表，每个元素包含股票信息
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor(cursor_factory=RealDictCursor) as cur:
                    select_sql = """
                    SELECT
                        id, symbol, display_name, exchange,
                        added_at, notes
                    FROM user_watchlist
                    WHERE user_id = %s
                    ORDER BY added_at DESC
                    """
                    cur.execute(select_sql, (user_id,))
                    rows = cur.fetchall()

                    # 转换为列表
                    return [dict(row) for row in rows]
        except psycopg2.Error as e:
            print(f"获取自选股列表时发生错误: {e}")
            return []

    def get_watchlist_symbols(self, user_id: int) -> List[str]:
        """
        获取用户的自选股代码列表

        Args:
            user_id: 用户ID

        Returns:
            List[str]: 股票代码列表
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    select_sql = """
                    SELECT symbol
                    FROM user_watchlist
                    WHERE user_id = %s
                    ORDER BY added_at DESC
                    """
                    cur.execute(select_sql, (user_id,))
                    rows = cur.fetchall()
                    return [row[0] for row in rows]
        except psycopg2.Error as e:
            print(f"获取自选股代码列表时发生错误: {e}")
            return []

    def is_in_watchlist(self, user_id: int, symbol: str) -> bool:
        """
        检查股票是否在用户的自选股列表中

        Args:
            user_id: 用户ID
            symbol: 股票代码

        Returns:
            bool: 是否在自选股列表中
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    select_sql = """
                    SELECT 1 FROM user_watchlist
                    WHERE user_id = %s AND symbol = %s
                    LIMIT 1
                    """
                    cur.execute(select_sql, (user_id, symbol))
                    return cur.fetchone() is not None
        except psycopg2.Error as e:
            print(f"检查自选股时发生错误: {e}")
            return False

    def update_watchlist_notes(self, user_id: int, symbol: str, notes: str) -> bool:
        """
        更新自选股备注

        Args:
            user_id: 用户ID
            symbol: 股票代码
            notes: 备注内容

        Returns:
            bool: 更新是否成功
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    update_sql = """
                    UPDATE user_watchlist
                    SET notes = %s
                    WHERE user_id = %s AND symbol = %s
                    """
                    cur.execute(update_sql, (notes, user_id, symbol))
                    updated_count = cur.rowcount
                conn.commit()
                return updated_count > 0
        except psycopg2.Error as e:
            print(f"更新自选股备注时发生错误: {e}")
            return False

    def get_watchlist_count(self, user_id: int) -> int:
        """
        获取用户自选股数量

        Args:
            user_id: 用户ID

        Returns:
            int: 自选股数量
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    select_sql = """
                    SELECT COUNT(*) FROM user_watchlist
                    WHERE user_id = %s
                    """
                    cur.execute(select_sql, (user_id,))
                    result = cur.fetchone()
                    return result[0] if result else 0
        except psycopg2.Error as e:
            print(f"获取自选股数量时发生错误: {e}")
            return 0

    def clear_watchlist(self, user_id: int) -> bool:
        """
        清空用户的自选股列表

        Args:
            user_id: 用户ID

        Returns:
            bool: 清空是否成功
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cur:
                    delete_sql = """
                    DELETE FROM user_watchlist
                    WHERE user_id = %s
                    """
                    cur.execute(delete_sql, (user_id,))
                conn.commit()
                return True
        except psycopg2.Error as e:
            print(f"清空自选股列表时发生错误: {e}")
            return False


# 创建全局实例
_watchlist_service = None

def get_watchlist_service() -> WatchlistService:
    """
    获取自选股服务实例（单例模式）

    Returns:
        WatchlistService: 自选股服务实例
    """
    global _watchlist_service
    if _watchlist_service is None:
        _watchlist_service = WatchlistService()
    return _watchlist_service
