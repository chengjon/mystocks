# MyStocks WebåŠŸèƒ½ä¼˜åŒ– - ç¬¬ä¸€é˜¶æ®µæŠ€æœ¯å®æ–½æŒ‡å—

## ğŸ“‹ é˜¶æ®µä¸€æ¦‚è¿°

**ç›®æ ‡**: æ ¸å¿ƒæŠ€æœ¯è¡¥å¼º (3-4å‘¨)
**é‡ç‚¹ä»»åŠ¡**: Klinecharté›†æˆ + TA-Libå®Œæ•´å®ç° + Aè‚¡äº¤æ˜“è§„åˆ™é€‚é…
**æˆåŠŸæ ‡å‡†**: ä¸“ä¸šKçº¿å›¾ + 70+æŠ€æœ¯æŒ‡æ ‡ + 100%å‡†ç¡®Aè‚¡è§„åˆ™

---

## ğŸ¯ ä»»åŠ¡1: Klinechartä¸“ä¸šKçº¿å›¾é›†æˆ (1å‘¨)

### æŠ€æœ¯æ–¹æ¡ˆé€‰æ‹©

ç»è¿‡æŠ€æœ¯è¯„ä¼°ï¼Œæ¨èé‡‡ç”¨ **Lightweight Charts + æŠ€æœ¯æŒ‡æ ‡åº“** æ–¹æ¡ˆï¼š

**ä¼˜åŠ¿**:
- âœ… è½»é‡çº§ï¼Œæ€§èƒ½ä¼˜ç§€
- âœ… æ”¯æŒTypeScript
- âœ… ä¸°å¯Œçš„äº¤äº’åŠŸèƒ½
- âœ… ç¤¾åŒºæ´»è·ƒï¼Œç»´æŠ¤æ€§å¥½
- âœ… MITè®¸å¯ï¼Œå•†ä¸šå‹å¥½

**å¤‡é€‰æ–¹æ¡ˆ**:
- TradingView Charting Library (éœ€è¦å•†ä¸šè®¸å¯)
- Klinechart Pythonåº“ (éœ€è¦WebSocketæ¡¥æ¥)
- è‡ªç ”Kçº¿ç»„ä»¶ (å¼€å‘å‘¨æœŸé•¿)

### å®æ–½æ­¥éª¤

#### Step 1: ç¯å¢ƒå‡†å¤‡ (0.5å¤©)

```bash
# 1. å®‰è£…ä¾èµ–
cd /opt/claude/mystocks_spec/web/frontend
npm install lightweight-charts
npm install @types/lightweight-charts
npm install technicalindicators
npm install dayjs

# 2. ç±»å‹å£°æ˜æ–‡ä»¶åˆ›å»º
# types/lightweight-charts.d.ts
declare module 'lightweight-charts' {
  export interface IChartApi {
    addCandlestickSeries(options?: any): ISeriesApi
    addHistogramSeries(options?: any): ISeriesApi
    addLineSeries(options?: any): ISeriesApi
    // ... æ›´å¤šæ¥å£
  }

  export interface ISeriesApi {
    setData(data: any[]): void
    update(data: any): void
  }

  export function createChart(
    container: HTMLElement,
    options?: any
  ): IChartApi
}
```

#### Step 2: æ ¸å¿ƒç»„ä»¶å¼€å‘ (2å¤©)

```vue
<!-- components/charts/ProKLineChart.vue -->
<template>
  <div class="pro-kline-chart">
    <!-- å·¥å…·æ  -->
    <div class="chart-toolbar">
      <el-button-group>
        <el-button
          v-for="period in periods"
          :key="period"
          :type="currentPeriod === period ? 'primary' : 'default'"
          @click="switchPeriod(period)"
          size="small"
        >
          {{ period }}
        </el-button>
      </el-button-group>

      <el-divider direction="vertical" />

      <!-- æŒ‡æ ‡é€‰æ‹© -->
      <el-dropdown @command="addIndicator">
        <el-button size="small">
          æ·»åŠ æŒ‡æ ‡ <el-icon><arrow-down /></el-icon>
        </el-button>
        <template #dropdown>
          <el-dropdown-menu>
            <el-dropdown-item command="MA">MAå‡çº¿</el-dropdown-item>
            <el-dropdown-item command="EMA">EMAæŒ‡æ•°å‡çº¿</el-dropdown-item>
            <el-dropdown-item command="MACD">MACD</el-dropdown-item>
            <el-dropdown-item command="RSI">RSI</el-dropdown-item>
            <el-dropdown-item command="KDJ">KDJ</el-dropdown-item>
            <el-dropdown-item command="BOLL">å¸ƒæ—å¸¦</el-dropdown-item>
          </el-dropdown-menu>
        </template>
      </el-dropdown>

      <!-- å›¾è¡¨ç±»å‹ -->
      <el-select
        v-model="chartType"
        @change="changeChartType"
        size="small"
        style="width: 120px"
      >
        <el-option label="Kçº¿" value="candlestick" />
        <el-option label="ç¾å›½çº¿" value="bar" />
        <el-option label="çº¿å›¾" value="line" />
      </el-select>

      <!-- å…¨å±æ˜¾ç¤º -->
      <el-button
        @click="toggleFullscreen"
        size="small"
        :icon="isFullscreen ? 'FullScreenExit' : 'FullScreen'"
      >
        {{ isFullscreen ? 'é€€å‡ºå…¨å±' : 'å…¨å±' }}
      </el-button>
    </div>

    <!-- ä¸»å›¾è¡¨åŒºåŸŸ -->
    <div
      ref="chartContainer"
      :class="['chart-container', { fullscreen: isFullscreen }]"
    ></div>

    <!-- æŒ‡æ ‡é¢æ¿ -->
    <div class="indicators-panel" v-if="activeIndicators.length > 0">
      <el-tag
        v-for="indicator in activeIndicators"
        :key="indicator"
        closable
        @close="removeIndicator(indicator)"
        size="small"
      >
        {{ indicator }}
      </el-tag>
    </div>

    <!-- åå­—çº¿ä¿¡æ¯ -->
    <div class="crosshair-info" v-if="crosshairData">
      <el-card>
        <div class="crosshair-data">
          <span>æ—¶é—´: {{ crosshairData.time }}</span>
          <span>å¼€ç›˜: {{ crosshairData.open?.toFixed(2) }}</span>
          <span>æœ€é«˜: {{ crosshairData.high?.toFixed(2) }}</span>
          <span>æœ€ä½: {{ crosshairData.low?.toFixed(2) }}</span>
          <span>æ”¶ç›˜: {{ crosshairData.close?.toFixed(2) }}</span>
          <span>æˆäº¤é‡: {{ crosshairData.volume }}</span>
        </div>
      </el-card>
    </div>
  </div>
</template>

<script>
import { createChart, CrosshairMode, PriceScaleMode } from 'lightweight-charts'
import { SMA, EMA, MACD, RSI, KDJ, BollingerBands } from 'technicalindicators'
import dayjs from 'dayjs'

export default {
  name: 'ProKLineChart',

  props: {
    symbol: {
      type: String,
      required: true
    },
    data: {
      type: Array,
      required: true
    },
    height: {
      type: Number,
      default: 600
    }
  },

  data() {
    return {
      chart: null,
      candlestickSeries: null,
      volumeSeries: null,
      indicatorSeries: new Map(),
      currentPeriod: '1d',
      periods: ['1m', '5m', '15m', '1h', '1d', '1w', '1M'],
      chartType: 'candlestick',
      isFullscreen: false,
      activeIndicators: [],
      crosshairData: null,
      chartOptions: {
        layout: {
          background: { color: '#ffffff' },
          textColor: '#333',
        },
        grid: {
          vertLines: { color: '#f0f0f0' },
          horzLines: { color: '#f0f0f0' },
        },
        crosshair: {
          mode: CrosshairMode.Normal,
        },
        rightPriceScale: {
          borderColor: '#ccc',
        },
        timeScale: {
          borderColor: '#ccc',
          timeVisible: true,
          secondsVisible: false,
        },
      }
    }
  },

  mounted() {
    this.initChart()
    this.loadChartData()
  },

  beforeUnmount() {
    if (this.chart) {
      this.chart.remove()
    }
  },

  methods: {
    initChart() {
      const container = this.$refs.chartContainer
      this.chart = createChart(container, {
        ...this.chartOptions,
        width: container.clientWidth,
        height: this.height,
      })

      // æ·»åŠ ä¸»Kçº¿ç³»åˆ—
      this.candlestickSeries = this.chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
      })

      // æ·»åŠ æˆäº¤é‡ç³»åˆ—
      this.volumeSeries = this.chart.addHistogramSeries({
        color: '#26a69a',
        priceFormat: {
          type: 'volume',
        },
        priceScaleId: 'volume',
      })

      // æˆäº¤é‡åˆ»åº¦
      this.chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.8,
          bottom: 0,
        },
      })

      // åå­—çº¿äº‹ä»¶
      this.chart.subscribeCrosshairMove((param) => {
        if (param.time) {
          this.crosshairData = param.seriesPrices.get(this.candlestickSeries)
        } else {
          this.crosshairData = null
        }
      })

      // çª—å£å¤§å°å˜åŒ–
      window.addEventListener('resize', this.handleResize)
    },

    async loadChartData() {
      try {
        // æ¨¡æ‹ŸAPIè°ƒç”¨
        const response = await this.$api.get(`/api/market/kline/${this.symbol}`, {
          params: { period: this.currentPeriod }
        })

        const processedData = this.processChartData(response.data)
        this.candlestickSeries.setData(processedData.candles)
        this.volumeSeries.setData(processedData.volume)

        // å¦‚æœæœ‰æ¿€æ´»çš„æŒ‡æ ‡ï¼Œé‡æ–°è®¡ç®—
        if (this.activeIndicators.length > 0) {
          await this.recalculateIndicators()
        }

      } catch (error) {
        console.error('åŠ è½½Kçº¿æ•°æ®å¤±è´¥:', error)
        this.$message.error('åŠ è½½Kçº¿æ•°æ®å¤±è´¥')
      }
    },

    processChartData(rawData) {
      return {
        candles: rawData.map(item => ({
          time: item.time,
          open: item.open,
          high: item.high,
          low: item.low,
          close: item.close
        })),
        volume: rawData.map(item => ({
          time: item.time,
          value: item.volume,
          color: item.close >= item.open ? '#26a69a' : '#ef5350'
        }))
      }
    },

    async switchPeriod(period) {
      this.currentPeriod = period
      await this.loadChartData()
    },

    async addIndicator(indicator) {
      if (!this.activeIndicators.includes(indicator)) {
        this.activeIndicators.push(indicator)
        await this.recalculateIndicators()
      }
    },

    async removeIndicator(indicator) {
      const index = this.activeIndicators.indexOf(indicator)
      if (index > -1) {
        this.activeIndicators.splice(index, 1)

        // ç§»é™¤æŒ‡æ ‡ç³»åˆ—
        const series = this.indicatorSeries.get(indicator)
        if (series) {
          this.chart.removeSeries(series)
          this.indicatorSeries.delete(indicator)
        }

        await this.recalculateIndicators()
      }
    },

    async recalculateIndicators() {
      const closePrices = this.data.map(item => item.close)

      for (const indicator of this.activeIndicators) {
        let indicatorData = []

        try {
          switch (indicator) {
            case 'MA':
              const sma20 = SMA.calculate({ period: 20, values: closePrices })
              const sma60 = SMA.calculate({ period: 60, values: closePrices })

              indicatorData = this.data.map((item, index) => ({
                time: item.time,
                value: index < 20 ? null : sma20[index - 20]
              })).filter(item => item.value !== null)

              this.createLineSeries(indicator, indicatorData, '#2196F3')
              break

            case 'EMA':
              const ema12 = EMA.calculate({ period: 12, values: closePrices })
              const ema26 = EMA.calculate({ period: 26, values: closePrices })

              indicatorData = this.data.map((item, index) => ({
                time: item.time,
                value: index < 26 ? null : ema26[index - 26]
              })).filter(item => item.value !== null)

              this.createLineSeries(indicator, indicatorData, '#FF9800')
              break

            case 'MACD':
              const macd = MACD.calculate({
                fastPeriod: 12,
                slowPeriod: 26,
                signalPeriod: 9,
                values: closePrices
              })

              // MACDçº¿
              const macdLine = macd.map((item, index) => ({
                time: this.data[index + 26].time,
                value: item.MACD
              }))

              // ä¿¡å·çº¿
              const signalLine = macd.map((item, index) => ({
                time: this.data[index + 26].time,
                value: item.signal
              }))

              // æŸ±çŠ¶å›¾
              const histogram = macd.map((item, index) => ({
                time: this.data[index + 26].time,
                value: item.histogram,
                color: item.histogram >= 0 ? '#4CAF50' : '#F44336'
              }))

              this.createLineSeries(`${indicator}_MACD`, macdLine, '#2196F3')
              this.createLineSeries(`${indicator}_Signal`, signalLine, '#FF9800')
              this.createHistogramSeries(`${indicator}_Histogram`, histogram)
              break

            case 'RSI':
              const rsi = RSI.calculate({ period: 14, values: closePrices })

              indicatorData = this.data.map((item, index) => ({
                time: item.time,
                value: index < 14 ? null : rsi[index - 14]
              })).filter(item => item.value !== null)

              this.createLineSeries(indicator, indicatorData, '#9C27B0')
              break

            case 'KDJ':
              const kdj = KDJ.calculate({
                high: this.data.map(item => item.high),
                low: this.data.map(item => item.low),
                close: closePrices,
                period: 9,
                signalPeriod: 3
              })

              const kLine = kdj.map((item, index) => ({
                time: this.data[index + 9].time,
                value: item.k
              }))

              const dLine = kdj.map((item, index) => ({
                time: this.data[index + 9].time,
                value: item.d
              }))

              this.createLineSeries('KDJ_K', kLine, '#2196F3')
              this.createLineSeries('KDJ_D', dLine, '#FF9800')
              break
          }
        } catch (error) {
          console.error(`è®¡ç®—${indicator}æŒ‡æ ‡å¤±è´¥:`, error)
        }
      }
    },

    createLineSeries(name, data, color) {
      // å…ˆç§»é™¤å·²å­˜åœ¨çš„ç³»åˆ—
      const existingSeries = this.indicatorSeries.get(name)
      if (existingSeries) {
        this.chart.removeSeries(existingSeries)
      }

      const series = this.chart.addLineSeries({
        color,
        lineWidth: 2,
        priceScaleId: 'right',
      })

      series.setData(data)
      this.indicatorSeries.set(name, series)
    },

    createHistogramSeries(name, data) {
      const existingSeries = this.indicatorSeries.get(name)
      if (existingSeries) {
        this.chart.removeSeries(existingSeries)
      }

      const series = this.chart.addHistogramSeries({
        color: data[0]?.color || '#2196F3',
        priceScaleId: 'right',
      })

      series.setData(data)
      this.indicatorSeries.set(name, series)
    },

    toggleFullscreen() {
      this.isFullscreen = !this.isFullscreen
      this.$nextTick(() => {
        if (this.chart) {
          this.chart.applyOptions({
            width: this.$refs.chartContainer.clientWidth,
            height: this.isFullscreen ? window.innerHeight : this.height
          })
        }
      })
    },

    handleResize() {
      if (this.chart) {
        this.chart.applyOptions({
          width: this.$refs.chartContainer.clientWidth
        })
      }
    }
  }
}
</script>

<style scoped>
.pro-kline-chart {
  width: 100%;
  position: relative;
}

.chart-toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #f5f5f5;
  border-bottom: 1px solid #e0e0e0;
}

.chart-container {
  width: 100%;
  position: relative;
}

.chart-container.fullscreen {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 9999;
  background: white;
}

.indicators-panel {
  padding: 8px 12px;
  background: #fafafa;
  border-top: 1px solid #e0e0e0;
}

.crosshair-info {
  position: absolute;
  top: 60px;
  right: 20px;
  z-index: 10;
}

.crosshair-data {
  display: flex;
  gap: 12px;
  font-size: 12px;
}

.crosshair-data span {
  color: #666;
}
</style>
```

#### Step 3: åç«¯APIå¼€å‘ (1å¤©)

```python
# api/endpoints/kline.py
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
import pandas as pd
from datetime import datetime, timedelta
import numpy as np

router = APIRouter()

@router.get("/market/kline/{symbol}")
async def get_kline_data(
    symbol: str,
    period: str = Query("1d", description="æ—¶é—´å‘¨æœŸ: 1m,5m,15m,1h,1d,1w"),
    limit: int = Query(200, description="è¿”å›æ•°æ®æ¡æ•°"),
    start_date: Optional[str] = Query(None, description="å¼€å§‹æ—¥æœŸ"),
    end_date: Optional[str] = Query(None, description="ç»“æŸæ—¥æœŸ")
):
    """
    è·å–Kçº¿æ•°æ®
    """
    try:
        # å‚æ•°éªŒè¯
        valid_periods = ['1m', '5m', '15m', '1h', '1d', '1w']
        if period not in valid_periods:
            raise HTTPException(
                status_code=400,
                detail=f"ä¸æ”¯æŒçš„æ—¶é—´å‘¨æœŸï¼Œæ”¯æŒ: {valid_periods}"
            )

        # è·å–æ•°æ®
        data = await fetch_kline_data(
            symbol=symbol,
            period=period,
            limit=limit,
            start_date=start_date,
            end_date=end_date
        )

        if not data:
            raise HTTPException(status_code=404, detail="æœªæ‰¾åˆ°Kçº¿æ•°æ®")

        # æ•°æ®æ ¼å¼åŒ–
        formatted_data = []
        for item in data:
            formatted_data.append({
                'time': int(item['timestamp']),
                'open': float(item['open']),
                'high': float(item['high']),
                'low': float(item['low']),
                'close': float(item['close']),
                'volume': float(item['volume'])
            })

        return {
            'code': 0,
            'message': 'success',
            'data': {
                'symbol': symbol,
                'period': period,
                'data': formatted_data,
                'count': len(formatted_data)
            }
        }

    except Exception as e:
        logger.error(f"è·å–{symbol} Kçº¿æ•°æ®å¤±è´¥: {str(e)}")
        raise HTTPException(status_code=500, detail=f"è·å–Kçº¿æ•°æ®å¤±è´¥: {str(e)}")

@router.get("/market/real-time/{symbol}")
async def get_real_time_data(symbol: str):
    """
    è·å–å®æ—¶è¡Œæƒ…æ•°æ®
    """
    try:
        # è·å–æœ€æ–°ä»·æ ¼æ•°æ®
        data = await fetch_real_time_data(symbol)

        return {
            'code': 0,
            'message': 'success',
            'data': data
        }

    except Exception as e:
        logger.error(f"è·å–{symbol}å®æ—¶æ•°æ®å¤±è´¥: {str(e)}")
        raise HTTPException(status_code=500, detail=f"è·å–å®æ—¶æ•°æ®å¤±è´¥: {str(e)}")
```

#### Step 4: é›†æˆæµ‹è¯• (0.5å¤©)

```javascript
// tests/e2e/kline-chart.spec.js
import { test, expect } from '@playwright/test'

test.describe('ä¸“ä¸šKçº¿å›¾åŠŸèƒ½', () => {
  test('Kçº¿å›¾æ¸²æŸ“å’Œäº¤äº’', async ({ page }) => {
    // è®¿é—®è‚¡ç¥¨è¯¦æƒ…é¡µé¢
    await page.goto('/stock/SH600000')

    // ç­‰å¾…Kçº¿å›¾ç»„ä»¶åŠ è½½
    await page.waitForSelector('.pro-kline-chart')

    // æ£€æŸ¥å›¾è¡¨å®¹å™¨å­˜åœ¨
    await expect(page.locator('.chart-container')).toBeVisible()

    // æµ‹è¯•å‘¨æœŸåˆ‡æ¢
    await page.click('button:has-text("5m")')
    await page.waitForTimeout(1000)

    // æ£€æŸ¥æ˜¯å¦æœ‰Kçº¿æ•°æ®
    const chartData = await page.evaluate(() => {
      const chart = document.querySelector('.pro-kline-chart')
      return chart ? chart.textContent.length > 0 : false
    })

    expect(chartData).toBe(true)
  })

  test('æŠ€æœ¯æŒ‡æ ‡åŠŸèƒ½', async ({ page }) => {
    await page.goto('/stock/SH600000')

    // æ·»åŠ MAæŒ‡æ ‡
    await page.click('.chart-toolbar .el-dropdown')
    await page.click('.el-dropdown-menu >> text=MAå‡çº¿')

    // æ£€æŸ¥æŒ‡æ ‡æ˜¯å¦æ˜¾ç¤º
    await expect(page.locator('.indicators-panel >> text=MA')).toBeVisible()

    // æµ‹è¯•æŒ‡æ ‡åˆ é™¤
    await page.click('.indicators-panel .el-tag .el-icon-close')
    await expect(page.locator('.indicators-panel >> text=MA')).not.toBeVisible()
  })
})
```

---

## ğŸ¯ ä»»åŠ¡2: TA-LibæŠ€æœ¯æŒ‡æ ‡åº“å®Œæ•´å®ç° (1.5å‘¨)

### æŠ€æœ¯æ–¹æ¡ˆ

**å‰ç«¯æ–¹æ¡ˆ**: technicalindicators JavaScriptåº“
**åç«¯æ–¹æ¡ˆ**: Python TA-Lib + è®¡ç®—API
**ç¼“å­˜æ–¹æ¡ˆ**: Redisç¼“å­˜è®¡ç®—ç»“æœ

### å®æ–½æ­¥éª¤

#### Step 1: åç«¯TA-Libé›†æˆ (3å¤©)

```python
# services/indicators.py
import talib
import numpy as np
import pandas as pd
from typing import List, Dict, Any, Optional
import logging
from datetime import datetime
import redis
import json

logger = logging.getLogger(__name__)

class TALibIndicatorEngine:
    def __init__(self):
        self.redis_client = redis.Redis(
            host='localhost', port=6379, db=1, decode_responses=True
        )
        self.cache_ttl = 300  # 5åˆ†é’Ÿç¼“å­˜

    async def calculate_indicators(
        self,
        symbol: str,
        data: List[Dict],
        indicators: List[str]
    ) -> Dict[str, Any]:
        """
        è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        """
        try:
            # è½¬æ¢ä¸ºnumpyæ•°ç»„
            prices = np.array([item['close'] for item in data])
            highs = np.array([item['high'] for item in data])
            lows = np.array([item['low'] for item in data])
            volumes = np.array([item['volume'] for item in data])

            results = {}

            for indicator in indicators:
                # æ£€æŸ¥ç¼“å­˜
                cache_key = f"indicators:{symbol}:{indicator}:{len(data)}"
                cached_result = self.redis_client.get(cache_key)

                if cached_result:
                    results[indicator] = json.loads(cached_result)
                    continue

                # è®¡ç®—æŒ‡æ ‡
                indicator_result = await self._calculate_single_indicator(
                    indicator, prices, highs, lows, volumes, data
                )

                results[indicator] = indicator_result

                # ç¼“å­˜ç»“æœ
                self.redis_client.setex(
                    cache_key,
                    self.cache_ttl,
                    json.dumps(indicator_result, default=str)
                )

            return results

        except Exception as e:
            logger.error(f"è®¡ç®—æŠ€æœ¯æŒ‡æ ‡å¤±è´¥: {str(e)}")
            raise

    async def _calculate_single_indicator(
        self,
        indicator: str,
        prices: np.ndarray,
        highs: np.ndarray,
        lows: np.ndarray,
        volumes: np.ndarray,
        original_data: List[Dict]
    ) -> Dict[str, Any]:
        """è®¡ç®—å•ä¸ªæŠ€æœ¯æŒ‡æ ‡"""

        if indicator == 'SMA':
            return self._calculate_sma(prices, original_data)
        elif indicator == 'EMA':
            return self._calculate_ema(prices, original_data)
        elif indicator == 'MACD':
            return self._calculate_macd(prices, original_data)
        elif indicator == 'RSI':
            return self._calculate_rsi(prices, original_data)
        elif indicator == 'KDJ':
            return self._calculate_kdj(highs, lows, prices, original_data)
        elif indicator == 'BOLL':
            return self._calculate_bollinger(prices, original_data)
        elif indicator == 'CCI':
            return self._calculate_cci(highs, lows, prices, original_data)
        elif indicator == 'ATR':
            return self._calculate_atr(highs, lows, prices, original_data)
        elif indicator == 'OBV':
            return self._calculate_obv(prices, volumes, original_data)
        elif indicator == 'ADX':
            return self._calculate_adx(highs, lows, prices, original_data)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æŠ€æœ¯æŒ‡æ ‡: {indicator}")

    def _calculate_sma(self, prices: np.ndarray, original_data: List[Dict]) -> Dict[str, Any]:
        """è®¡ç®—ç®€å•ç§»åŠ¨å¹³å‡çº¿"""
        periods = [5, 10, 20, 30, 60, 120, 250]
        results = {}

        for period in periods:
            if len(prices) >= period:
                sma_values = talib.SMA(prices, timeperiod=period)

                # åªè¿”å›æœ‰æ•ˆæ•°æ®
                valid_data = []
                for i in range(period-1, len(sma_values)):
                    if not np.isnan(sma_values[i]):
                        valid_data.append({
                            'time': original_data[i]['timestamp'],
                            'value': float(sma_values[i])
                        })

                results[f'SMA{period}'] = valid_data

        return results

    def _calculate_ema(self, prices: np.ndarray, original_data: List[Dict]) -> Dict[str, Any]:
        """è®¡ç®—æŒ‡æ•°ç§»åŠ¨å¹³å‡çº¿"""
        periods = [5, 10, 12, 20, 26, 60, 120]
        results = {}

        for period in periods:
            if len(prices) >= period:
                ema_values = talib.EMA(prices, timeperiod=period)

                valid_data = []
                for i in range(period-1, len(ema_values)):
                    if not np.isnan(ema_values[i]):
                        valid_data.append({
                            'time': original_data[i]['timestamp'],
                            'value': float(ema_values[i])
                        })

                results[f'EMA{period}'] = valid_data

        return results

    def _calculate_macd(self, prices: np.ndarray, original_data: List[Dict]) -> Dict[str, Any]:
        """è®¡ç®—MACDæŒ‡æ ‡"""
        if len(prices) < 26:
            return {}

        macd, signal, histogram = talib.MACD(
            prices,
            fastperiod=12,
            slowperiod=26,
            signalperiod=9
        )

        results = {}

        # MACDçº¿
        macd_data = []
        for i in range(len(macd)):
            if not np.isnan(macd[i]):
                macd_data.append({
                    'time': original_data[i + 25]['timestamp'],  # å‰25ä¸ªæ•°æ®æ— æ•ˆ
                    'value': float(macd[i])
                })
        results['MACD'] = macd_data

        # ä¿¡å·çº¿
        signal_data = []
        for i in range(len(signal)):
            if not np.isnan(signal[i]):
                signal_data.append({
                    'time': original_data[i + 25]['timestamp'],
                    'value': float(signal[i])
                })
        results['MACD_Signal'] = signal_data

        # æŸ±çŠ¶å›¾
        histogram_data = []
        for i in range(len(histogram)):
            if not np.isnan(histogram[i]):
                histogram_data.append({
                    'time': original_data[i + 25]['timestamp'],
                    'value': float(histogram[i]),
                    'color': 'red' if histogram[i] > 0 else 'green'
                })
        results['MACD_Histogram'] = histogram_data

        return results

    def _calculate_rsi(self, prices: np.ndarray, original_data: List[Dict]) -> Dict[str, Any]:
        """è®¡ç®—RSIæŒ‡æ ‡"""
        if len(prices) < 14:
            return {}

        periods = [6, 14, 21]
        results = {}

        for period in periods:
            if len(prices) >= period:
                rsi_values = talib.RSI(prices, timeperiod=period)

                valid_data = []
                for i in range(period-1, len(rsi_values)):
                    if not np.isnan(rsi_values[i]):
                        valid_data.append({
                            'time': original_data[i]['timestamp'],
                            'value': float(rsi_values[i])
                        })

                results[f'RSI{period}'] = valid_data

        return results

    def _calculate_kdj(self, highs: np.ndarray, lows: np.ndarray, prices: np.ndarray, original_data: List[Dict]) -> Dict[str, Any]:
        """è®¡ç®—KDJæŒ‡æ ‡"""
        if len(prices) < 9:
            return {}

        k_values = np.full_like(prices, np.nan)
        d_values = np.full_like(prices, np.nan)
        j_values = np.full_like(prices, np.nan)

        # è®¡ç®—RSV
        for i in range(8, len(prices)):
            lowest = np.min(lows[i-8:i+1])
            highest = np.max(highs[i-8:i+1])

            if highest != lowest:
                rsv = (prices[i] - lowest) / (highest - lowest) * 100
            else:
                rsv = 50

            # è®¡ç®—Kå€¼
            if i == 8:
                k_values[i] = rsv
            else:
                k_values[i] = k_values[i-1] * 2/3 + rsv * 1/3

            # è®¡ç®—Då€¼
            if i == 8:
                d_values[i] = k_values[i]
            else:
                d_values[i] = d_values[i-1] * 2/3 + k_values[i] * 1/3

            # è®¡ç®—Jå€¼
            j_values[i] = 3 * k_values[i] - 2 * d_values[i]

        results = {}

        # Kå€¼
        k_data = []
        for i in range(9, len(k_values)):
            if not np.isnan(k_values[i]):
                k_data.append({
                    'time': original_data[i]['timestamp'],
                    'value': float(k_values[i])
                })
        results['KDJ_K'] = k_data

        # Då€¼
        d_data = []
        for i in range(9, len(d_values)):
            if not np.isnan(d_values[i]):
                d_data.append({
                    'time': original_data[i]['timestamp'],
                    'value': float(d_values[i])
                })
        results['KDJ_D'] = d_data

        # Jå€¼
        j_data = []
        for i in range(9, len(j_values)):
            if not np.isnan(j_values[i]):
                j_data.append({
                    'time': original_data[i]['timestamp'],
                    'value': float(j_values[i])
                })
        results['KDJ_J'] = j_data

        return results

# æŒ‡æ ‡å¼•æ“å®ä¾‹
indicator_engine = TALibIndicatorEngine()
```

#### Step 2: æŒ‡æ ‡APIç«¯ç‚¹å¼€å‘ (2å¤©)

```python
# api/endpoints/indicators.py
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
from services.indicators import indicator_engine

router = APIRouter()

@router.get("/indicators/calculate")
async def calculate_indicators(
    symbol: str = Query(..., description="è‚¡ç¥¨ä»£ç "),
    indicators: str = Query(..., description="æŒ‡æ ‡åˆ—è¡¨ï¼Œç”¨é€—å·åˆ†éš”"),
    period: str = Query("1d", description="æ—¶é—´å‘¨æœŸ"),
    limit: int = Query(200, description="æ•°æ®æ¡æ•°")
):
    """
    è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
    """
    try:
        # è§£ææŒ‡æ ‡åˆ—è¡¨
        indicator_list = indicators.split(',')

        # è·å–ä»·æ ¼æ•°æ®
        price_data = await fetch_price_data(symbol, period, limit)

        if not price_data:
            raise HTTPException(status_code=404, detail="æœªæ‰¾åˆ°ä»·æ ¼æ•°æ®")

        # è®¡ç®—æŒ‡æ ‡
        results = await indicator_engine.calculate_indicators(
            symbol, price_data, indicator_list
        )

        return {
            'code': 0,
            'message': 'success',
            'data': {
                'symbol': symbol,
                'indicators': results,
                'timestamp': datetime.now().isoformat()
            }
        }

    except Exception as e:
        logger.error(f"è®¡ç®—{symbol}æŠ€æœ¯æŒ‡æ ‡å¤±è´¥: {str(e)}")
        raise HTTPException(status_code=500, detail=f"è®¡ç®—æŒ‡æ ‡å¤±è´¥: {str(e)}")

@router.get("/indicators/library")
async def get_indicators_library():
    """
    è·å–æ”¯æŒçš„æŒ‡æ ‡åº“
    """
    indicators = {
        'trend': {
            'name': 'è¶‹åŠ¿æŒ‡æ ‡',
            'indicators': [
                {'code': 'SMA', 'name': 'ç®€å•ç§»åŠ¨å¹³å‡', 'params': [5, 10, 20, 30, 60]},
                {'code': 'EMA', 'name': 'æŒ‡æ•°ç§»åŠ¨å¹³å‡', 'params': [5, 10, 12, 20, 26, 60]},
                {'code': 'MACD', 'name': 'MACD', 'params': [12, 26, 9]},
                {'code': 'ADX', 'name': 'å¹³å‡è¶‹å‘æŒ‡æ•°', 'params': [14]},
                {'code': 'BOLL', 'name': 'å¸ƒæ—å¸¦', 'params': [20]},
            ]
        },
        'momentum': {
            'name': 'åŠ¨é‡æŒ‡æ ‡',
            'indicators': [
                {'code': 'RSI', 'name': 'ç›¸å¯¹å¼ºå¼±æŒ‡æ•°', 'params': [6, 14, 21]},
                {'code': 'KDJ', 'name': 'éšæœºæŒ‡æ ‡', 'params': [9, 3, 3]},
                {'code': 'CCI', 'name': 'å•†å“é€šé“æŒ‡æ•°', 'params': [14]},
            ]
        },
        'volume': {
            'name': 'æˆäº¤é‡æŒ‡æ ‡',
            'indicators': [
                {'code': 'OBV', 'name': 'èƒ½é‡æ½®', 'params': []},
                {'code': 'ATR', 'name': 'å¹³å‡çœŸå®æ³¢å¹…', 'params': [14]},
            ]
        }
    }

    return {
        'code': 0,
        'message': 'success',
        'data': indicators
    }

@router.get("/indicators/signal")
async def get_trading_signals(
    symbol: str = Query(..., description="è‚¡ç¥¨ä»£ç "),
    indicators: str = Query("RSI,KDJ,MACD", description="ç”¨äºä¿¡å·åˆ¤æ–­çš„æŒ‡æ ‡")
):
    """
    è·å–äº¤æ˜“ä¿¡å·
    """
    try:
        indicator_list = indicators.split(',')

        # è·å–æœ€è¿‘æ•°æ®
        recent_data = await fetch_recent_data(symbol, 100)

        if not recent_data:
            raise HTTPException(status_code=404, detail="æœªæ‰¾åˆ°æ•°æ®")

        # è®¡ç®—æŒ‡æ ‡
        results = await indicator_engine.calculate_indicators(
            symbol, recent_data, indicator_list
        )

        # ç”Ÿæˆäº¤æ˜“ä¿¡å·
        signals = generate_trading_signals(results)

        return {
            'code': 0,
            'message': 'success',
            'data': {
                'symbol': symbol,
                'signals': signals,
                'timestamp': datetime.now().isoformat()
            }
        }

    except Exception as e:
        logger.error(f"è·å–{symbol}äº¤æ˜“ä¿¡å·å¤±è´¥: {str(e)}")
        raise HTTPException(status_code=500, detail=f"è·å–äº¤æ˜“ä¿¡å·å¤±è´¥: {str(e)}")

def generate_trading_signals(indicators_data: Dict) -> List[Dict]:
    """ç”Ÿæˆäº¤æ˜“ä¿¡å·"""
    signals = []

    # RSIä¿¡å·
    if 'RSI14' in indicators_data:
        latest_rsi = indicators_data['RSI14'][-1]['value']
        if latest_rsi > 70:
            signals.append({
                'indicator': 'RSI',
                'signal': 'sell',
                'strength': 'strong' if latest_rsi > 80 else 'medium',
                'value': latest_rsi,
                'description': 'RSIè¶…ä¹°ï¼Œå»ºè®®å–å‡º'
            })
        elif latest_rsi < 30:
            signals.append({
                'indicator': 'RSI',
                'signal': 'buy',
                'strength': 'strong' if latest_rsi < 20 else 'medium',
                'value': latest_rsi,
                'description': 'RSIè¶…å–ï¼Œå»ºè®®ä¹°å…¥'
            })

    # KDJä¿¡å·
    if 'KDJ_K' in indicators_data and 'KDJ_D' in indicators_data:
        latest_k = indicators_data['KDJ_K'][-1]['value']
        latest_d = indicators_data['KDJ_D'][-1]['value']

        # é‡‘å‰æ­»å‰åˆ¤æ–­
        if len(indicators_data['KDJ_K']) >= 2:
            prev_k = indicators_data['KDJ_K'][-2]['value']
            prev_d = indicators_data['KDJ_D'][-2]['value']

            if prev_k <= prev_d and latest_k > latest_d:
                signals.append({
                    'indicator': 'KDJ',
                    'signal': 'buy',
                    'strength': 'strong' if latest_k < 20 else 'medium',
                    'value': f'K:{latest_k:.2f}, D:{latest_d:.2f}',
                    'description': 'KDJé‡‘å‰ï¼Œå»ºè®®ä¹°å…¥'
                })
            elif prev_k >= prev_d and latest_k < latest_d:
                signals.append({
                    'indicator': 'KDJ',
                    'signal': 'sell',
                    'strength': 'strong' if latest_k > 80 else 'medium',
                    'value': f'K:{latest_k:.2f}, D:{latest_d:.2f}',
                    'description': 'KDJæ­»å‰ï¼Œå»ºè®®å–å‡º'
                })

    return signals
```

#### Step 3: å‰ç«¯æŒ‡æ ‡åº“ç»„ä»¶ (3å¤©)

```vue
<!-- components/indicators/IndicatorLibrary.vue -->
<template>
  <div class="indicator-library">
    <div class="library-header">
      <h3>æŠ€æœ¯æŒ‡æ ‡åº“</h3>
      <el-input
        v-model="searchQuery"
        placeholder="æœç´¢æŒ‡æ ‡..."
        size="small"
        style="width: 200px"
      >
        <template #prefix>
          <el-icon><Search /></el-icon>
        </template>
      </el-input>
    </div>

    <div class="indicators-grid">
      <el-collapse v-model="activeCategories">
        <el-collapse-item
          v-for="category in filteredIndicators"
          :key="category.name"
          :title="category.name"
          :name="category.name"
        >
          <div class="indicators-list">
            <div
              v-for="indicator in category.indicators"
              :key="indicator.code"
              class="indicator-item"
              @click="selectIndicator(indicator)"
            >
              <div class="indicator-info">
                <span class="indicator-code">{{ indicator.code }}</span>
                <span class="indicator-name">{{ indicator.name }}</span>
              </div>
              <div class="indicator-params">
                <el-tag
                  v-for="param in indicator.params"
                  :key="param"
                  size="small"
                  type="info"
                >
                  {{ param }}
                </el-tag>
              </div>
              <div class="indicator-actions">
                <el-button
                  size="small"
                  type="primary"
                  @click.stop="addToChart(indicator)"
                >
                  æ·»åŠ 
                </el-button>
              </div>
            </div>
          </div>
        </el-collapse-item>
      </el-collapse>
    </div>

    <div class="selected-indicators">
      <h4>å·²é€‰æŒ‡æ ‡</h4>
      <div class="selected-list">
        <el-tag
          v-for="indicator in selectedIndicators"
          :key="indicator.code"
          closable
          @close="removeIndicator(indicator)"
          class="selected-tag"
        >
          {{ indicator.name }}
        </el-tag>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'IndicatorLibrary',

  props: {
    onIndicatorSelect: {
      type: Function,
      required: true
    }
  },

  data() {
    return {
      searchQuery: '',
      activeCategories: ['trend', 'momentum', 'volume'],
      selectedIndicators: [],
      indicatorsLibrary: {
        trend: {
          name: 'è¶‹åŠ¿æŒ‡æ ‡',
          indicators: [
            { code: 'SMA', name: 'ç®€å•ç§»åŠ¨å¹³å‡', params: [5, 10, 20, 30, 60] },
            { code: 'EMA', name: 'æŒ‡æ•°ç§»åŠ¨å¹³å‡', params: [5, 10, 12, 20, 26, 60] },
            { code: 'MACD', name: 'MACD', params: [12, 26, 9] },
            { code: 'ADX', name: 'å¹³å‡è¶‹å‘æŒ‡æ•°', params: [14] },
            { code: 'BOLL', name: 'å¸ƒæ—å¸¦', params: [20] }
          ]
        },
        momentum: {
          name: 'åŠ¨é‡æŒ‡æ ‡',
          indicators: [
            { code: 'RSI', name: 'ç›¸å¯¹å¼ºå¼±æŒ‡æ•°', params: [6, 14, 21] },
            { code: 'KDJ', name: 'éšæœºæŒ‡æ ‡', params: [9, 3, 3] },
            { code: 'CCI', name: 'å•†å“é€šé“æŒ‡æ•°', params: [14] }
          ]
        },
        volume: {
          name: 'æˆäº¤é‡æŒ‡æ ‡',
          indicators: [
            { code: 'OBV', name: 'èƒ½é‡æ½®', params: [] },
            { code: 'ATR', name: 'å¹³å‡çœŸå®æ³¢å¹…', params: [14] }
          ]
        }
      }
    }
  },

  computed: {
    filteredIndicators() {
      if (!this.searchQuery) {
        return this.indicatorsLibrary
      }

      const filtered = {}
      const query = this.searchQuery.toLowerCase()

      Object.entries(this.indicatorsLibrary).forEach(([key, category]) => {
        const filteredIndicators = category.indicators.filter(indicator =>
          indicator.code.toLowerCase().includes(query) ||
          indicator.name.toLowerCase().includes(query)
        )

        if (filteredIndicators.length > 0) {
          filtered[key] = {
            ...category,
            indicators: filteredIndicators
          }
        }
      })

      return filtered
    }
  },

  methods: {
    selectIndicator(indicator) {
      // æŒ‡æ ‡é€‰æ‹©é€»è¾‘
      this.$emit('indicator-selected', indicator)
    },

    addToChart(indicator) {
      if (!this.selectedIndicators.find(item => item.code === indicator.code)) {
        this.selectedIndicators.push(indicator)
        this.onIndicatorSelect(indicator)
      }
    },

    removeIndicator(indicator) {
      const index = this.selectedIndicators.indexOf(indicator)
      if (index > -1) {
        this.selectedIndicators.splice(index, 1)
        this.$emit('indicator-removed', indicator)
      }
    }
  }
}
</script>

<style scoped>
.indicator-library {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.library-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.indicators-grid {
  flex: 1;
  overflow-y: auto;
}

.indicators-list {
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
}

.indicator-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s;
}

.indicator-item:hover {
  border-color: #409eff;
  background-color: #f0f9ff;
}

.indicator-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.indicator-code {
  font-weight: bold;
  color: #409eff;
}

.indicator-name {
  font-size: 12px;
  color: #666;
}

.indicator-params {
  display: flex;
  gap: 4px;
}

.selected-indicators {
  border-top: 1px solid #e0e0e0;
  padding-top: 16px;
}

.selected-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.selected-tag {
  margin: 0;
}
</style>
```

---

## ğŸ¯ ä»»åŠ¡3: Aè‚¡äº¤æ˜“è§„åˆ™å®Œæ•´é€‚é… (1å‘¨)

### æ ¸å¿ƒè§„åˆ™å®ç°

#### Step 1: Aè‚¡è§„åˆ™å¼•æ“å¼€å‘ (3å¤©)

```python
# utils/china_stock_rules.py
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class StockBoard(Enum):
    MAIN = "main"  # ä¸»æ¿
    SME = "sme"    # ä¸­å°æ¿
    CHINEXT = "chinext"  # åˆ›ä¸šæ¿
    STAR = "star"  # ç§‘åˆ›æ¿

class TradingRuleEngine:
    def __init__(self):
        self.rules = {
            'price_limit': {
                StockBoard.MAIN: 0.10,
                StockBoard.SME: 0.10,
                StockBoard.CHINEXT: 0.20,
                StockBoard.STAR: 0.20
            },
            'min_trade_unit': 100,  # æœ€å°äº¤æ˜“å•ä½ï¼š100è‚¡
            'trading_calendar': self._get_trading_calendar()
        }

    def get_stock_board(self, symbol: str) -> StockBoard:
        """æ ¹æ®è‚¡ç¥¨ä»£ç åˆ¤æ–­æ¿å—"""
        if symbol.startswith(('60', '68')):  # æ²ªå¸‚ä¸»æ¿å’Œç§‘åˆ›æ¿
            return Stock
