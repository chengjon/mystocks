# ğŸ“Š MyStocks é¡¹ç›®æ•°æ®æµè½¬æœºåˆ¶æ€»ç»“

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**åˆ›å»ºæ—¥æœŸ**: 2026-01-02
**ç³»ç»Ÿç‰ˆæœ¬**: MyStocks v2.1 (US3æ¶æ„)

---

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### æ•°æ®åˆ†ç±»æ¶æ„ (US3 - Unified Storage Strategy 3)

ç³»ç»Ÿé‡‡ç”¨**5å±‚æ•°æ®åˆ†ç±»**ï¼Œå…±34ä¸ªåˆ†ç±»ï¼Œæ¯ç±»æ•°æ®è‡ªåŠ¨è·¯ç”±åˆ°æœ€ä¼˜æ•°æ®åº“ï¼š

| åˆ†ç±»å±‚çº§ | æ•°æ®ç±»å‹ | ç›®æ ‡æ•°æ®åº“ | ç¤ºä¾‹åˆ†ç±»æ•° |
|---------|---------|-----------|-----------|
| **ç¬¬1ç±»** | å¸‚åœºæ•°æ® (é«˜é¢‘) | TDengine | 6é¡¹ |
| **ç¬¬2ç±»** | å‚è€ƒæ•°æ® (ä½é¢‘) | PostgreSQL | 9é¡¹ |
| **ç¬¬3ç±»** | è¡ç”Ÿæ•°æ® (è®¡ç®—) | PostgreSQL | 6é¡¹ |
| **ç¬¬4ç±»** | äº¤æ˜“æ•°æ® (äº‹åŠ¡) | PostgreSQL | 7é¡¹ |
| **ç¬¬5ç±»** | å…ƒæ•°æ® (é…ç½®) | PostgreSQL | 6é¡¹ |

---

## ğŸ”„ å®Œæ•´æ•°æ®æµè½¬æµç¨‹

### é˜¶æ®µ1: æ•°æ®è·å– (Data Ingestion)

```
å¤–éƒ¨æ•°æ®æº â†’ é€‚é…å™¨å±‚ â†’ ç»Ÿä¸€æ¥å£
```

#### 1.1 å¤–éƒ¨æ•°æ®æº

**ä¸»è¦æ•°æ®æº: AkShare**
- æ•°æ®æä¾›æ–¹: ä¸œæ–¹è´¢å¯Œç½‘
- è¦†ç›–èŒƒå›´: Aè‚¡å¸‚åœºå…¨é‡æ•°æ®
- æ•°æ®ç±»å‹:
  - å®æ—¶è¡Œæƒ… (tickæ•°æ®)
  - æ—¥çº¿/åˆ†é’Ÿçº¿æ•°æ®
  - è´¢åŠ¡æ•°æ®
  - è¡Œä¸š/æ¦‚å¿µåˆ†ç±»
  - è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯

**Akshareé€‚é…å™¨** (`src/adapters/akshare_adapter.py`):
```python
class AkshareDataSource(IDataSource):
    """å®ç°ç»Ÿä¸€æ•°æ®æºæ¥å£"""

    def get_stock_daily(self, symbol, start_date, end_date):
        """è·å–æ—¥çº¿æ•°æ®"""
        stock_code = format_stock_code_for_source(symbol, "akshare")
        df = ak.stock_zh_a_hist(
            symbol=stock_code,
            period="daily",
            start_date=start_date_fmt,
            end_date=end_date_fmt,
            adjust="qfq",  # å‰å¤æƒ
            timeout=self.api_timeout
        )
        return df

    def get_stock_list(self):
        """è·å–è‚¡ç¥¨åˆ—è¡¨"""
        df = ak.stock_zh_a_spot_em()
        return df
```

**å…³é”®ç‰¹æ€§**:
- âœ… è‡ªåŠ¨é‡è¯•æœºåˆ¶ (æœ€å¤š3æ¬¡)
- âœ… å¤šAPIè‡ªåŠ¨åˆ‡æ¢ (ä¸»API + å¤‡ç”¨API)
- âœ… æ•°æ®æ ¼å¼æ ‡å‡†åŒ– (ç»Ÿä¸€è½¬æ¢ä¸ºç³»ç»Ÿæ ¼å¼)
- âœ… é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•

---

### é˜¶æ®µ2: æ•°æ®è·¯ç”± (Data Routing)

```
åˆ†ç±»æ ‡è¯† â†’ è·¯ç”±å†³ç­– â†’ æ•°æ®åº“é€‰æ‹©
```

#### 2.1 æ•°æ®åˆ†ç±»æšä¸¾ (`src/core/data_classification.py`)

```python
class DataClassification(Enum):
    # å¸‚åœºæ•°æ® - é«˜é¢‘ â†’ TDengine
    TICK_DATA = "tick_data"
    MINUTE_KLINE = "minute_kline"
    DAILY_KLINE = "daily_kline"
    ORDER_BOOK_DEPTH = "order_book_depth"
    LEVEL2_SNAPSHOT = "level2_snapshot"
    INDEX_QUOTES = "index_quotes"

    # å‚è€ƒæ•°æ® - ä½é¢‘ â†’ PostgreSQL
    SYMBOLS_INFO = "symbols_info"
    INDUSTRY_CLASS = "industry_class"
    CONCEPT_CLASS = "concept_class"
    INDEX_CONSTITUENTS = "index_constituents"
    TRADE_CALENDAR = "trade_calendar"
    FUNDAMENTAL_METRICS = "fundamental_metrics"
    DIVIDEND_DATA = "dividend_data"
    SHAREHOLDER_DATA = "shareholder_data"
    MARKET_RULES = "market_rules"

    # è¡ç”Ÿæ•°æ® - è®¡ç®— â†’ PostgreSQL
    TECHNICAL_INDICATORS = "technical_indicators"
    QUANT_FACTORS = "quant_factors"
    MODEL_OUTPUT = "model_output"
    TRADE_SIGNALS = "trade_signals"
    BACKTEST_RESULTS = "backtest_results"
    RISK_METRICS = "risk_metrics"

    # äº¤æ˜“æ•°æ® - äº‹åŠ¡ â†’ PostgreSQL
    ORDER_RECORDS = "order_records"
    TRADE_RECORDS = "trade_records"
    POSITION_HISTORY = "position_history"
    REALTIME_POSITIONS = "realtime_positions"
    REALTIME_ACCOUNT = "realtime_account"
    FUND_FLOW = "fund_flow"
    ORDER_QUEUE = "order_queue"

    # å…ƒæ•°æ® - é…ç½® â†’ PostgreSQL
    DATA_SOURCE_STATUS = "data_source_status"
    TASK_SCHEDULE = "task_schedule"
    STRATEGY_PARAMS = "strategy_params"
    SYSTEM_CONFIG = "system_config"
    DATA_QUALITY_METRICS = "data_quality_metrics"
    USER_CONFIG = "user_config"
```

#### 2.2 è·¯ç”±æ˜ å°„ (`src/core/data_manager.py`)

```python
class DataManager:
    """æ•°æ®ç®¡ç†å™¨ - æ ¸å¿ƒè·¯ç”±å¼•æ“"""

    # é¢„è®¡ç®—çš„è·¯ç”±æ˜ å°„ (<5msè·¯ç”±æ—¶é—´)
    _ROUTING_MAP: Dict[DataClassification, DatabaseTarget] = {
        # ç¬¬1ç±»: å¸‚åœºæ•°æ® â†’ TDengine
        DataClassification.TICK_DATA: DatabaseTarget.TDENGINE,
        DataClassification.MINUTE_KLINE: DatabaseTarget.TDENGINE,
        DataClassification.DAILY_KLINE: DatabaseTarget.POSTGRESQL,

        # ç¬¬2ç±»: å‚è€ƒæ•°æ® â†’ PostgreSQL
        DataClassification.SYMBOLS_INFO: DatabaseTarget.POSTGRESQL,
        DataClassification.INDUSTRY_CLASS: DatabaseTarget.POSTGRESQL,
        DataClassification.CONCEPT_CLASS: DatabaseTarget.POSTGRESQL,

        # ... (å…±34ä¸ªåˆ†ç±»)
    }

    def get_target_database(self, classification: DataClassification):
        """
        å¿«é€Ÿè·¯ç”±å†³ç­– (O(1) æ—¶é—´å¤æ‚åº¦)

        Args:
            classification: æ•°æ®åˆ†ç±»

        Returns:
            ç›®æ ‡æ•°æ®åº“ç±»å‹
        """
        return self._ROUTING_MAP.get(classification, DatabaseTarget.POSTGRESQL)
```

**æ€§èƒ½ä¼˜åŒ–**:
- âœ… é¢„è®¡ç®—å­—å…¸æ˜ å°„
- âœ… O(1) æ—¶é—´å¤æ‚åº¦
- âœ… é¢„æœŸ <5ms è·¯ç”±å†³ç­–æ—¶é—´

---

### é˜¶æ®µ3: æ•°æ®ä¿å­˜ (Data Persistence)

```
DataFrame â†’ è®¿é—®å±‚ â†’ æ•°æ®åº“è¿æ¥æ±  â†’ ç‰©ç†å­˜å‚¨
```

#### 3.1 ç»Ÿä¸€ä¿å­˜æ¥å£ (`src/core/data_manager.py`)

```python
class DataManager:
    def save_data(
        self,
        classification: DataClassification,
        data: pd.DataFrame,
        table_name: str,
        **kwargs
    ) -> bool:
        """
        ä¿å­˜æ•°æ®åˆ°æ­£ç¡®çš„æ•°æ®åº“

        Args:
            classification: æ•°æ®åˆ†ç±»
            data: DataFrameæ•°æ®
            table_name: ç›®æ ‡è¡¨å
            **kwargs: é¢å¤–å‚æ•° (upsert, conflict_columnsç­‰)

        Returns:
            bool: ä¿å­˜æ˜¯å¦æˆåŠŸ
        """
        # 1. å¿«é€Ÿè·¯ç”±å†³ç­–
        target_db = self.get_target_database(classification)

        # 2. æ ¹æ®ç›®æ ‡æ•°æ®åº“é€‰æ‹©è®¿é—®å±‚
        if target_db == DatabaseTarget.TDENGINE:
            success = self._tdengine.save_data(
                data, classification, table_name, **kwargs
            )
        else:  # PostgreSQL
            success = self._postgresql.save_data(
                data, classification, table_name, **kwargs
            )

        # 3. è®°å½•æ€§èƒ½æŒ‡æ ‡
        if self.enable_monitoring:
            self._performance_monitor.record_operation(
                operation="save_data",
                classification=classification.value,
                duration_ms=duration_ms,
                success=success
            )

        return success
```

#### 3.2 PostgreSQLæ•°æ®è®¿é—®å±‚ (`src/data_access/postgresql_access.py`)

**æ‰¹é‡æ’å…¥ (Insert)**:
```python
def insert_dataframe(self, table_name: str, df: pd.DataFrame) -> int:
    """
    æ‰¹é‡æ’å…¥DataFrame (ä½¿ç”¨execute_valuesä¼˜åŒ–)

    æ€§èƒ½ä¼˜åŒ–:
    - execute_values: ä¸€æ¬¡æ’å…¥å¤šè¡Œ
    - æ‰¹å¤„ç†: æ˜¾è‘—å‡å°‘ç½‘ç»œå¾€è¿”
    - äº‹åŠ¡ç®¡ç†: ç¡®ä¿æ•°æ®ä¸€è‡´æ€§

    Returns:
        æ’å…¥çš„è¡Œæ•°
    """
    if df.empty:
        return 0

    conn = self._get_connection()

    try:
        # 1. å‡†å¤‡åˆ—åå’Œæ•°æ®
        columns = list(df.columns)
        columns_str = ", ".join(columns)
        data = [tuple(row) for row in df.itertuples(index=False, name=None)]

        # 2. æ„å»ºæ’å…¥SQL
        sql = f"INSERT INTO {table_name} ({columns_str}) VALUES %s"

        # 3. æ‰¹é‡æ‰§è¡Œ (execute_valuesä¼˜åŒ–)
        cursor = conn.cursor()
        execute_values(cursor, sql, data)
        conn.commit()

        rows_inserted = cursor.rowcount or 0
        return rows_inserted
    except Exception as e:
        conn.rollback()
        raise
    finally:
        self._return_connection(conn)
```

**æ‰¹é‡æ›´æ–° (Upsert)**:
```python
def upsert_dataframe(
    self,
    table_name: str,
    df: pd.DataFrame,
    conflict_columns: List[str],
    update_columns: Optional[List[str]] = None
) -> int:
    """
    æ‰¹é‡Upsert (INSERT ... ON CONFLICT UPDATE)

    ä½¿ç”¨åœºæ™¯:
    - æ•°æ®å»é‡
    - å¢é‡æ›´æ–°
    - è§£å†³ä¸»é”®å†²çª

    Example:
        upsert_dataframe('daily_kline', df,
                       conflict_columns=['symbol', 'date'],
                       update_columns=['close', 'volume'])
    """
    conn = self._get_connection()

    try:
        columns = list(df.columns)
        data = [tuple(row) for row in df.itertuples(index=False, name=None)]

        # 1. æ„å»ºå†²çªå¤„ç†å­å¥
        conflict_str = ", ".join(conflict_columns)
        if update_columns is None:
            update_columns = [col for col in columns if col not in conflict_columns]

        update_str = ", ".join([f"{col} = EXCLUDED.{col}" for col in update_columns])

        # 2. Upsert SQL
        sql = f"""
            INSERT INTO {table_name} ({columns_str})
            VALUES %s
            ON CONFLICT ({conflict_str})
            DO UPDATE SET {update_str}
        """

        # 3. æ‰§è¡Œ
        cursor = conn.cursor()
        execute_values(cursor, sql, data)
        conn.commit()

        return cursor.rowcount or 0
    except Exception as e:
        conn.rollback()
        raise
    finally:
        self._return_connection(conn)
```

#### 3.3 è¿æ¥æ± ç®¡ç†

```python
class PostgreSQLDataAccess:
    """PostgreSQLè¿æ¥æ± ç®¡ç†"""

    def _get_connection(self):
        """ä»è¿æ¥æ± è·å–è¿æ¥"""
        if self.pool is None:
            self.pool = self.conn_manager.get_postgresql_connection()
        return self.pool.getconn()

    def _return_connection(self, conn):
        """å½’è¿˜è¿æ¥åˆ°è¿æ¥æ± """
        if self.pool:
            self.pool.putconn(conn)
```

**è¿æ¥æ± é…ç½®** (Phase 3ä¼˜åŒ–):
```python
# PostgreSQLè¿æ¥æ± 
pool_size=20           # æœ€å°è¿æ¥æ•°
max_overflow=40        # æœ€å¤§é¢å¤–è¿æ¥æ•°
pool_timeout=30        # è·å–è¿æ¥è¶…æ—¶(ç§’)

# TDengineè¿æ¥æ± 
pool_size=5            # æœ€å°è¿æ¥æ•°
max_size=20            # æœ€å¤§è¿æ¥æ•°
```

---

### é˜¶æ®µ4: æ•°æ®æŸ¥è¯¢ (Data Retrieval)

```
APIè¯·æ±‚ â†’ è·¯ç”±å†³ç­– â†’ æ•°æ®åº“æŸ¥è¯¢ â†’ ç»“æœè¿”å›
```

#### 4.1 ç»Ÿä¸€æŸ¥è¯¢æ¥å£

```python
class DataManager:
    def load_data(
        self,
        classification: DataClassification,
        table_name: str,
        **filters
    ) -> Optional[pd.DataFrame]:
        """
        ä»æ­£ç¡®çš„æ•°æ®åº“åŠ è½½æ•°æ®

        Args:
            classification: æ•°æ®åˆ†ç±»
            table_name: æºè¡¨å
            **filters: è¿‡æ»¤æ¡ä»¶
                - symbol: '600000.SH'
                - start_date: '2024-01-01'
                - end_date: '2024-12-31'
                - limit: 100

        Returns:
            pandas DataFrame or None
        """
        # 1. å¿«é€Ÿè·¯ç”±å†³ç­–
        target_db = self.get_target_database(classification)

        # 2. æ ¹æ®ç›®æ ‡æ•°æ®åº“é€‰æ‹©è®¿é—®å±‚
        if target_db == DatabaseTarget.TDENGINE:
            data = self._tdengine.load_data(table_name, **filters)
        else:
            data = self._postgresql.load_data(table_name, **filters)

        return data
```

#### 4.2 æ—¶é—´èŒƒå›´æŸ¥è¯¢ (PostgreSQL)

```python
def query_by_time_range(
    self,
    table_name: str,
    time_column: str,
    start_time: str,
    end_time: str,
    symbol: Optional[str] = None,
    limit: Optional[int] = None
) -> pd.DataFrame:
    """
    æ—¶é—´èŒƒå›´æŸ¥è¯¢ (ä½¿ç”¨TimescaleDBä¼˜åŒ–)

    æ€§èƒ½ä¼˜åŒ–:
    - æ—¶é—´ç´¢å¼•
    - åˆ†åŒºè£å‰ª
    - å€’åºæŸ¥è¯¢ä¼˜åŒ–
    """
    conn = self._get_connection()

    try:
        # æ„å»ºæŸ¥è¯¢SQL
        where_conditions = [
            f"{time_column} >= '{start_time}'",
            f"{time_column} <= '{end_time}'"
        ]

        if symbol:
            where_conditions.append(f"symbol = '{symbol}'")

        where_clause = " AND ".join(where_conditions)
        order_clause = f"ORDER BY {time_column} DESC"
        limit_clause = f"LIMIT {limit}" if limit else ""

        sql = f"""
            SELECT * FROM {table_name}
            WHERE {where_clause}
            {order_clause}
            {limit_clause}
        """

        df = pd.read_sql(sql, conn)
        return df
    finally:
        self._return_connection(conn)
```

---

### é˜¶æ®µ5: APIæ•°æ®è®¿é—® (Data API)

```
HTTPè¯·æ±‚ â†’ è®¤è¯ â†’ APIè·¯ç”± â†’ æ•°æ®æœåŠ¡ â†’ è¿”å›å“åº”
```

#### 5.1 FastAPIè·¯ç”±å±‚ (`web/backend/app/api/data.py`)

```python
@router.get("/stocks/basic")
async def get_stocks_basic(
    limit: int = Query(100, ge=1, le=1000),
    offset: int = Query(0, ge=0),
    search: Optional[str] = None,
    industry: Optional[str] = None,
    concept: Optional[str] = None,
    market: Optional[str] = None,
    sort_field: Optional[str] = None,
    sort_order: Optional[str] = None,
    current_user: User = Depends(get_current_user),  # JWTè®¤è¯
):
    """
    è·å–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯åˆ—è¡¨

    è®¤è¯: JWT Bearer Token
    æ•°æ®æº: symbols_infoè¡¨
    ç‰¹æ€§:
        - åˆ†é¡µæ”¯æŒ
        - æœç´¢è¿‡æ»¤
        - è¡Œä¸š/æ¦‚å¿µç­›é€‰
        - å¸‚åœºç­›é€‰
        - æ’åºåŠŸèƒ½
    """
    # 1. ä½¿ç”¨æ•°æ®æºå·¥å‚è·å–æ•°æ®
    from app.services.data_source_factory import get_data_source_factory
    factory = await get_data_source_factory()

    # 2. æ„å»ºè¯·æ±‚å‚æ•°
    params = {
        "limit": limit,
        "offset": offset,
        "search": search,
        "industry": industry,
        "concept": concept,
        "market": market,
        "sort_field": sort_field,
        "sort_order": sort_order,
    }

    # 3. è°ƒç”¨æ•°æ®æºå·¥å‚
    result = await factory.get_data("data", "stocks/basic", params)

    # 4. ç»Ÿä¸€å“åº”æ ¼å¼
    return {
        "success": True,
        "data": result.get("data", []),
        "total": result.get("total", 0),
        "limit": limit,
        "offset": offset,
        "timestamp": datetime.now().isoformat(),
        "source": result.get("source", "data"),
    }
```

#### 5.2 è®¤è¯æœºåˆ¶

```python
# JWT Tokenç”Ÿæˆ
def create_access_token(data: Dict[str, Any]) -> str:
    """
    åˆ›å»ºJWTè®¿é—®ä»¤ç‰Œ

    é…ç½®:
        - Algorithm: HS256
        - Secret: JWT_SECRET_KEY (from .env)
        - Expires: 30 minutes
    """
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=30)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)
    return encoded_jwt

# è®¤è¯ä¾èµ–
async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """
    éªŒè¯JWTä»¤ç‰Œå¹¶è¿”å›å½“å‰ç”¨æˆ·

    æµç¨‹:
        1. æå–ä»¤ç‰Œ
        2. éªŒè¯ç­¾å
        3. è§£ç è½½è·
        4. æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
        5. è¿”å›ç”¨æˆ·å¯¹è±¡
    """
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])
        username: str = payload.get("sub")
        user_id: int = payload.get("user_id")
        role: str = payload.get("role")

        if username is None:
            raise HTTPException(status_code=401, detail="Could not validate credentials")

        token_data = TokenData(username=username, user_id=user_id, role=role)
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Could not validate credentials")

    # ä»æ•°æ®åº“è·å–ç”¨æˆ·ä¿¡æ¯
    user = authenticate_user_by_id(token_data.user_id)
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    return user
```

---

## ğŸ”‘ å…³é”®æŠ€æœ¯ç‚¹

### 1. è‡ªåŠ¨è·¯ç”±æœºåˆ¶

**ä¼˜åŠ¿**:
- âœ… å¼€å‘è€…æ— éœ€å…³å¿ƒåº•å±‚å­˜å‚¨
- âœ… 2è¡Œä»£ç å®Œæˆæ•°æ®æ“ä½œ
- âœ… è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ•°æ®åº“

**ç¤ºä¾‹**:
```python
manager = MyStocksUnifiedManager()

# ä¿å­˜Tickæ•°æ® â†’ è‡ªåŠ¨è·¯ç”±åˆ°TDengine
manager.save_data_by_classification(
    DataClassification.TICK_DATA,
    tick_df,
    table_name='tick_600000'
)

# åŠ è½½æ—¥çº¿æ•°æ® â†’ è‡ªåŠ¨è·¯ç”±åˆ°PostgreSQL
kline_df = manager.load_data_by_classification(
    DataClassification.DAILY_KLINE,
    table_name='daily_kline',
    filters={'symbol': '600000.SH'}
)
```

---

### 2. æ‰¹é‡æ“ä½œä¼˜åŒ–

**execute_values vs å•è¡Œæ’å…¥**:

```python
# âŒ ä½æ•ˆæ–¹å¼ (å•è¡Œæ’å…¥)
for index, row in df.iterrows():
    cursor.execute("INSERT INTO table VALUES (%s, %s, %s)", (row.a, row.b, row.c))

# âœ… é«˜æ•ˆæ–¹å¼ (æ‰¹é‡æ’å…¥)
data = [tuple(row) for row in df.itertuples(index=False, name=None)]
execute_values(cursor, "INSERT INTO table VALUES %s", data)
```

**æ€§èƒ½å¯¹æ¯”**:
- å•è¡Œæ’å…¥: 100æ¡æ•°æ® â‰ˆ 500ms
- æ‰¹é‡æ’å…¥: 100æ¡æ•°æ® â‰ˆ 5ms
- **æ€§èƒ½æå‡: 100å€**

---

### 3. Upsertæœºåˆ¶

**ä½¿ç”¨åœºæ™¯**:
- æ•°æ®å»é‡
- å¢é‡æ›´æ–°
- å†²çªè§£å†³

```python
# ç¤ºä¾‹: æ—¥çº¿æ•°æ®Upsert
db.upsert_dataframe(
    table_name='daily_kline',
    df=kline_df,
    conflict_columns=['symbol', 'date'],  # ä¸»é”®
    update_columns=['open', 'high', 'low', 'close', 'volume']  # éœ€è¦æ›´æ–°çš„åˆ—
)
```

**SQLç­‰ä»·**:
```sql
INSERT INTO daily_kline (symbol, date, open, high, low, close, volume)
VALUES ('600000.SH', '2024-01-01', 10.0, 10.5, 9.8, 10.2, 1000000)
ON CONFLICT (symbol, date)
DO UPDATE SET
    open = EXCLUDED.open,
    high = EXCLUDED.high,
    low = EXCLUDED.low,
    close = EXCLUDED.close,
    volume = EXCLUDED.volume;
```

---

### 4. è¿æ¥æ± ç®¡ç†

**è¿æ¥æ± ä¼˜åŠ¿**:
- âœ… å‡å°‘è¿æ¥åˆ›å»ºå¼€é”€
- âœ… æ§åˆ¶æ•°æ®åº“è¿æ¥æ•°
- âœ… æé«˜å¹¶å‘æ€§èƒ½
- âœ… è‡ªåŠ¨è¿æ¥å¤ç”¨

**PostgreSQLè¿æ¥æ± é…ç½®**:
```python
# åˆå§‹åŒ–
pool = psycopg2.pool.ThreadedConnectionPool(
    minconn=20,      # æœ€å°è¿æ¥æ•°
    maxconn=60,      # æœ€å¤§è¿æ¥æ•° (20 + 40 overflow)
    host='192.168.123.104',
    port=5438,
    database='mystocks',
    user='postgres',
    password='c790414J'
)

# ä½¿ç”¨
conn = pool.getconn()
try:
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM symbols_info LIMIT 10")
    result = cursor.fetchall()
finally:
    pool.putconn(conn)  # å½’è¿˜è¿æ¥
```

---

### 5. å®‰å…¨æœºåˆ¶

#### 5.1 SQLæ³¨å…¥é˜²æŠ¤

```python
# âŒ å±é™©: ç›´æ¥æ‹¼æ¥SQL
sql = f"SELECT * FROM table WHERE name = '{name}'"

# âœ… å®‰å…¨: å‚æ•°åŒ–æŸ¥è¯¢
cursor.execute("SELECT * FROM table WHERE name = %s", (name,))

# âœ… å®‰å…¨: ç™½åå•éªŒè¯
ALLOWED_TABLES = ['symbols_info', 'daily_kline', 'concepts']
if table_name not in ALLOWED_TABLES:
    raise ValueError(f"Invalid table name: {table_name}")
```

#### 5.2 JWTè®¤è¯

```python
# TokenéªŒè¯
try:
    payload = jwt.decode(
        token,
        settings.secret_key,
        algorithms=[settings.algorithm]
    )
    user_id = payload.get("user_id")
    role = payload.get("role")
except jwt.PyJWTError:
    raise HTTPException(status_code=401, detail="Invalid token")
```

#### 5.3 CORSé…ç½®

```python
# å…è®¸çš„æº
cors_origins = [
    "http://localhost:3000",
    "http://localhost:8080",
    "http://localhost:5173"
]

# å…è®¸çš„æ–¹æ³•
cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]

# å…è®¸çš„å¤´éƒ¨
cors_allow_headers = ["Authorization", "Content-Type"]
```

---

## ğŸ“Š å®Œæ•´æ•°æ®æµè½¬ç¤ºä¾‹

### ç¤ºä¾‹1: è·å–å¹¶ä¿å­˜è‚¡ç¥¨æ—¥çº¿æ•°æ®

```python
# ========== æ­¥éª¤1: æ•°æ®è·å– ==========
from src.adapters.akshare_adapter import AkshareDataSource

akshare = AkshareDataSource()
df = akshare.get_stock_daily(
    symbol='600000.SH',
    start_date='2024-01-01',
    end_date='2024-12-31'
)

# df åŒ…å«: date, open, high, low, close, volume, amount

# ========== æ­¥éª¤2: æ•°æ®ä¿å­˜ ==========
from src.core.unified_manager import MyStocksUnifiedManager
from src.core.data_classification import DataClassification

manager = MyStocksUnifiedManager()

success = manager.save_data_by_classification(
    classification=DataClassification.DAILY_KLINE,  # æ—¥çº¿æ•°æ®
    data=df,
    table_name='daily_kline'
)

# è‡ªåŠ¨è·¯ç”±æµç¨‹:
# 1. è·å–åˆ†ç±»: DataClassification.DAILY_KLINE
# 2. æŸ¥è¯¢è·¯ç”±è¡¨: DAILY_KLINE â†’ PostgreSQL
# 3. é€‰æ‹©è®¿é—®å±‚: postgresql.save_data()
# 4. æ‰§è¡Œæ‰¹é‡æ’å…¥: insert_dataframe('daily_kline', df)
# 5. è¿”å›ç»“æœ: True/False
```

---

### ç¤ºä¾‹2: APIæŸ¥è¯¢è‚¡ç¥¨ä¿¡æ¯

```python
# ========== å®¢æˆ·ç«¯è¯·æ±‚ ==========
import requests

# 1. ç™»å½•è·å–Token
login_response = requests.post(
    "http://localhost:8000/api/v1/auth/login",
    data={"username": "admin", "password": "admin123"}
)
token = login_response.json()["data"]["token"]

# 2. æŸ¥è¯¢è‚¡ç¥¨åˆ—è¡¨
headers = {"Authorization": f"Bearer {token}"}
response = requests.get(
    "http://localhost:8000/api/v1/data/stocks/basic",
    headers=headers,
    params={"limit": 10, "industry": "é“¶è¡Œ"}
)

# ========== æœåŠ¡ç«¯å¤„ç† ==========
# FastAPIè·¯ç”±å¤„ç†æµç¨‹:

# 1. è®¤è¯æ£€æŸ¥
@router.get("/stocks/basic")
async def get_stocks_basic(
    current_user: User = Depends(get_current_user)  # JWTéªŒè¯
):
    # tokenéªŒè¯é€šè¿‡ï¼Œcurrent_user = User(id=1, username="admin")

# 2. å‚æ•°è§£æ
limit = 10
industry = "é“¶è¡Œ"

# 3. æ•°æ®æŸ¥è¯¢
from app.core.database import db_service
df = db_service.query_stocks_basic(limit=10000)  # æŸ¥è¯¢å…¨éƒ¨æ•°æ®

# 4. æ•°æ®ç­›é€‰
df = df[df["industry"] == industry]

# 5. åˆ†é¡µå¤„ç†
df = df.iloc[offset:offset+limit]

# 6. ç»“æœè¿”å›
return {
    "success": True,
    "data": df.to_dict("records"),
    "total": len(df),
    "limit": limit,
    "offset": offset
}
```

---

## ğŸ—„ï¸ æ•°æ®åº“æ¶æ„

### PostgreSQL (å‚è€ƒæ•°æ®åº“)

**å­˜å‚¨ç±»å‹**:
- å‚è€ƒæ•°æ® (ä½é¢‘æ›´æ–°)
- è¡ç”Ÿæ•°æ® (è®¡ç®—ç»“æœ)
- äº¤æ˜“æ•°æ® (äº‹åŠ¡æ€§)
- å…ƒæ•°æ® (é…ç½®ä¿¡æ¯)

**å…³é”®è¡¨**:

| è¡¨å | åˆ†ç±» | ç”¨é€” | è®°å½•æ•° |
|------|------|------|--------|
| `symbols_info` | å‚è€ƒæ•°æ® | è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯ | 5,452 |
| `daily_kline` | å¸‚åœºæ•°æ® | æ—¥çº¿è¡Œæƒ… | æ•°ç™¾ä¸‡ |
| `concepts` | å‚è€ƒæ•°æ® | æ¦‚å¿µåˆ†ç±» | 376 |
| `technical_indicators` | è¡ç”Ÿæ•°æ® | æŠ€æœ¯æŒ‡æ ‡ | - |
| `order_records` | äº¤æ˜“æ•°æ® | è®¢å•è®°å½• | - |

**ä¼˜åŒ–ç‰¹æ€§**:
- âœ… TimescaleDBæ—¶åºæ‰©å±•
- âœ… è‡ªåŠ¨åˆ†åŒº
- âœ… è¿ç»­èšåˆ
- âœ… ç´¢å¼•ä¼˜åŒ–

---

### TDengine (æ—¶åºæ•°æ®åº“)

**å­˜å‚¨ç±»å‹**:
- Tickæ•°æ® (è¶…é«˜é¢‘)
- åˆ†é’ŸKçº¿ (ä¸­é¢‘)
- ç›˜å£æ•°æ® (é«˜é¢‘)
- é€ç¬”æˆäº¤ (é«˜é¢‘)

**å…³é”®è¡¨**:
- `tick_600000` - Tickæ•°æ®
- `minute_kline` - åˆ†é’ŸKçº¿
- `order_book` - ç›˜å£æ•°æ®
- `level2_snapshot` - Level2å¿«ç…§

**ä¼˜åŠ¿**:
- âœ… é«˜å‹ç¼©ç‡
- âœ… é«˜å†™å…¥æ€§èƒ½
- âœ… æ—¶åºä¼˜åŒ–
- âœ… è‡ªåŠ¨é™é‡‡æ ·

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒä¼˜åŠ¿

1. **è‡ªåŠ¨åŒ–**: åŸºäºåˆ†ç±»è‡ªåŠ¨è·¯ç”±åˆ°æœ€ä¼˜æ•°æ®åº“
2. **é«˜æ€§èƒ½**: æ‰¹é‡æ“ä½œ + è¿æ¥æ±  + ç´¢å¼•ä¼˜åŒ–
3. **æ˜“ç”¨æ€§**: 2è¡Œä»£ç å®Œæˆæ•°æ®æ“ä½œ
4. **å¯é æ€§**: Upsert + é‡è¯•æœºåˆ¶ + é”™è¯¯å¤„ç†
5. **å®‰å…¨æ€§**: JWTè®¤è¯ + SQLæ³¨å…¥é˜²æŠ¤ + ç™½åå•éªŒè¯

### æ•°æ®æµè½¬å…³é”®è·¯å¾„

```
å¤–éƒ¨API â†’ é€‚é…å™¨ â†’ ç»Ÿä¸€æ¥å£ â†’ åˆ†ç±»æ ‡è¯† â†’ è·¯ç”±å†³ç­– â†’ æ•°æ®åº“è®¿é—®å±‚ â†’ è¿æ¥æ±  â†’ ç‰©ç†å­˜å‚¨

HTTPè¯·æ±‚ â†’ è®¤è¯ â†’ APIè·¯ç”± â†’ æ•°æ®æœåŠ¡ â†’ æ•°æ®åº“æŸ¥è¯¢ â†’ ç»“æœæ ¼å¼åŒ– â†’ JSONå“åº”
```

### æŠ€æœ¯æ ˆ

- **æ•°æ®æº**: AkShare (ä¸œæ–¹è´¢å¯Œ)
- **æ•°æ®åº“**: PostgreSQL 17.6 + TDengine 3.x
- **æ¡†æ¶**: FastAPI (Python 3.12)
- **ORM**: SQLAlchemy + psycopg2
- **ç¼“å­˜**: TDengine + å¯é€‰Redis
- **è®¤è¯**: JWT (HS256)

---

**æ–‡æ¡£ç»´æŠ¤**: æœ¬æ–‡æ¡£åæ˜ å½“å‰ç³»ç»Ÿæ¶æ„ï¼Œå¦‚æœ‰æ›´æ–°è¯·åŠæ—¶ä¿®è®¢ã€‚
