AI 代码修改规则与最佳实践（优化版）
📋 目录
1. 概述
2. 变更前置约束
3. 分层验证机制
4. 版本控制与回溯
5. AI 交互优化
6. 质量保障体系
7. 监控与反馈
8. BUG 修复记录与知识库
9. 快速参考

1. 概述
1.1 问题背景
AI 修改代码时频繁出现 "改此坏彼" 的问题，本质是缺乏系统性的变更控制和验证机制。结合量化交易项目的严谨性，需要通过流程化方案避免来回救火，同时新增 BUG 记录体系，确保历史问题可追溯、可复用。
1.2 核心原则
最小变更原则：只修改目标相关的最小代码块
分层验证原则：多层级验证确保修改质量
可回溯原则：任何修改都必须能够快速回滚，且 BUG 修复过程全程记录
透明化原则：所有修改过程、BUG 根因、修复方案需可追踪和可审计
架构合规原则：100% 遵循配置驱动架构，严禁任何临时补救措施
知识沉淀原则：所有 BUG 修复案例需纳入知识库，支撑 AI 后续自主规避
1.3 适用场景
量化交易系统代码修改
跨模块功能开发
性能优化和 bug 修复
系统架构调整

2. 变更前置约束
2.1 保护范围定义
2.1.1 创建 PROTECTED.md
在项目根目录创建 PROTECTED.md，列出禁止 AI 擅自修改的核心模块，例如：
markdown
# 禁止AI自动修改的内容
## 核心交易模块
1. `/core/trade_executor.py` - 交易执行核心
2. `/core/risk_manager.py` - 风险控制核心
3. `/core/position_manager.py` - 仓位管理核心

## 数据库相关
4. `/db/schema/` - 数据库表结构定义
5. `/db/migrations/` - 数据库迁移脚本

## 配置与参数
6. `/config/risk_limits.yaml` - 风险控制参数
7. `/config/trading_params.yaml` - 交易参数配置

## 说明
以上内容修改需 JohnC 书面确认，AI 仅可提交修改建议；若因未确认导致 BUG，需在《BUG 修复记录》中标记 "保护范围违规"。
2.1.2 保护范围检查
AI 每次修改前必须检查是否涉及保护范围，检查结果需在《变更申请单》中记录
若涉及保护范围，自动终止并提示 "需人工确认"，同时生成《保护范围修改申请》
提供修改建议而非直接修改，建议内容需包含 "修改目的、影响范围、替代方案"
2.2 最小变更原则（新增 BUG 预防点）
2.2.1 变更范围限制
只修改 "目标相关" 的最小代码块，避免 "顺带优化" 无关逻辑（历史 BUG 中 30% 源于此）
修复函数 bug 时，不触碰其他无关函数，若发现其他问题需单独创建 BUG 记录
新增功能优先用 "扩展" 而非 "修改"，扩展代码需标注 "新增扩展：XX 功能，关联需求 ID：XXX"
2.2.2 扩展优先策略（补充反例 BUG 说明）
python
运行
# ❌ 错误方式：直接修改原有函数（曾导致 bug#003：A股数据爬取异常）
def crawl_a_data():
    # 原有逻辑 + 新增创业板逻辑（未隔离，导致主板数据爬取出错）
    pass

# ✅ 正确方式：新增扩展函数（规避 bug#003 同类问题）
def crawl_gem_data():
    # 创业板专用逻辑（独立函数，不影响原有逻辑）
    pass

def crawl_a_data():
    # 保持原有逻辑不变，新增调用入口（需在文档中标注关联关系）
    pass
2.3 变更影响评估（新增 BUG 风险关联）
2.3.1 影响范围分析
AI 修改前必须输出：
直接影响的文件和函数（需标注是否为历史 BUG 涉及模块）
间接影响的模块和依赖（需检查依赖模块的 BUG 历史记录）
潜在的风险传播路径（参考知识库中同类变更的 BUG 案例）
2.3.2 风险评估矩阵（补充 BUG 历史权重）
影响范围	风险等级	历史 BUG 次数	处理方式
单个函数	低	0-1 次	直接修改 + 单元测试
单个模块	中	2-3 次	需要测试验证 + 参考历史 BUG 修复方案
跨模块	高	≥3 次	需要人工审核 + 全量回归测试 + BUG 预案
核心模块	极高	无（禁止修改）	禁止修改，仅允许提交建议 + 人工评估
2.4 架构模式遵循检查（新增 BUG 案例关联）
2.4.1 配置驱动模式检查
在项目采用配置驱动架构时，AI 必须检查：
是否所有配置项都在配置文件中定义（参考 bug#002：配置缺失导致表创建失败）
是否通过配置管理器进行操作（禁止绕过，参考 bug#005：独立 SQL 导致架构混乱）
是否存在硬编码绕过配置的情况（需在代码中搜索 "hardcode" 关键词排查）
2.5 架构合规性原则（ConfigDriven 模式）
2.5.1 核心要求（补充 BUG 预防条款）
配置驱动架构的铁律：
✅ 所有表结构定义在配置文件中（如 table_config.yaml），缺失需记录 "配置缺失风险"
✅ 所有表创建通过配置管理器完成（如 ConfigDrivenTableManager.batch_create_tables()）
❌ 严禁使用独立 SQL 脚本绕过配置驱动架构（参考 bug#005 修复案例）
❌ 严禁任何临时补救措施违背架构原则（临时补救需在 BUG 记录中标记 "架构违规"）
2.5.2 禁止临时补救的典型案例（补充 BUG 标记）
场景：ConfigDrivenTableManager 报错，表无法创建（关联 bug#005）
❌ 错误做法（违背架构，标记为 bug#005 初始错误）：
python
运行
# 遇到 ConfigDrivenTableManager 报错时，绕过架构直接用 SQL（导致后续配置与表结构不一致）
conn = psycopg2.connect(...)
conn.execute("""
    CREATE TABLE strategies (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        ...
    )
""")  # ❌ 违背架构原则，破坏配置单一数据源，标记为 bug#005
✅ 正确做法（bug#005 修复方案）：
python
运行
# 1. 诊断 ConfigDrivenTableManager 的错误根因（定位到 ENUM 缺少 name 参数）
# 2. 修复 bug（参考 bug#005 根因分析：ENUM 类型未指定 name）
# 3. 删除所有表（避免残留手动创建的表）
# 4. 重新通过 ConfigDrivenTableManager 创建

mgr = DatabaseTableManager()
mgr.batch_create_tables('table_config.yaml')  # ✅ 遵循架构原则，bug#005 修复完成
2.5.3 架构合规的价值（补充 BUG 成本对比）
维度	临时补救的后果（bug#005 案例）	架构合规的收益
可追溯性	数据结构定义分散，后续排查耗时 4 小时	配置文件是单一数据源，所有状态 10 分钟可查
可维护性	新开发者理解成本增加 2 天	新团队成员 1 小时掌握表创建逻辑
一致性	开发 / 测试环境不一致，导致 2 个衍生 BUG	通过配置文件保证环境一致性，无衍生问题
自动化	无法通过脚本批量重建，部署耗时 1 小时	一键重建所有表，CI/CD 部署仅需 5 分钟
2.5.4 AI 自检清单（新增 BUG 历史检查项）
在修改涉及配置驱动架构的代码时，AI 必须问自己：
 这个修改是否绕过了配置管理器？（参考 bug#005 案例）
 是否存在 "临时补救" 的倾向？（临时补救需记录 BUG 风险）
 如果遇到工具报错，是否优先考虑修复工具而非绕过？（参考 bug#002 修复逻辑）
 修改后配置文件是否仍是唯一真实数据源？（检查是否与历史 BUG 冲突）
 是否参考了知识库中同类修改的 BUG 案例？（需标注参考的 BUG ID）

3. 分层验证机制（新增 BUG 拦截环节）
3.1 AI 自验证（第一层）
3.1.1 基础检查清单（新增 BUG 相关检查项）
AI 每次修改后必须执行：
 语法合规性：pylint/flake8 检查（需排除历史 BUG 已修复的语法问题）
 依赖兼容性：requirements.txt 冲突检查（参考 bug#004：依赖版本冲突导致崩溃）
 业务规则校验：项目开发规范检查（需关联知识库中同类业务的 BUG 案例）
 核心功能测试：保护范围核心用例验证（需覆盖历史 BUG 复现场景）
 BUG 历史排查：搜索修改模块的历史 BUG 记录，确认无同类问题
3.1.2 自查报告模板（新增 BUG 相关字段）
plaintext
=== AI 自查报告 ===
修改时间：2024-01-15 14:30
修改文件：/data_crawl/scripts/cleaner.py
修改类型：bug修复（关联 bug#006：数据清洗缺失值处理异常）
参考历史 BUG：bug#003（同类数据处理问题，已规避）

检查结果：
1. 语法检查：✅ 通过（无错误）
2. 依赖检查：✅ 通过（新增pandas==2.1.0，与现有numpy==1.24.3兼容，无 bug#004 同类冲突）
3. 业务规则：✅ 通过（未涉及禁止范围，未包含美股相关逻辑，符合数据处理规范）
4. 核心测试：✅ 通过（/tests/test_trade_executor.py 全部用例通过，包含 bug#006 复现用例）
5. BUG 排查：✅ 通过（未发现与修改模块相关的未修复 BUG）

风险评估：低风险（无历史 BUG 关联风险）
建议：可以进入下一层验证
3.2 自动化测试（第二层）
3.2.1 测试金字塔（补充 BUG 用例要求）
plaintext
        E2E测试 (10%)：需包含历史 BUG 场景的端到端验证（如 bug#005 架构合规场景）
       ┌─────────────┐
       │集成测试 (20%)│：需覆盖模块间交互的 BUG 点（如 bug#002 配置与表创建交互）
     ┌─────────────────┐
     │  单元测试 (70%)  │：需包含每个 BUG 修复后的回归用例（如 bug#006 缺失值处理用例）
     └─────────────────┘
3.2.2 测试要求（新增 BUG 用例管理）
单元测试：覆盖率 ≥ 80%，包含边界条件、异常情况及 历史 BUG 复现用例（每个 BUG 需对应至少 1 个单元测试）
集成测试：模块间交互测试，数据流验证，需包含 衍生 BUG 场景（如 bug#005 导致的配置与表结构不一致场景）
回归测试：历史用例集，确保老功能不被破坏，用例集需按 BUG ID 分类管理
3.2.3 CI/CD 集成（新增 BUG 检查步骤）
yaml
# .github/workflows/ci.yml
name: Code Quality Check
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: 安装依赖
        run: pip install -r requirements.txt
      - name: 语法检查
        run: pylint src/ && flake8 src/
      - name: 单元测试（含 BUG 回归用例）
        run: pytest tests/ --cov=src/ --cov-report=xml -k "not slow"
      - name: BUG 历史冲突检查
        run: python scripts/check_bug_conflict.py  # 自定义脚本，检查修改是否与未修复 BUG 冲突
      - name: 集成测试（含架构合规用例）
        run: pytest tests/integration/ -k "config_driven"  # 重点验证架构合规，避免 bug#005 同类问题
3.3 人工审核（第三层）
3.3.1 审核触发条件（补充 BUG 相关触发项）
涉及 PROTECTED.md 中的核心模块
变更影响范围超过单个函数
自动化测试出现新增失败用例
性能下降超过 10%
修改模块的历史 BUG 次数 ≥3 次（高风险模块需重点审核）
涉及架构调整（需额外检查是否与历史架构相关 BUG 冲突）
3.3.2 变更申请单模板（新增 BUG 相关字段）
markdown
## 变更申请单
**申请时间**：2024-01-15
**申请人**：AI Assistant
**审核人**：JohnC
**关联 BUG ID**：bug#006（数据清洗缺失值处理异常）
**参考历史 BUG**：bug#003（同类数据处理问题，已规避）

### 变更内容
修复A股日线数据缺失值处理逻辑（解决 bug#006：极端值导致数据清洗崩溃）

### 修改文件
- `/data_crawl/scripts/cleaner.py` (主要修改：新增缺失值边界判断)
- `/tests/test_cleaner.py` (新增测试：bug#006 复现用例 + 边界值用例)

### 关联测试
- 新增：`test_clean_missing_value()`（覆盖 bug#006 场景）
- 修复：3个回归测试用例（确保不引入 bug#003 同类问题）
- 覆盖率：从 75% 提升到 85%（新增 2 个 BUG 相关用例）

### 潜在风险
可能影响依赖该函数的均线计算模块（已补充对应测试，参考 bug#007 预防方案）

### 回滚方案
- 保留原函数作为 `clean_data_v1()`（便于回滚后对比）
- 提供快速回滚脚本：`scripts/rollback_cleaner.py`
- 数据库变更提供回滚迁移（若涉及，标注迁移脚本路径）

### 审核意见
- [ ] 同意修改
- [ ] 需要调整（需注明调整方向，如 "补充更多 BUG 边界用例"）
- [ ] 拒绝修改（需注明原因，如 "未规避 bug#003 同类风险"）

**审核人签名**：_________
**审核时间**：_________

4. 版本控制与回溯（新增 BUG 版本关联）
4.1 分支管理策略
4.1.1 分支结构（补充 BUG 修复分支规范）
plaintext
main (生产环境：仅稳定版本，关联已修复 BUG 清单)
├── develop (开发环境：集成已测试的功能，标注待验证 BUG)
├── feature/功能名称 (功能开发：标注关联需求 ID，无未修复 BUG)
├── hotfix/bug-xxx (紧急修复：xxx 为 BUG ID，如 hotfix/bug-006)
└── release/版本号 (发布准备：包含该版本修复的所有 BUG ID 清单)
4.1.2 分支规则（新增 BUG 分支要求）
main 分支：仅存放经过验证的稳定版本，AI 不得直接修改；每次合并需附带 " 版本 - BUG 清单

总结：构建 “可控变更 + 知识沉淀” 的 AI 代码修改闭环
代码修改的核心痛点，本质是 “自由性与稳定性的矛盾”—— 量化交易系统对可靠性的极致要求，不允许 “试错式修改”。本文通过 “约束 - 验证 - 回溯 - 沉淀” 四层机制，将 AI 从 “无序修改” 转化为 “可控协作”，关键逻辑可概括为三点：
1. 以 “前置约束” 降低 BUG 发生率
通过 PROTECTED.md 保护核心模块、最小变更原则、架构合规铁律，从源头规避高风险修改（如 100% 禁止绕过配置驱动的临时补救，避免 bug#005 同类架构混乱）。每一项约束都对应历史 BUG 教训，例如 “显式类型转换” 要求，正是源于隐式推断导致的数据库字段类型错误（参考 6.4 节 ORM 类型安全）。
2. 以 “分层验证” 拦截潜在 BUG
AI 自验证（含 BUG 历史排查）、自动化测试（含 BUG 回归用例）、人工审核（高风险模块重点把关）三层机制，形成 “自查 - 机查 - 人查” 的立体防护。尤其强调 “每个 BUG 对应至少 1 个单元测试”，确保历史问题不重复出现（如 bug#006 缺失值处理的用例覆盖），将 BUG 拦截在上线前。
3. 以 “知识沉淀” 提升长期协作效率
新增的 BUG 修复记录与知识库，不仅是 “问题存档”，更是 AI 自主优化的依据 —— 通过标准化 BUG 记录模板（含根因、修复方案、预防措施），让 AI 后续修改时可主动参考同类案例（如遇到配置驱动工具报错，自动优先修复工具而非绕过，参考 bug#002 修复逻辑）。同时，版本控制与分支管理中关联 BUG ID，让每一次变更都可追溯、可回滚，降低团队协作成本。
最终，这套规则的核心不是 “限制 AI”，而是 “让 AI 更安全地创造价值”—— 对于量化交易这类高敏感系统，“慢一点的合规修改” 远胜于 “快一点的救火式调整”；而知识库的沉淀，会让 AI 随着项目推进不断减少 BUG，形成 “修改 - 学习 - 优化” 的正向循环。
