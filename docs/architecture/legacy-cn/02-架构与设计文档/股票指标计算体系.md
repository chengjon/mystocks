股票指标计算/管理体系设计方案
1. 体系架构设计
1.1 分层架构
text

应用层 (API + 前端)
   ↓
服务层 (指标计算引擎)
   ↓
数据层 (原始数据 + 指标缓存)
   ↓
存储层 (PostgreSQL + TDengine + Redis)

1.2 核心模块划分
text

1. 指标定义管理器
2. 计算任务调度器
3. 数据源管理器
4. 指标计算引擎
5. 指标存储管理器
6. 监控与告警模块

2. 数据库设计
2.1 核心表结构
sql

-- 1. 指标定义表
CREATE TABLE indicator_definitions (
    id SERIAL PRIMARY KEY,
    indicator_code VARCHAR(50) UNIQUE NOT NULL,  -- 如: MA_5, RSI_14
    indicator_name VARCHAR(100) NOT NULL,
    category VARCHAR(50),  -- 趋势/动量/波动率/成交量/基本面
    formula TEXT NOT NULL,  -- 计算公式或计算逻辑描述
    parameters JSONB,       -- 参数定义，如{"period": 5}
    description TEXT,
    version INTEGER DEFAULT 1,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 2. 指标数据表 (按频率分表)
-- 日频指标
CREATE TABLE indicator_daily (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(10) NOT NULL,
    trade_date DATE NOT NULL,
    indicator_code VARCHAR(50) NOT NULL,
    value DECIMAL(20,6),
    metadata JSONB,  -- 额外信息，如计算状态、数据来源等
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(stock_code, trade_date, indicator_code)
);
CREATE INDEX idx_indicator_daily_code_date ON indicator_daily(stock_code, trade_date);
CREATE INDEX idx_indicator_daily_indicator ON indicator_daily(indicator_code);

-- 分钟级指标 (使用TDengine)
-- 创建超级表
CREATE STABLE IF NOT EXISTS indicators_1min (
    ts TIMESTAMP,
    value DOUBLE,
    status TINYINT
) TAGS (stock_code BINARY(10), indicator_code BINARY(50));

-- 3. 计算任务表
CREATE TABLE calculation_tasks (
    id BIGSERIAL PRIMARY KEY,
    task_type VARCHAR(50),  -- 全量计算/增量计算/实时计算
    status VARCHAR(20),     -- pending/running/success/failed
    priority INTEGER DEFAULT 5,
    parameters JSONB,       -- 计算参数
    progress FLOAT DEFAULT 0,
    total_items INTEGER,
    processed_items INTEGER DEFAULT 0,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 4. 数据依赖关系表
CREATE TABLE data_dependencies (
    id SERIAL PRIMARY KEY,
    indicator_code VARCHAR(50) NOT NULL,
    required_data_type VARCHAR(50),  -- 如: daily_price, financial_report
    required_fields JSONB,           -- 需要的字段列表
    min_data_points INTEGER,         -- 最小数据点数
    update_frequency VARCHAR(20),    -- daily/weekly/quarterly
    FOREIGN KEY (indicator_code) REFERENCES indicator_definitions(indicator_code)
);

3. 指标分类体系
3.1 指标分类维度
yaml

技术指标:
  趋势类: MA, EMA, MACD, 布林带
  动量类: RSI, KDJ, CCI, WR
  成交量: OBV, VR, MFI
  波动率: ATR, 波动率通道
  
基本面指标:
  估值类: PE, PB, PS, PEG
  盈利类: ROE, ROA, 毛利率, 净利率
  成长类: 营收增长率, 净利润增长率
  财务健康: 资产负债率, 流动比率
  
风险指标:
  波动率: 历史波动率, 已实现波动率
  下行风险: VaR, CVaR, 最大回撤
  流动性: 换手率, Amihud非流动性指标
  
衍生指标:
  复合指标: 综合评分, 风险分数
  对比指标: 行业分位数, 历史分位数

3.2 指标计算频率
python

频率等级 = {
    "L1": "实时(秒级)",      # 实时监控用
    "L2": "分钟级(1/5/15/30/60分)",  # 盘中分析
    "L3": "日级",            # 盘后分析
    "L4": "周级/月级",       # 中长期分析
    "L5": "季级/年级"        # 基本面分析
}

4. 计算引擎设计
4.1 计算引擎架构
python

class IndicatorCalculationEngine:
    """
    指标计算引擎
    支持批量计算、实时计算、增量计算
    """
    
    def __init__(self):
        self.calculators = {}  # 注册的计算器
        self.data_fetcher = DataFetcher()
        self.cache_manager = CacheManager()
        
    def register_calculator(self, indicator_code, calculator_class):
        """注册指标计算器"""
        self.calculators[indicator_code] = calculator_class
        
    def calculate_single(self, stock_code, indicator_code, 
                         start_date, end_date, params=None):
        """计算单个指标"""
        # 1. 检查缓存
        cached = self.cache_manager.get(stock_code, indicator_code, 
                                       start_date, end_date)
        if cached and not params.get('force_recalc'):
            return cached
            
        # 2. 获取所需数据
        calculator = self.calculators[indicator_code]
        required_data = calculator.get_required_data()
        raw_data = self.data_fetcher.fetch(stock_code, required_data, 
                                          start_date, end_date)
        
        # 3. 计算指标
        result = calculator.calculate(raw_data, params)
        
        # 4. 缓存结果
        self.cache_manager.set(stock_code, indicator_code, result)
        
        return result
        
    def calculate_batch(self, stock_list, indicator_list, date_range):
        """批量计算"""
        # 使用任务队列并行计算
        tasks = []
        for stock in stock_list:
            for indicator in indicator_list:
                task = CalculationTask(stock, indicator, date_range)
                tasks.append(task)
                
        return self.parallel_execute(tasks)
        
    def calculate_realtime(self, stock_code, indicator_code, 
                          realtime_price):
        """实时计算"""
        # 获取历史数据
        history_data = self.get_latest_history(stock_code, 
                                              indicator_code)
        
        # 结合实时数据计算
        calculator = self.calculators[indicator_code]
        result = calculator.update_realtime(history_data, realtime_price)
        
        # 更新实时缓存
        self.cache_manager.update_realtime(stock_code, indicator_code, 
                                         result)
        
        return result

4.2 计算器接口规范
python

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Optional
import pandas as pd

@dataclass
class CalculationResult:
    values: pd.Series  # 指标值序列
    metadata: Dict     # 元数据，如计算状态、数据质量
    dependencies: List[str]  # 依赖的指标或数据
    
class IndicatorCalculator(ABC):
    """指标计算器基类"""
    
    @property
    @abstractmethod
    def indicator_code(self) -> str:
        pass
        
    @property
    @abstractmethod
    def required_fields(self) -> List[str]:
        """需要的原始数据字段"""
        pass
        
    @property
    @abstractmethod
    def min_data_points(self) -> int:
        """最小数据点数"""
        pass
        
    @abstractmethod
    def calculate(self, data: pd.DataFrame, 
                 params: Dict) -> CalculationResult:
        """批量计算"""
        pass
        
    def update_realtime(self, historical_result: CalculationResult,
                       realtime_data: Dict) -> CalculationResult:
        """实时更新计算"""
        # 默认实现：重新计算
        return self.calculate(
            pd.concat([historical_result.values, realtime_data]),
            self.default_params
        )

4.3 常用计算器实现示例
python

class MACalculator(IndicatorCalculator):
    """移动平均线计算器"""
    
    @property
    def indicator_code(self):
        return "MA"
        
    @property
    def required_fields(self):
        return ["close"]
        
    @property
    def min_data_points(self):
        return max(self.params.get("periods", [5, 10, 20, 60]))
        
    def calculate(self, data: pd.DataFrame, params: Dict):
        periods = params.get("periods", [5, 10, 20, 60])
        
        results = {}
        metadata = {
            "calculation_method": "simple_moving_average",
            "periods": periods,
            "data_quality": self._check_data_quality(data)
        }
        
        for period in periods:
            if len(data) >= period:
                ma_values = data["close"].rolling(window=period).mean()
                results[f"MA_{period}"] = ma_values
            else:
                results[f"MA_{period}"] = pd.Series([None] * len(data))
                
        return CalculationResult(
            values=pd.DataFrame(results),
            metadata=metadata,
            dependencies=["close"]
        )

class RSICalculator(IndicatorCalculator):
    """RSI计算器"""
    
    def calculate(self, data: pd.DataFrame, params: Dict):
        period = params.get("period", 14)
        
        delta = data["close"].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        metadata = {
            "period": period,
            "overbought": 70,
            "oversold": 30,
            "calculation_formula": "100 - 100/(1+RS)"
        }
        
        return CalculationResult(
            values=rsi,
            metadata=metadata,
            dependencies=["close"]
        )

5. 计算任务调度系统
5.1 调度策略
python

class CalculationScheduler:
    """计算任务调度器"""
    
    def __init__(self):
        self.daily_schedule = {
            "00:05": ["daily_price_indicators"],  # 盘后计算
            "01:00": ["volatility_indicators"],
            "02:00": ["fundamental_indicators"],
            "09:15": ["pre_market_indicators"],   # 盘前计算
        }
        
        self.realtime_triggers = [
            "price_change_1%",     # 价格变动1%
            "volume_spike",        # 成交量异动
            "time_interval_5min",  # 每5分钟
        ]
        
    def schedule_daily_tasks(self):
        """安排日频任务"""
        for stock in self.monitored_stocks:
            tasks = []
            
            # 日级指标
            tasks.append({
                "type": "daily",
                "stock": stock,
                "indicators": ["MA", "RSI", "MACD", "BOLL"],
                "priority": 3
            })
            
            # 基本面指标（季度）
            if self.is_quarter_end():
                tasks.append({
                    "type": "quarterly",
                    "stock": stock,
                    "indicators": ["PE", "PB", "ROE"],
                    "priority": 2
                })
                
            self.submit_tasks(tasks)
            
    def schedule_realtime_tasks(self, market_event):
        """实时任务调度"""
        triggered_indicators = []
        
        if market_event.type == "price_change":
            if abs(market_event.change_pct) > 0.01:
                triggered_indicators.extend(["ATR", "Volatility"])
                
        if market_event.type == "volume_spike":
            triggered_indicators.append("Volume_Indicators")
            
        # 提交实时计算任务
        for indicator in triggered_indicators:
            task = RealtimeTask(
                stock=market_event.stock_code,
                indicator=indicator,
                timestamp=market_event.timestamp,
                priority=1  # 高优先级
            )
            self.realtime_queue.put(task)

5.2 任务优先级队列
python

class PriorityTaskQueue:
    """带优先级的任务队列"""
    
    PRIORITY_LEVELS = {
        "CRITICAL": 0,   # 实时风险监控
        "HIGH": 1,       # 交易信号生成
        "NORMAL": 2,     # 日常指标计算
        "LOW": 3,        # 历史数据补全
        "BACKGROUND": 4  # 批量回测
    }
    
    def submit_task(self, task):
        """提交任务"""
        priority = self.PRIORITY_LEVELS.get(task.priority, 2)
        self.queues[priority].put(task)
        
    def get_next_task(self):
        """获取下一个任务"""
        for priority in sorted(self.PRIORITY_LEVELS.values()):
            if not self.queues[priority].empty():
                return self.queues[priority].get()
        return None

6. 缓存策略
6.1 多级缓存设计
python

class MultiLevelCache:
    """多级缓存管理器"""
    
    def __init__(self):
        # L1: 内存缓存 (高频指标)
        self.l1_cache = LRUCache(maxsize=10000)
        
        # L2: Redis缓存 (全量指标)
        self.redis_client = redis.Redis()
        
        # L3: 本地磁盘缓存 (冷数据)
        self.disk_cache = DiskCache()
        
    def get(self, stock_code, indicator_code, date_range):
        """获取缓存数据"""
        cache_key = f"{stock_code}:{indicator_code}:{date_range}"
        
        # 1. 检查L1缓存
        result = self.l1_cache.get(cache_key)
        if result:
            return result
            
        # 2. 检查Redis缓存
        result = self.redis_client.get(cache_key)
        if result:
            # 存入L1缓存
            self.l1_cache.put(cache_key, result)
            return result
            
        # 3. 检查磁盘缓存
        result = self.disk_cache.get(cache_key)
        if result:
            # 存入Redis缓存
            self.redis_client.setex(cache_key, 3600, result)
            self.l1_cache.put(cache_key, result)
            return result
            
        return None
        
    def set(self, stock_code, indicator_code, date_range, data):
        """设置缓存"""
        cache_key = f"{stock_code}:{indicator_code}:{date_range}"
        
        # 1. 存入L1缓存
        self.l1_cache.put(cache_key, data)
        
        # 2. 存入Redis缓存 (设置过期时间)
        # 根据数据频率设置不同的过期时间
        ttl = self._get_ttl(indicator_code)
        self.redis_client.setex(cache_key, ttl, data)
        
        # 3. 持久化到磁盘
        if self._should_persist(indicator_code):
            self.disk_cache.set(cache_key, data)

6.2 缓存过期策略
python

def _get_ttl(self, indicator_code):
    """根据指标类型获取缓存过期时间"""
    ttl_map = {
        "realtime": 60,          # 1分钟
        "intraday": 300,         # 5分钟
        "daily": 86400,          # 1天
        "weekly": 604800,        # 7天
        "monthly": 2592000,      # 30天
        "quarterly": 7776000,    # 90天
        "yearly": 31536000,      # 365天
    }
    
    # 根据指标代码判断类型
    if indicator_code.startswith("RT_"):
        return ttl_map["realtime"]
    elif indicator_code in ["MA", "RSI", "MACD"]:
        return ttl_map["daily"]
    elif indicator_code in ["PE", "PB", "ROE"]:
        return ttl_map["quarterly"]
    else:
        return ttl_map["daily"]

7. 监控与告警
7.1 计算质量监控
python

class CalculationMonitor:
    """计算质量监控"""
    
    METRICS_TO_MONITOR = [
        "calculation_latency",     # 计算延迟
        "data_freshness",          # 数据新鲜度
        "success_rate",            # 计算成功率
        "cache_hit_rate",          # 缓存命中率
        "resource_usage",          # 资源使用率
    ]
    
    def check_data_quality(self, indicator_data):
        """检查数据质量"""
        issues = []
        
        # 1. 检查缺失值
        missing_rate = indicator_data.isnull().mean()
        if missing_rate > 0.1:
            issues.append(f"缺失值过多: {missing_rate:.2%}")
            
        # 2. 检查数据异常
        if self._has_outliers(indicator_data):
            issues.append("存在异常值")
            
        # 3. 检查数据一致性
        if not self._check_consistency(indicator_data):
            issues.append("数据不一致")
            
        return {
            "score": 100 - len(issues) * 20,
            "issues": issues,
            "timestamp": datetime.now()
        }
        
    def monitor_calculation_latency(self):
        """监控计算延迟"""
        latency_metrics = {}
        
        for indicator in self.active_indicators:
            # 记录计算开始时间
            start_time = time.time()
            
            # 执行计算
            result = self.calculate_indicator(indicator)
            
            # 记录延迟
            latency = time.time() - start_time
            latency_metrics[indicator] = latency
            
            # 触发告警
            if latency > self.thresholds[indicator]:
                self.trigger_alert(
                    f"指标{indicator}计算延迟过高: {latency:.2f}s"
                )
                
        return latency_metrics

7.2 告警规则配置
yaml

alert_rules:
  calculation_failure:
    condition: "success_rate < 95% for 5 minutes"
    severity: "critical"
    action: "通知运维团队"
    
  data_staleness:
    condition: "data_age > 1 hour for daily indicators"
    severity: "high"
    action: "触发重新计算"
    
  resource_exhaustion:
    condition: "cpu_usage > 80% or memory_usage > 90%"
    severity: "high"
    action: "扩容或优化计算任务"
    
  cache_miss_rate:
    condition: "cache_hit_rate < 60% for 1 hour"
    severity: "medium"
    action: "调整缓存策略"

8. 配置管理
8.1 指标配置文件
yaml

indicators:
  MA:
    description: "移动平均线"
    category: "trend"
    calculator: "MACalculator"
    parameters:
      periods: [5, 10, 20, 60]
    dependencies:
      - "close"
    update_frequency: "daily"
    cache_ttl: 86400
    
  RSI:
    description: "相对强弱指标"
    category: "momentum"
    calculator: "RSICalculator"
    parameters:
      period: 14
      overbought: 70
      oversold: 30
    dependencies:
      - "close"
    update_frequency: "daily"
    cache_ttl: 86400
    
  ATR:
    description: "平均真实波幅"
    category: "volatility"
    calculator: "ATRCalculator"
    parameters:
      period: 14
    dependencies:
      - "high"
      - "low"
      - "close"
    update_frequency: "intraday"
    cache_ttl: 300

8.2 计算引擎配置
yaml

calculation_engine:
  max_workers: 8
  batch_size: 100
  retry_times: 3
  retry_delay: 5
  
  realtime:
    enabled: true
    update_interval: 60  # 秒
    max_concurrent: 50
    
  batch:
    enabled: true
    schedule: "0 1 * * *"  # 每天1点
    priority: "LOW"
    
  cache:
    l1_size: 10000
    redis_ttl: 3600
    enable_disk_cache: true

9. API设计
9.1 RESTful API
python

# 指标计算API
@app.route('/api/v1/indicators/calculate', methods=['POST'])
def calculate_indicators():
    """
    计算指标
    POST /api/v1/indicators/calculate
    {
        "stock_codes": ["000001.SZ", "600000.SH"],
        "indicator_codes": ["MA_5", "RSI_14"],
        "start_date": "2024-01-01",
        "end_date": "2024-01-31",
        "force_recalculate": false
    }
    """
    pass

# 指标数据查询API
@app.route('/api/v1/indicators/data', methods=['GET'])
def get_indicator_data():
    """
    获取指标数据
    GET /api/v1/indicators/data?
        stock_code=000001.SZ&
        indicator_code=MA_5&
        start_date=2024-01-01&
        end_date=2024-01-31
    """
    pass

# 实时指标API
@app.route('/api/v1/indicators/realtime', methods=['GET'])
def get_realtime_indicators():
    """
    获取实时指标
    GET /api/v1/indicators/realtime?
        stock_code=000001.SZ&
        indicator_codes=MA_5,RSI_14
    """
    pass

# 任务状态API
@app.route('/api/v1/tasks/<task_id>', methods=['GET'])
def get_task_status(task_id):
    """获取任务状态"""
    pass

9.2 WebSocket实时推送
python

@app.websocket('/ws/v1/indicators/realtime')
async def realtime_indicators_ws(websocket):
    """实时指标WebSocket推送"""
    await websocket.accept()
    
    # 订阅请求
    subscription = await websocket.receive_json()
    stock_code = subscription["stock_code"]
    indicators = subscription["indicators"]
    
    # 创建实时计算任务
    calculator = RealtimeCalculator(stock_code, indicators)
    
    try:
        while True:
            # 获取最新行情
            realtime_data = await get_realtime_data(stock_code)
            
            # 计算实时指标
            results = calculator.update(realtime_data)
            
            # 推送结果
            await websocket.send_json({
                "timestamp": datetime.now().isoformat(),
                "data": results
            })
            
            await asyncio.sleep(5)  # 5秒推送一次
            
    except WebSocketDisconnect:
        calculator.cleanup()