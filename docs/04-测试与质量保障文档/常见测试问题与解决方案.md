# 常见测试问题与解决方案

## 概述

本文档汇总了MyStocks项目在测试过程中遇到的常见问题及其解决方案，旨在帮助开发团队快速定位和解决测试相关问题，提高测试效率和代码质量。

## 前端测试问题

### 1. 菜单事件绑定问题

**问题描述**
```javascript
// 错误示例：事件绑定失效
<el-menu-item @click="handleMenuClick('dashboard')">仪表盘</el-menu-item>
```

**解决方案**
```javascript
// 正确示例：使用箭头函数确保正确的作用域
<el-menu-item @click="() => handleMenuClick('dashboard')">仪表盘</el-menu-item>

// 或者在methods中定义
methods: {
  handleMenuClick(route) {
    this.$router.push(route)
  }
}
```

**预防措施**
- 使用Vue DevTools检查事件绑定
- 在组件mounted后验证事件监听器
- 编写单元测试验证用户交互

### 2. 路由逻辑问题

**问题描述**
```javascript
// 错误示例：路由跳转失败
this.$router.push('/dashboard') // 404错误
```

**解决方案**
```javascript
// 正确示例：使用命名路由
this.$router.push({ name: 'Dashboard' })

// 或使用路径参数
this.$router.push({
  path: '/stock/:symbol',
  params: { symbol: '600000' }
})
```

**预防措施**
- 在router/index.js中定义所有路由
- 使用路由守卫验证权限
- 编写路由导航测试

### 3. 变量作用域问题

**问题描述**
```javascript
// 错误示例：异步操作中变量作用域丢失
for (let i = 0; i < stocks.length; i++) {
  setTimeout(() => {
    console.log(stocks[i]) // undefined
  }, 1000)
}
```

**解决方案**
```javascript
// 正确示例：使用闭包或async/await
// 方案1：闭包
for (let i = 0; i < stocks.length; i++) {
  ((index) => {
    setTimeout(() => {
      console.log(stocks[index])
    }, 1000)
  })(i)
}

// 方案2：async/await
for (const stock of stocks) {
  await new Promise(resolve => setTimeout(resolve, 1000))
  console.log(stock)
}
```

**预防措施**
- 使用ESLint检查变量使用
- 编写异步操作的单元测试
- 使用TypeScript增强类型检查

## API测试问题

### 1. 参数错误

**问题描述**
```python
# 错误示例：缺少必需参数
@app.get("/api/stocks/{symbol}")
async def get_stock(symbol: str):
    # 缺少start_date和end_date参数验证
    pass
```

**解决方案**
```python
# 正确示例：完整的参数验证
from pydantic import BaseModel, validator
from datetime import datetime

class StockQuery(BaseModel):
    symbol: str
    start_date: datetime
    end_date: datetime

    @validator('start_date', 'end_date')
    def validate_dates(cls, v):
        if v > datetime.now():
            raise ValueError('日期不能超过当前时间')
        return v

@app.get("/api/stocks/{symbol}")
async def get_stock(symbol: str, query: StockQuery):
    # 完整的参数验证
    pass
```

**预防措施**
- 使用Pydantic模型进行参数验证
- 编写API参数测试用例
- 使用OpenAPI文档自动生成验证

### 2. 响应格式不一致

**问题描述**
```python
# 错误示例：响应格式不统一
@app.get("/api/stocks")
def get_stocks():
    return [{"symbol": "600000", "name": "浦发银行"}]  # 直接返回列表

@app.get("/api/stocks/{symbol}")
def get_stock(symbol: str):
    return {"success": True, "data": {"symbol": "600000"}}  # 包装格式
```

**解决方案**
```python
# 正确示例：统一响应格式
from typing import Any, Dict, List, Optional, Union
from pydantic import BaseModel

class APIResponse(BaseModel):
    success: bool
    data: Optional[Any] = None
    message: str = ""
    error: Optional[Dict] = None
    timestamp: datetime = Field(default_factory=datetime.now)

@app.get("/api/stocks")
async def get_stocks():
    stocks = await get_stock_list()
    return APIResponse(
        success=True,
        data=stocks,
        message="获取股票列表成功"
    )

@app.get("/api/stocks/{symbol}")
async def get_stock(symbol: str):
    stock = await get_stock_detail(symbol)
    return APIResponse(
        success=True,
        data=stock,
        message="获取股票详情成功"
    )
```

**预防措施**
- 定义统一的API响应模型
- 编写响应格式测试
- 使用中间件统一处理响应格式

## 数据库测试问题

### 1. 连接超时

**问题描述**
```python
# 错误示例：没有连接超时处理
engine = create_engine("postgresql://user:pass@localhost/mystocks")
# 长时间查询导致连接超时
```

**解决方案**
```python
# 正确示例：配置连接池和超时
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    "postgresql://user:pass@localhost/mystocks",
    poolclass=QueuePool,
    pool_size=10,
    max_overflow=20,
    pool_timeout=30,
    pool_recycle=3600,
    connect_args={
        "connect_timeout": 10,
        "command_timeout": 30
    }
)

# 使用上下文管理器确保连接释放
async def execute_query(query: str):
    async with engine.connect() as conn:
        result = await conn.execute(query)
        return result.fetchall()
```

**预防措施**
- 配置合适的连接池参数
- 编写连接超时测试
- 监控数据库连接状态

### 2. 数据一致性问题

**问题描述**
```python
# 错误示例：并发操作导致数据不一致
async def update_stock_price(symbol: str, price: float):
    # 读取-修改-写入不是原子操作
    current = await get_stock_price(symbol)
    new_price = current + price
    await save_stock_price(symbol, new_price)
```

**解决方案**
```python
# 正确示例：使用事务和锁
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

async def update_stock_price(session: AsyncSession, symbol: str, price: float):
    try:
        # 使用FOR UPDATE锁定记录
        stmt = select(Stock).where(Stock.symbol == symbol).with_for_update()
        result = await session.execute(stmt)
        stock = result.scalar_one()

        if stock:
            stock.price += price
            await session.commit()
            return stock
    except Exception as e:
        await session.rollback()
        raise e
```

**预防措施**
- 使用数据库事务确保原子性
- 编写并发测试用例
- 实施乐观锁或悲观锁机制

## 部署测试问题

### 1. 端口冲突

**问题描述**
```bash
# 错误示例：硬编码端口导致冲突
uvicorn app.main:app --host 0.0.0.0 --port 8000
# 端口8000已被占用
```

**解决方案**
```python
# 正确示例：自动端口检测
import socket
from contextlib import closing

def find_free_port(start_port: int = 8000, max_port: int = 8010) -> int:
    for port in range(start_port, max_port + 1):
        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
            if sock.connect_ex(('localhost', port)) != 0:
                return port
    raise RuntimeError("No available ports found")

# 使用自动检测的端口
port = find_free_port()
uvicorn.run(app, host="0.0.0.0", port=port)
```

**预防措施**
- 使用环境变量配置端口
- 编写端口可用性检查
- 容器化部署避免端口冲突

### 2. 环境变量缺失

**问题描述**
```python
# 错误示例：没有默认值
import os
database_url = os.getenv('DATABASE_URL')  # 可能为None
```

**解决方案**
```python
# 正确示例：提供默认值和验证
from typing import Optional
import os
from pydantic import BaseSettings

class Settings(BaseSettings):
    database_url: str
    redis_url: str = "redis://localhost:6379"
    debug: bool = False

    class Config:
        env_file = ".env"

    def validate_settings(self):
        if not self.database_url:
            raise ValueError("DATABASE_URL is required")

settings = Settings()
settings.validate_settings()
```

**预防措施**
- 提供配置文件模板
- 编写配置验证测试
- 使用配置管理工具

## 测试工具问题

### 1. Playwright测试失败

**问题描述**
```javascript
// 错误示例：元素定位不稳定
await page.click('.stock-item') // 元素可能还未加载
```

**解决方案**
```javascript
// 正确示例：等待元素加载
await page.waitForSelector('.stock-item', { state: 'visible' })
await page.click('.stock-item')

// 或使用更稳定的选择器
await page.click('[data-testid="stock-item"]')
```

**预防措施**
- 使用稳定的测试ID
- 编写等待策略
- 实施测试重试机制

### 2. 测试数据管理

**问题描述**
```python
# 错误示例：测试数据硬编码
def test_stock_api():
    symbol = "600000"  # 硬编码
    response = client.get(f"/api/stocks/{symbol}")
    assert response.status_code == 200
```

**解决方案**
```python
# 正确示例：使用测试夹具
import pytest
from test_data import SAMPLE_STOCKS

@pytest.fixture
def sample_stock():
    return SAMPLE_STOCKS[0]

def test_stock_api(sample_stock):
    symbol = sample_stock['symbol']
    response = client.get(f"/api/stocks/{symbol}")
    assert response.status_code == 200
```

**预防措施**
- 使用测试数据库
- 实施数据工厂模式
- 编写数据清理脚本

## 性能测试问题

### 1. 内存泄漏

**问题描述**
```python
# 错误示例：大对象没有及时释放
def process_large_dataset():
    data = load_large_dataset()  # 大对象
    processed = process(data)
    # 没有释放data对象
    return processed
```

**解决方案**
```python
# 正确示例：及时释放资源
def process_large_dataset():
    data = load_large_dataset()
    try:
        processed = process(data)
        return processed
    finally:
        del data  # 显式释放
        gc.collect()  # 强制垃圾回收
```

**预防措施**
- 使用内存分析工具
- 编写内存泄漏测试
- 监控应用程序内存使用

### 2. 并发性能问题

**问题描述**
```python
# 错误示例：同步操作阻塞
@app.get("/api/heavy-computation")
def heavy_computation():
    result = cpu_intensive_task()  # 阻塞事件循环
    return result
```

**解决方案**
```python
# 正确示例：异步处理
import asyncio
from concurrent.futures import ProcessPoolExecutor

@app.get("/api/heavy-computation")
async def heavy_computation():
    loop = asyncio.get_event_loop()
    with ProcessPoolExecutor() as executor:
        result = await loop.run_in_executor(
            executor, cpu_intensive_task
        )
    return result
```

**预防措施**
- 使用异步编程模式
- 编写并发性能测试
- 监控系统资源使用

## 安全测试问题

### 1. CSRF攻击

**问题描述**
```python
# 错误示例：没有CSRF保护
@app.post("/api/update-stock")
def update_stock(data: dict):
    # 没有CSRF token验证
    return update_stock_data(data)
```

**解决方案**
```python
# 正确示例：CSRF保护
from fastapi_csrf_protect import CsrfProtect

@app.post("/api/update-stock")
@CsrfProtect.protect
def update_stock(data: dict, csrf_token: str):
    # CSRF token自动验证
    return update_stock_data(data)
```

**预防措施**
- 实施CSRF保护
- 编写安全测试用例
- 使用安全扫描工具

### 2. 输入验证

**问题描述**
```python
# 错误示例：没有输入验证
@app.get("/api/stocks/{symbol}")
def get_stock(symbol: str):
    # 没有验证symbol格式
    return get_stock_data(symbol)
```

**解决方案**
```python
# 正确示例：完整的输入验证
import re
from fastapi import HTTPException

@app.get("/api/stocks/{symbol}")
def get_stock(symbol: str):
    # 验证股票代码格式
    if not re.match(r'^\d{6}$', symbol):
        raise HTTPException(status_code=400, detail="Invalid stock symbol")

    # 白名单验证
    valid_symbols = get_valid_stock_list()
    if symbol not in valid_symbols:
        raise HTTPException(status_code=404, detail="Stock not found")

    return get_stock_data(symbol)
```

**预防措施**
- 实施输入验证
- 使用白名单机制
- 编写安全测试用例

## 故障排查指南

### 1. 测试失败排查步骤

1. **查看错误日志**
   ```bash
   tail -f logs/test.log
   ```

2. **运行单个测试**
   ```bash
   pytest tests/test_stock_api.py::test_get_stock -v
   ```

3. **调试模式运行**
   ```bash
   pytest --pdb tests/test_stock_api.py
   ```

4. **检查测试环境**
   ```bash
   python -c "from app.main import app; print('App loaded successfully')"
   ```

### 2. 性能问题排查

1. **使用性能分析工具**
   ```bash
   python -m cProfile -o profile.stats app/main.py
   ```

2. **内存分析**
   ```bash
   python -m memory_profiler app/main.py
   ```

3. **数据库查询分析**
   ```sql
   EXPLAIN ANALYZE SELECT * FROM stocks WHERE symbol = '600000';
   ```

### 3. 网络问题排查

1. **端口检查**
   ```bash
   netstat -tulpn | grep :8000
   ```

2. **连接测试**
   ```bash
   curl -I http://localhost:8000/health
   ```

3. **防火墙检查**
   ```bash
   sudo ufw status
   ```

## 最佳实践

### 1. 测试编写规范

- **AAA模式**：Arrange（准备）、Act（执行）、Assert（断言）
- **独立性**：每个测试用例应该独立运行
- **可重复性**：测试结果应该一致
- **清晰性**：测试意图应该明确

### 2. 错误处理规范

- **统一异常处理**：使用全局异常处理器
- **错误日志记录**：记录详细的错误信息
- **用户友好提示**：提供清晰的错误消息

### 3. 性能优化规范

- **异步优先**：使用异步编程模式
- **资源管理**：及时释放不需要的资源
- **缓存策略**：合理使用缓存提高性能

## 工具推荐

### 1. 测试工具

- **pytest**：Python测试框架
- **Playwright**：端到端测试
- **Jest**：JavaScript单元测试
- **Postman**：API测试

### 2. 性能工具

- **Apache Bench**：压力测试
- **Locust**：负载测试
- **Py-Spy**：Python性能分析
- **Memory Profiler**：内存分析

### 3. 安全工具

- **Bandit**：Python安全扫描
- **OWASP ZAP**：Web应用安全扫描
- **SQLMap**：SQL注入测试
- **Nikto**：Web服务器扫描

## 总结

本文档涵盖了MyStocks项目在测试过程中的常见问题和解决方案。通过遵循这些最佳实践和预防措施，开发团队可以：

1. **提高测试效率**：快速定位和解决问题
2. **减少错误发生**：通过预防措施避免常见问题
3. **改善代码质量**：通过测试驱动开发
4. **增强系统稳定性**：通过全面的测试覆盖

定期更新本文档，记录新遇到的问题和解决方案，形成团队的知识积累和共享机制。

---

*文档版本：v1.0*
*最后更新：2025-12-06*
*维护团队：MyStocks测试团队*
