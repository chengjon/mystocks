é’ˆå¯¹æ‚¨å¤šæ•°æ®æºç®¡ç†æ··ä¹±çš„é—®é¢˜ï¼Œæˆ‘å»ºè®®è®¾è®¡ä¸€ä¸ªæ•°æ®æºæ³¨å†Œä¸­å¿ƒæ–¹æ¡ˆã€‚è¿™ä¸ªæ–¹æ¡ˆä¸ä»…ç®¡ç†åŸå§‹æ¥å£ï¼Œè¿˜æä¾›å®Œæ•´çš„ç›‘æ§å’Œæ²»ç†èƒ½åŠ›ã€‚
ğŸ“Š æ–¹æ¡ˆï¼šæ•°æ®æºæ³¨å†Œä¸æ²»ç†ä¸­å¿ƒ
1. æ•°æ®æºå…ƒæ•°æ®æ³¨å†Œè¡¨ï¼ˆæ ¸å¿ƒï¼‰

åœ¨PostgreSQLä¸­å»ºç«‹ç»Ÿä¸€çš„æ•°æ®æºæ³¨å†Œè¡¨ï¼š
sql

CREATE TABLE data_source_registry (
    id SERIAL PRIMARY KEY,
    source_name VARCHAR(50),      -- æ•°æ®æºåç§°ï¼šakshareã€tushareç­‰
    source_type VARCHAR(20),      -- API/çˆ¬è™«/æ–‡ä»¶/æ•°æ®åº“
    endpoint_name VARCHAR(100),   -- æ¥å£åç§°ï¼Œå¦‚"akshare.stock_zh_a_hist"

    -- è°ƒç”¨ä¿¡æ¯
    call_method VARCHAR(20),      -- http/get/post/function_call
    endpoint_url TEXT,            -- å®Œæ•´URLæˆ–å‡½æ•°è·¯å¾„
    parameters JSONB,             -- å‚æ•°å®šä¹‰å’Œç¤ºä¾‹
    response_format VARCHAR(20),  -- json/csv/dataframe

    -- åˆ†ç±»ä¸è·¯ç”±
    data_category VARCHAR(50),    -- å¯¹åº”æ‚¨çš„34ä¸ªåˆ†ç±»
    target_db VARCHAR(20),        -- postgresql/tdengine
    table_name VARCHAR(100),      -- å­˜å‚¨çš„ç›®æ ‡è¡¨å

    -- å…ƒæ•°æ®
    description TEXT,
    update_frequency VARCHAR(20), -- å®æ—¶/æ—¥é¢‘/å‘¨é¢‘/æœˆé¢‘
    data_quality_score FLOAT,     -- æ•°æ®è´¨é‡è¯„åˆ†
    status VARCHAR(20),           -- active/deprecated/maintenance

    -- ç›‘æ§æŒ‡æ ‡
    last_success_time TIMESTAMP,
    avg_response_time FLOAT,
    success_rate FLOAT,
    quota_used INT,               -- è°ƒç”¨é¢åº¦ä½¿ç”¨æƒ…å†µ

    -- ç®¡ç†ä¿¡æ¯
    owner VARCHAR(50),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,

    -- ç´¢å¼•
    INDEX idx_category (data_category),
    INDEX idx_status (status)
);

2. ç»Ÿä¸€æ•°æ®æºç®¡ç†å™¨ç±»
python

class DataSourceManager:
    """ç»Ÿä¸€æ•°æ®æºç®¡ç†å…¥å£"""

    def __init__(self):
        self.registry = {}  # å†…å­˜ç¼“å­˜
        self.load_registry()

    def load_registry(self):
        """ä»æ•°æ®åº“åŠ è½½æ‰€æœ‰æ•°æ®æºé…ç½®"""
        # æ”¯æŒå¤šç§æ ¼å¼é…ç½®æ–‡ä»¶
        sources = self._load_from_db()
        sources.extend(self._load_from_yaml("sources_config.yaml"))

        for source in sources:
            self.registry[source['endpoint_name']] = {
                'handler': self._create_handler(source),
                'metadata': source,
                'cache': LRUCache(maxsize=100)
            }

    def get_data(self, endpoint_name, **kwargs):
        """ç»Ÿä¸€æ•°æ®è·å–æ¥å£"""
        # 1. æŸ¥æ‰¾æ•°æ®æº
        source = self.registry.get(endpoint_name)
        if not source:
            raise ValueError(f"æ•°æ®æº {endpoint_name} ä¸å­˜åœ¨")

        # 2. æ£€æŸ¥ç¼“å­˜
        cache_key = self._generate_cache_key(endpoint_name, kwargs)
        if cached := source['cache'].get(cache_key):
            return cached

        # 3. è°ƒç”¨å…·ä½“å¤„ç†å™¨
        start_time = time.time()
        try:
            data = source['handler'].fetch(**kwargs)

            # 4. è®°å½•æˆåŠŸæŒ‡æ ‡
            self._record_success(endpoint_name, time.time() - start_time)

            # 5. æ›´æ–°ç¼“å­˜
            source['cache'][cache_key] = data
            return data

        except Exception as e:
            self._record_failure(endpoint_name, str(e))
            raise

    def _create_handler(self, source_config):
        """å·¥å‚æ–¹æ³•åˆ›å»ºå…·ä½“å¤„ç†å™¨"""
        source_type = source_config['source_type']

        handlers = {
            'akshare': AkshareHandler,
            'tushare': TushareHandler,
            'baostock': BaostockHandler,
            'tdx': TdxHandler,
            'web_crawler': WebCrawlerHandler,
            'local_file': LocalFileHandler,
            'database': DatabaseHandler
        }

        return handlers[source_type](source_config)

3. å…·ä½“æ•°æ®æºå¤„ç†å™¨ç¤ºä¾‹
python

class AkshareHandler:
    """akshareæ•°æ®æºå¤„ç†å™¨"""

    def __init__(self, config):
        self.config = config
        self.module = importlib.import_module('akshare')

    def fetch(self, **kwargs):
        # åŠ¨æ€è°ƒç”¨akshareå‡½æ•°
        func_name = self.config['function_name']  # å¦‚"stock_zh_a_hist"
        func = getattr(self.module, func_name)

        # å‚æ•°æ˜ å°„è½¬æ¢
        mapped_args = self._map_arguments(kwargs)

        return func(**mapped_args)

    def _map_arguments(self, args):
        # å°†ç»Ÿä¸€å‚æ•°åæ˜ å°„åˆ°å…·ä½“APIå‚æ•°å
        param_mapping = self.config.get('param_mapping', {})
        return {param_mapping.get(k, k): v for k, v in args.items()}


class TushareHandler:
    """tushareå¤„ç†å™¨ï¼ˆå¸¦tokenç®¡ç†ï¼‰"""

    def __init__(self, config):
        self.pro = ts.pro_api(config['token'])
        self.config = config

    def fetch(self, **kwargs):
        # è‡ªåŠ¨å¤„ç†åˆ†é¡µã€é¢‘ç‡é™åˆ¶ç­‰
        return self.pro.query(
            self.config['api_name'],
            **kwargs,
            fields=self.config.get('fields')
        )

4. æ•°æ®æºç›‘æ§é¢æ¿

åˆ›å»ºWebç®¡ç†ç•Œé¢ï¼Œå±•ç¤ºï¼š
python

# APIç«¯ç‚¹å¥åº·ç›‘æ§
{
    "endpoint": "akshare.stock_zh_a_hist",
    "status": "healthy",
    "last_24h_calls": 1250,
    "success_rate": 99.8,
    "avg_response_time": 0.45,
    "last_error": null,
    "data_freshness": "5åˆ†é’Ÿå‰",
    "quota_remaining": "æ— é™åˆ¶"
}

5. é…ç½®æ–‡ä»¶ç»“æ„
yaml

# sources_config.yaml
data_sources:
  akshare_stock_daily:
    type: "akshare"
    function_name: "stock_zh_a_hist"
    category: "DAILY_KLINE"
    target_db: "postgresql"
    table_name: "daily_kline"

    # å‚æ•°å®šä¹‰
    parameters:
      symbol:
        required: true
        type: "string"
        example: "000001"
      period:
        default: "daily"
        options: ["daily", "weekly", "monthly"]
      start_date:
        type: "string"
        format: "YYYYMMDD"
      end_date:
        type: "string"
        format: "YYYYMMDD"

    # æ˜ å°„åˆ°akshareå®é™…å‚æ•°
    param_mapping:
      symbol: "symbol"
      period: "period"
      start_date: "start_date"
      end_date: "end_date"

    # æ›´æ–°ç­–ç•¥
    update_schedule: "daily 16:00"
    retention_days: 3650

  tushare_basic:
    type: "tushare"
    api_name: "stock_basic"
    category: "REFERENCE_DATA"
    token_env_var: "TUSHARE_TOKEN"
    quota: 5000  # æ¯æ—¥é™åˆ¶

6. è‡ªåŠ¨å‘ç°ä¸æ³¨å†Œ
python

class DataSourceDiscoverer:
    """è‡ªåŠ¨å‘ç°å¯ç”¨çš„æ•°æ®æº"""

    def scan_akshare(self):
        """æ‰«æakshareæ‰€æœ‰å¯ç”¨å‡½æ•°"""
        import akshare as ak
        for name in dir(ak):
            if not name.startswith('_'):
                func = getattr(ak, name)
                if callable(func):
                    # è‡ªåŠ¨ç”Ÿæˆæ¥å£å®šä¹‰
                    self.register_from_function(name, func)

    def register_from_function(self, name, func):
        """ä»å‡½æ•°è‡ªåŠ¨ç”Ÿæˆæ¥å£é…ç½®"""
        signature = inspect.signature(func)
        params = self._extract_params(signature)

        config = {
            'endpoint_name': f'akshare.{name}',
            'function_name': name,
            'parameters': params,
            'source_type': 'akshare'
        }

        # ä¿å­˜åˆ°æ³¨å†Œè¡¨
        self.db.save_source(config)

7. ä½¿ç”¨ç¤ºä¾‹
python

# ç»Ÿä¸€è°ƒç”¨æ–¹å¼
manager = DataSourceManager()

# 1. è·å–æ—¥Kçº¿æ•°æ®
kline = manager.get_data(
    endpoint_name="akshare.stock_zh_a_hist",
    symbol="000001",
    period="daily",
    start_date="20230101",
    end_date="20231231"
)

# 2. è·å–tushareæ•°æ®
basic = manager.get_data(
    endpoint_name="tushare.stock_basic",
    list_status="L",
    fields="ts_code,symbol,name,area,industry"
)

# 3. æœç´¢å¯ç”¨æ¥å£
available = manager.search_sources(
    category="DAILY_KLINE",
    status="active"
)

8. é«˜çº§ç‰¹æ€§
python

# æ•°æ®æºå¥åº·æ£€æŸ¥
class HealthChecker:
    def check_all(self):
        for name, source in self.registry.items():
            health = self._test_source(source)
            self._update_status(name, health)

    def _test_source(self, source):
        # ä½¿ç”¨æµ‹è¯•å‚æ•°éªŒè¯æ¥å£
        test_params = source['metadata'].get('test_parameters', {})
        try:
            data = source['handler'].fetch(**test_params)
            return {
                'status': 'healthy',
                'sample_data': data.head(1) if hasattr(data, 'head') else data
            }
        except Exception as e:
            return {'status': 'unhealthy', 'error': str(e)}

# æ™ºèƒ½è·¯ç”±
class SmartRouter:
    def get_best_source(self, data_category):
        """æ ¹æ®è´¨é‡è¯„åˆ†é€‰æ‹©æœ€ä¼˜æ•°æ®æº"""
        sources = self.db.query(
            "SELECT * FROM data_source_registry "
            "WHERE data_category = %s AND status = 'active' "
            "ORDER BY data_quality_score DESC, avg_response_time ASC",
            (data_category,)
        )
        return sources[0] if sources else None

ğŸ“ˆ å®æ–½å»ºè®®

    åˆ†é˜¶æ®µå®æ–½ï¼š

        ç¬¬ä¸€é˜¶æ®µï¼šå»ºç«‹æ³¨å†Œè¡¨å’ŒåŸºæœ¬ç®¡ç†å™¨

        ç¬¬äºŒé˜¶æ®µï¼šå®ç°ç»Ÿä¸€è°ƒç”¨æ¥å£

        ç¬¬ä¸‰é˜¶æ®µï¼šæ·»åŠ ç›‘æ§å’Œç®¡ç†ç•Œé¢

        ç¬¬å››é˜¶æ®µï¼šå®ç°æ™ºèƒ½è·¯ç”±å’Œæ•…éšœè½¬ç§»

    ç›‘æ§æŒ‡æ ‡ï¼š

        æ¥å£æˆåŠŸç‡

        å“åº”æ—¶é—´

        æ•°æ®æ–°é²œåº¦

        é¢åº¦ä½¿ç”¨ç‡

        å¼‚å¸¸é¢‘ç‡

    ç»´æŠ¤æµç¨‹ï¼š
    text

æ–°æ•°æ®æº â†’ æ³¨å†Œæµ‹è¯• â†’ è´¨é‡è¯„ä¼° â†’ ç”Ÿäº§ä½¿ç”¨ â†’ å®šæœŸå·¡æ£€ â†’ ä¸‹çº¿å½’æ¡£

è¿™ä¸ªæ–¹æ¡ˆå°†æ‚¨çš„æ•°æ®æºä»"æ•£è£…"å˜ä¸º"è´§æ¶å¼ç®¡ç†"ï¼Œæ¯ä¸ªæ¥å£éƒ½æœ‰å®Œæ•´çš„å…ƒæ•°æ®ã€ç›‘æ§å’Œæ–‡æ¡£ï¼Œå¤§å¤§é™ä½äº†ä½¿ç”¨å’Œç»´æŠ¤æˆæœ¬ã€‚
