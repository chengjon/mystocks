# 多CLI协作 Worktree 管理手册

**版本**: 2.0
**适用场景**: 任何使用Git Worktree进行多CLI并行协作的项目
**创建者**: Main CLI (Manager & Coordinator)
**创建时间**: 2025-12-28
**基于**: Git Worktree官方文档 + Phase 4/5/6实际协作经验

---

## 📚 目录

1. [概述](#概述)
2. [核心概念](#核心概念)
3. [角色定义](#角色定义)
4. [主CLI工作流程](#主cli工作流程)
5. [Worker CLI工作流程](#worker-cli工作流程)
6. [任务分配方法](#任务分配方法)
7. [权限管理](#权限管理)
8. [交互规则](#交互规则)
9. [任务管理工具](#任务管理工具)
10. [快速参考](#快速参考)

---

## 概述

### 适用场景

本手册适用于任何需要**多个CLI并行协作**的开发项目，特别是：

- **大型功能开发**: 单个功能模块太大，需要多个CLI同时工作
- **并行测试**: 同时执行多个独立的测试套件
- **文档与代码分离**: 一个CLI编写代码，另一个CLI同步编写文档
- **多系统验证**: 同时验证多个子系统或组件

### 核心价值

使用Git Worktree进行多CLI协作的优势：

1. **真正的并行开发**: 多个CLI同时工作，无需频繁切换分支
2. **隔离的工作环境**: 每个CLI有独立的工作目录，互不干扰
3. **共享Git历史**: 所有worktree共享对象数据库，节省空间
4. **灵活的权限管理**: 主CLI管理全局，Worker CLI管理本地
5. **清晰的职责边界**: 管理者 vs 执行者，避免责任混乱

### 前置要求

**技术要求**:
- Git版本 ≥ 2.17.0（支持worktree子命令）
- 所有CLI使用相同的Git仓库
- 每个CLI有独立的工作目录

**团队要求**:
- 明确的主CLI角色（唯一的管理者）
- 至少2个Worker CLI（并行执行者）
- 清晰的任务分配和验收标准

---

## 核心概念

### 什么是Git Worktree？

Git Worktree允许在**同一个仓库**中创建**多个独立的工作目录**，每个目录可以签出不同的分支。

**官方定义**: > "Git worktree allows you to have multiple working directories attached to the same repository."

**架构图**:
```
project_main/                        # 主仓库 (主 worktree)
├── .git/                           # Git 对象数据库 (共享)
│   ├── worktrees/                  # Worktree 元数据
│   │   ├── feature-auth/           # Worker CLI-1 的元数据
│   │   ├── feature-payment/        # Worker CLI-2 的元数据
│   │   └── feature-report/         # Worker CLI-3 的元数据
│   ├── refs/                       # 共享的引用 (分支/标签)
│   └── objects/                    # 共享的 Git 对象
├── src/                            # 主分支代码
└── ...

/opt/claude/project_feature_auth/   # Worker CLI-1 worktree
├── .git -> ../project_main/.git/worktrees/feature-auth
└── 认证功能开发代码

/opt/claude/project_feature_payment/ # Worker CLI-2 worktree
├── .git -> ../project_main/.git/worktrees/feature-payment
└── 支付功能开发代码
```

**共享 vs 独立**:
- **共享**: `refs/`, `objects/`（Git历史和引用）
- **独立**: `HEAD`, `index`, 工作目录文件（每个worktree有自己的状态）

### 协作模型

```
┌─────────────────────────────────────────────────────────────┐
│                    主CLI (Manager & Coordinator)            │
│                                                             │
│  职责:                                                      │
│  1. 任务规划与分配（Worktree管理、工作量估算）               │
│  2. 流程把控（进度监控、里程碑管理）                         │
│  3. 问题协调（跨worktree冲突、依赖解决）                     │
│  4. 集成管理（验证交付物、合并分支、生成报告）               │
│                                                             │
│  工作目录: <project_main> (main分支)                        │
│  权限范围: 全部worktree（读+写）                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ Worker CLI-1│  │ Worker CLI-2│  │ Worker CLI-3│  ...    │
│  │  认证功能   │  │  支付功能   │  │  报表功能   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│                                                             │
│  职责: 在各自worktree中独立完成任务                         │
│  权限范围: 本worktree（读+写），其他worktree（只读）       │
└─────────────────────────────────────────────────────────────┘
```

---

## 角色定义

### 主CLI (Manager & Coordinator)

**定位**: 多CLI协作的**唯一管理者和协调者**

**核心职责**:

1. **任务规划与分配**:
   - 将大任务拆分为可并行执行的子任务
   - 估算每个任务的工作量和时间
   - 为每个Worker CLI创建worktree和README
   - 确保任务工作量均衡，避免等待

2. **流程把控**:
   - 定期检查各Worker CLI的进度
   - 管理里程碑（T+Xh检查点）
   - 调整任务优先级（如果需要）
   - 生成进度报告

3. **问题协调**:
   - 解决跨worktree的冲突
   - 协调worktree间的依赖关系
   - 提供资源支持（Worker CLI无法独立解决的问题）

4. **集成管理**:
   - 验证所有Worker CLI的交付物
   - 合并所有分支到main
   - 生成完成报告
   - 清理worktree

**权限范围**:
- ✅ 全部worktree的读+写权限
- ✅ 创建、删除、移动worktree
- ✅ 合并分支到main
- ✅ 修改任何worktree的文件（仅在紧急情况下）

**不应该做的事** ❌:
- ❌ 代替Worker CLI执行具体任务
- ❌ 在Worker CLI未请求的情况下修改其代码
- ❌ 指定具体的技术实现方案
- ❌ 过度干预Worker CLI的工作方式

### Worker CLI (执行者)

**定位**: 专注领域的**独立执行者**

**核心职责**:

1. **独立执行**:
   - 在分配的worktree中独立完成任务
   - 自主选择技术实现方案
   - 管理本worktree的Git提交

2. **自主决策**:
   - 选择编程语言、框架、工具库
   - 决定代码风格和组织方式
   - 确定测试策略和覆盖率目标

3. **进度汇报**:
   - 定期更新README.md中的进度
   - 在关键节点（50%, 80%, 100%）汇报状态

4. **问题请示**:
   - 超出本worktree范围的问题及时请示主CLI
   - 例如：需要修改其他worktree的文件、需要调整任务优先级

**权限范围**:
- ✅ 本worktree的读+写权限
- ✅ 提交到分配的分支
- ✅ 创建本worktree内的文件和目录
- ⚠️ 其他worktree的只读权限（需要修改时必须请示主CLI）

**应该做的事** ✅:
- ✅ 独立完成任务，不依赖主CLI的具体指导
- ✅ 在README.md中记录工作进展和遇到的问题
- ✅ 遇到超出本worktree范围的问题时主动请示主CLI

**不应该做的事** ❌:
- ❌ 修改其他worktree的文件（未请示主CLI）
- ❌ 直接合并到main分支（必须通过主CLI）
- ❌ 修改主worktree的文件（未请示主CLI）
- ❌ 创建额外的worktree（这是主CLI的职责）

---

## 主CLI工作流程

### 完整流程概览

```
时间线（从T+0h开始）:

T+0h    ├─ 主CLI: 任务规划与worktree创建
        │   ├─ 分析任务，拆分为N个子任务
        │   ├─ 估算每个任务的工作量（小时）
        │   ├─ 创建N个worktree
        │   └─ 创建N个README任务文档
        │
        └─ Worker CLIs: 阅读README，理解任务

T+1h    ├─ Worker CLIs: 开始独立工作
        │   ├─ 各自在worktree中执行任务
        │   └─ 定期更新README进度
        │
T+Xh    ├─ 主CLI: 定期进度检查（每2小时）
        │   ├─ 检查所有worktree状态
        │   ├─ 统计修改文件数量
        │   └─ 生成进度报告
        │
T+完成  ├─ Worker CLIs: 完成任务并提交
        │   ├─ 验证验收标准
        │   └─ 提交到分配的分支
        │
T+集成  ├─ 主CLI: 验证与集成
        │   ├─ 验证所有交付物
        │   ├─ 合并所有分支到main
        │   └─ 生成完成报告
        │
T+清理  └─ 主CLI: 清理worktree
            └─ 删除所有worktree
```

### 阶段1: 任务规划与worktree创建 (T+0h)

#### 步骤1.1: 任务分析与拆分

**目标**: 将大任务拆分为可并行执行的子任务

**要求**:
- 每个子任务**独立**，不依赖其他子任务
- 每个子任务有**清晰的验收标准**
- 每个子任务有**可估算的工作量**

**产出物**: 任务拆分文档（可以是文本或markdown）

**示例**:
```markdown
# 多CLI协作任务拆分

## 原始任务
开发用户认证系统和支付系统

## 拆分方案

### 子任务1: 用户认证系统
- Worker: CLI-1
- 工作量: 6小时
- 优先级: 高
- 独立性: 完全独立，不依赖其他子任务

### 子任务2: 支付系统
- Worker: CLI-2
- 工作量: 8小时
- 优先级: 高
- 独立性: 完全独立，不依赖其他子任务

## 工作量平衡分析
- CLI-1: 6小时
- CLI-2: 8小时
- 差异: 2小时（可接受，CLI-2完成后等待2小时）

## 建议
考虑到工作量差异，可以让CLI-1在完成后协助CLI-2进行测试
```

#### 步骤1.2: 工作量估算

**目标**: 估算每个子任务的工作量，确保任务分配合理

**要求**:
- 使用**小时**作为单位（精确到0.5小时）
- 考虑以下因素：
  - 代码编写时间
  - 测试时间
  - 文档编写时间
  - 调试和修复时间（增加20%缓冲）
- 如果工作量差异>3小时，需要重新调整或分配辅助任务

**产出物**: 工作量估算表

**示例**:
```markdown
# 工作量估算表

| 子任务 | 代码编写 | 测试 | 文档 | 调试缓冲 | 总计 | 分配给 |
|--------|---------|------|------|---------|------|--------|
| 认证系统 | 3h | 1h | 0.5h | 1h | 5.5h | CLI-1 |
| 支付系统 | 4h | 1.5h | 1h | 1.5h | 8h | CLI-2 |
| 报表系统 | 2h | 0.5h | 0.5h | 0.5h | 3.5h | CLI-3 |

**总计**: 17小时
**并行时间**: 8小时（以最长的任务为准）
**效率提升**: 17h → 8h（2.125x加速比）
```

#### 步骤1.3: 创建worktree（使用Git命令）

**目标**: 为每个Worker CLI创建独立的worktree

**使用Git命令**: `git worktree add`

**详细步骤**:

```bash
# ============================================
# 步骤1.3.1: 确保主分支是最新的
# ============================================
cd <project_main>
git checkout main
git pull origin main

# 产出物: 主分支更新到最新版本
# 验证: git log --oneline -1

# ============================================
# 步骤1.3.2: 创建第一个worktree
# ============================================
# 语法: git worktree add <路径> <分支名>

# 示例1: 从新分支创建worktree
git worktree add /opt/claude/project_feature_auth feature-auth-system

# 产出物:
# - 新目录: /opt/claude/project_feature_auth
# - 新分支: feature-auth-system
# - .git文件: 指向主仓库的worktrees元数据

# 验证:
ls -la /opt/claude/project_feature_auth/.git
# 输出: lrwxrwxrwx 1 root root 50 Dec 28 12:00 .git -> ../project_main/.git/worktrees/feature-auth-system

# ============================================
# 步骤1.3.3: 创建第二个worktree
# ============================================
git worktree add /opt/claude/project_feature_payment feature-payment-system

# 产出物:
# - 新目录: /opt/claude/project_feature_payment
# - 新分支: feature-payment-system

# ============================================
# 步骤1.3.4: 创建更多worktree（重复命令）
# ============================================
git worktree add /opt/claude/project_feature_report feature-report-system

# ============================================
# 步骤1.3.5: 验证所有worktree创建成功
# ============================================
git worktree list

# 期望输出:
# /opt/claude/project_main            abcd1234 [main]
# /opt/claude/project_feature_auth    5678abcd [feature-auth-system]
# /opt/claude/project_feature_payment 1234ef56 [feature-payment-system]
# /opt/claude/project_feature_report  9f0e1a2b [feature-report-system]

# ============================================
# 步骤1.3.6: 在每个worktree中创建.gitignore（如果需要）
# ============================================
# 如果某些worktree需要特定的忽略规则，可以创建.gitignore
# 注意: 大多数情况下，主仓库的.gitignore已经足够

# 示例: 为测试worktree添加本地配置忽略
cat > /opt/claude/project_feature_payment/.gitignore.worktree <<EOF
# 本地测试配置
.env.local
*.log
test-results/
EOF
```

**Git命令速查**:
```bash
# 创建新分支并签出
git worktree add -b <分支名> <路径>

# 从现有分支创建worktree
git worktree add <路径> <分支名>

# 从指定起点创建worktree
git worktree add <路径> <分支名> <起点>

# 创建分离式HEAD（用于实验）
git worktree add --detach <路径>
```

#### 步骤1.4: 创建README任务文档

**目标**: 为每个Worker CLI创建清晰的任务说明

**要求**:
- README必须放在worktree的根目录
- 文件名必须是`README.md`
- 包含任务目标、验收标准、预计时间、优先级

**产出物**: 每个worktree根目录的README.md

**README模板**:
```markdown
# <项目名称> - <任务名称>

## 任务目标
[清晰描述任务目标，1-2句话]

## 背景
[为什么需要这个任务，解决了什么问题]

## 验收标准
- [ ] 标准1: [具体描述]
- [ ] 标准2: [具体描述]
- [ ] 标准3: [具体描述]

## 工作范围
### 本worktree范围内
- ✅ [可以做的事情1]
- ✅ [可以做的事情2]

### 超出本worktree范围（需要请示主CLI）
- ⚠️ [需要协调的事情1]
- ⚠️ [需要协调的事情2]

## 优先级
- 🔴 高（最高优先级，如果发现和其他任务重叠/冲突，以本worktree任务为主要方向）
- 🟡 中
- 🟢 低

## 预计工作量
- 总计: X小时
- 代码编写: X小时
- 测试: X小时
- 文档: X小时

## 预计完成时间
T+Xh（从现在开始计算）

## 任务管理工具
- OpenSpec: `openspec proposal create <name>`
- TaskMaster: `task-master list`
- (根据项目选择使用的工具)

## 技术建议（可选）
[推荐的技术栈、工具库，但Worker CLI可以自主决策]

## 问题请示流程
如果遇到以下情况，请向主CLI请示：
1. 需要修改其他worktree的文件
2. 需要调整任务优先级
3. 需要额外的资源或协助
4. 发现无法独立解决的技术问题

## 进度更新
### T+0h（任务开始）
- 状态: 任务理解中
- 进度: 0%

### T+Xh（自行更新）
- 状态: [进行中/阻塞/完成]
- 进度: X%
- 完成项:
  - ✅ [已完成的工作]
- 进行项:
  - 🔄 [正在进行的工作]
- 待开始:
  - ⏳ [待开始的工作]
- 遇到的问题:
  - ⚠️ [如果有阻塞问题，在此记录]

## 完成报告（任务完成后填写）
### 完成时间
YYYY-MM-DD HH:MM

### 完成情况
- ✅ 验收标准1: [具体描述完成情况]
- ✅ 验收标准2: [具体描述完成情况]
- ⚠️  验收标准3: [如果未完全完成，说明原因]

### 交付物
1. [文件/目录路径]
2. [文件/目录路径]
3. [报告路径]

### 测试结果
- 测试通过率: X%
- 性能指标: [达标/未达标]

### 问题记录
[记录遇到的问题和解决方案]

### Git提交
- 分支: <分支名>
- 提交SHA: <commit hash>
- 提交消息: [简要描述]

---

**任务分配信息**
- 分配给: Worker CLI-X
- 分配时间: YYYY-MM-DD HH:MM
- 主CLI: [主CLI名称]
- 项目: <项目名称>
```

**README示例**（实际项目）:
```markdown
# MyStocks项目 - Phase 4 测试修复

## 任务目标
修复所有失败的单元测试和集成测试，确保测试通过率达到100%

## 背景
Phase 4开发引入了新的数据访问层，导致48个测试失败。需要修复这些测试以验证新架构的正确性。

## 验收标准
- [ ] 所有单元测试通过（目标: 100%通过率）
- [ ] 所有集成测试通过（目标: 100%通过率）
- [ ] 测试覆盖率 > 80%
- [ ] 生成测试报告

## 工作范围
### 本worktree范围内
- ✅ 修改测试文件
- ✅ 修复测试代码中的bug
- ✅ 调整测试配置
- ✅ 生成测试报告

### 超出本worktree范围（需要请示主CLI）
- ⚠️ 修改源代码（如果测试失败是因为源代码bug）
- ⚠️ 修改测试框架配置
- ⚠️ 添加新的测试依赖

## 优先级
- 🔴 高（最高优先级，Phase 4的阻塞问题）

## 预计工作量
- 总计: 8小时
- 分析测试失败原因: 2小时
- 修复测试代码: 4小时
- 运行完整测试套件: 1小时
- 生成测试报告: 1小时

## 预计完成时间
T+8h（从现在开始计算）

## 任务管理工具
- TaskMaster: `task-master list`（查看所有测试任务）
- TaskMaster: `task-master show <id>`（查看具体测试任务）

## 问题请示流程
如果遇到以下情况，请向主CLI请示：
1. 测试失败是因为源代码bug（需要修改源代码）
2. 需要调整测试框架配置
3. 发现架构设计问题（需要主CLI协调）

## 进度更新
### T+0h（任务开始）
- 状态: 任务理解中
- 进度: 0%

---

**任务分配信息**
- 分配给: Worker CLI-2
- 分配时间: 2025-12-28 12:00
- 主CLI: Claude Code (Manager)
- 项目: MyStocks Phase 4
- 分支: phase4-test-fixes
```

### 阶段2: 进度监控 (T+0h → T+完成)

#### 步骤2.1: 定期检查worktree状态

**频率**: 每1-2小时检查一次

**使用Git命令**: `git worktree list`, `git status`, `git log`

**详细步骤**:

```bash
# ============================================
# 步骤2.1.1: 检查所有worktree列表
# ============================================
cd <project_main>
git worktree list

# 产出物: 所有worktree的状态列表
# 示例输出:
# /opt/claude/project_main            abcd1234 [main]
# /opt/claude/project_feature_auth    5678abcd [feature-auth-system]
# /opt/claude/project_feature_payment 1234ef56 [feature-payment-system]

# ============================================
# 步骤2.1.2: 检查每个worktree的Git状态
# ============================================
for worktree in /opt/claude/project_feature_*; do
    echo "=== $worktree ==="
    cd "$worktree"

    # 检查未提交的修改
    git status --short | wc -l

    # 检查最新提交
    git log --oneline -3

    cd -
done

# 产出物: 每个worktree的
# - 未提交文件数量（评估活跃度）
# - 最新3次提交（评估进展）

# ============================================
# 步骤2.1.3: 检查README进度更新
# ============================================
for worktree in /opt/claude/project_feature_*; do
    echo "=== $worktree README进度 ==="
    tail -n 30 "$worktree/README.md" | grep -A 10 "进度更新"
done

# 产出物: 每个worktree的最新进度更新
```

**监控指标**:
| 指标 | 测量方法 | 用途 |
|------|---------|------|
| 文件修改数量 | `git status --short \| wc -l` | 评估工作活跃度 |
| 提交频率 | `git log --oneline --since="2 hours ago" \| wc -l` | 评估工作进展 |
| README更新 | `tail -n 30 README.md` | 了解Worker CLI的自我汇报 |
| 分支状态 | `git branch -vv` | 确认worktree在正确的分支 |

#### 步骤2.2: 生成进度报告

**频率**: 每2小时生成一次

**产出物**: 进度报告markdown文件

**报告模板**:
```markdown
# 多CLI协作进度报告（第N小时）

**生成时间**: YYYY-MM-DD HH:MM
**报告人**: 主CLI
**当前阶段**: T+Xh状态检查

---

## 📊 总体进度概览

### 完成率
- **已完成**: X/N 个Worker CLI（X%）
- **进行中**: Y/N 个Worker CLI（Y%）
- **未开始**: Z/N 个Worker CLI（Z%）
- **总体进度**: ~W%（加权平均，考虑工作量）

### 时间线状态
```
T+0h    ✅ 基础设施准备完成（所有worktree创建）
T+2h    🔄 第一个进度检查点
T+4h    ⏳ 第二个进度检查点
T+6h    ⏳ 第三个进度检查点
T+完成  ⏳ 所有Worker CLI预计完成
T+集成  ⏳ 主CLI验证和集成
```

---

## 🔄 Worker CLI 当前状态

### ✅ Worker CLI-1: <任务名称>

**状态**: 已完成 / 进行中 / 阻塞
**完成时间**: T+Xh（提前/延迟X小时）
**分支**: `<分支名>`
**最新提交**: `<commit-sha> - <commit-message>`

**核心成果**:
- ✅ [成果1]
- ✅ [成果2]
- ✅ [成果3]

**当前工作证据** (X个文件已修改):
```
修改文件统计:
- [模块名]: [文件列表]
- [模块名]: [文件列表]
```

**进度评估**: [基于修改文件数量和提交频率，评估是否按计划进行]

---

### 🔄 Worker CLI-2: <任务名称>

**状态**: 进行中 (~X% 进度)
**预计完成**: T+Xh
**分支**: `<分支名>`

**当前工作证据** (X个文件已修改):
```
修改文件统计:
- [模块名]: [文件列表]
- [模块名]: [文件列表]
```

**任务清单**:
1. [ ] [子任务1]
2. [ ] [子任务2]
3. [ ] [子任务3]

**进度评估**: [基于修改文件数量和类型，评估是否按计划]

---

### ⚠️ Worker CLI-3: <任务名称>

**状态**: 阻塞中 (~X% 进度)

**阻塞问题**:
- 🔴 **[问题描述]**
- 🔴 **[问题描述]**

**当前工作证据** (X个文件已修改):
```
修改文件统计:
- [模块名]: [文件列表]
```

**任务清单**:
1. ⚠️ **[阻塞问题]** - [影响描述]
   - [问题描述]
   - [建议解决方案]
   - [需要主CLI协助]

2. [ ] [子任务2]（等待阻塞解决）

**风险提示**: [如果阻塞问题不能快速解决，可能影响完成时间]

---

## 🎯 下一阶段行动计划

### 立即行动 (T+Xh → T+Yh)

**主CLI任务**:
1. ✅ **生成当前进度报告** - 已完成
2. 🔍 **持续监控Worker CLI进度** - [具体行动]
3. 🚨 **支持阻塞的Worker CLI** - [具体行动]

**Worker CLI-1**:
- [继续当前工作]

**Worker CLI-2**:
- [继续当前工作]

**Worker CLI-3**:
- **关键路径**: 立即解决阻塞问题
- [具体建议]

---

## ⚠️ 风险和问题

### 当前风险

1. **[Worker CLI-X] - [风险类型]** 🔴
   - **问题**: [问题描述]
   - **影响**: [对整体进度的影响]
   - **建议**: [缓解措施]
   - **状态**: [跟踪状态]

### 已解决问题

1. ✅ **[问题描述]** - [如何解决]

---

## 📈 成功指标

| 指标 | 目标 | 当前状态 | 达成率 |
|------|------|----------|--------|
| **任务完成率** | N/N | X/N | X% |
| [指标2] | [目标值] | [当前值] | X% |
| [指标3] | [目标值] | [当前值] | X% |

---

## 🚀 关键成就

1. **[成就1]**: [描述]
2. **[成就2]**: [描述]
3. **[成就3]**: [描述]

---

**下次更新**: T+Yh（约X小时后）- [下一个里程碑]

**备注**: [任何需要记录的备注]

---

**生成时间**: YYYY-MM-DD HH:MM
**报告版本**: vX（T+Xh状态检查）
**主CLI**: [主CLI名称]
```

### 阶段3: 问题协调（响应式）

#### 步骤3.1: 识别问题

**触发条件**:
1. Worker CLI通过README更新报告问题
2. 定期检查发现异常（长时间无提交、大量文件未提交）
3. Worker CLI主动请示

**问题级别定义**:

| 级别 | 定义 | 示例 | 主CLI响应时间 |
|------|------|------|--------------|
| 🟢 信息级 | 不影响工作的小问题 | 代码风格建议、文档不完整 | 下次定期检查 |
| 🟡 警告级 | 可能影响进度 | 依赖版本冲突、测试偶尔失败 | 4小时内 |
| 🔴 阻塞级 | 完全无法继续工作 | 服务启动失败、测试环境崩溃、跨worktree冲突 | 立即（1小时内） |

#### 步骤3.2: 分析问题

**目标**: 确定问题的根本原因和影响范围

**详细步骤**:

```bash
# ============================================
# 步骤3.2.1: 收集问题信息
# ============================================

# 从Worker CLI的README中读取问题报告
cd /opt/claude/project_<worktree>
tail -n 50 README.md | grep -A 20 "遇到的问题"

# 产出物: 问题描述、已尝试的解决方案、请求的协助

# ============================================
# 步骤3.2.2: 检查相关worktree状态
# ============================================

# 如果问题涉及多个worktree，检查所有相关worktree
git worktree list

# 检查冲突的文件
git diff --name-only <branch1> <branch2>

# 产出物: 受影响的worktree列表、冲突文件列表

# ============================================
# 步骤3.2.3: 评估问题严重程度
# ============================================

# 根据问题级别定义，评估严重程度
# 产出物: 问题级别（🟢/🟡/🔴）
```

#### 步骤3.3: 提供解决方案

**目标**: 为Worker CLI提供清晰的解决方案

**详细步骤**:

```bash
# ============================================
# 步骤3.3.1: 制定解决方案
# ============================================

# 根据问题类型，制定解决方案
# 产出物: 解决方案文档

# ============================================
# 步骤3.3.2: 记录到进度报告
# ============================================

# 在当前的进度报告中添加问题记录
cat >> /tmp/progress_report_T+Xh.md <<EOF

## 紧急问题处理

### 问题
[问题标题]

### 级别
🔴 阻塞级

### 影响
[影响描述]

### 解决方案
[具体解决方案]

### 执行步骤
1. [步骤1]
2. [步骤2]
3. [步骤3]

### 下一步
[Worker CLI需要执行的操作]
EOF

# 产出物: 更新的进度报告
```

**解决方案文档模板**:
```markdown
# <Worker CLI-X> 问题解决方案

## 问题
[清晰的标题]

## 级别
🔴 阻塞级 / 🟡 警告级 / 🟢 信息级

## 问题描述
[详细描述问题]

## 根因分析
[分析问题的根本原因]

## 解决方案
[具体的解决方案]

## 执行步骤
1. **步骤1**: [具体操作]
   ```bash
   [命令或操作]
   ```
   产出物: [期望的结果]

2. **步骤2**: [具体操作]
   ```bash
   [命令或操作]
   ```
   产出物: [期望的结果]

3. **步骤3**: [具体操作]
   产出物: [期望的结果]

## 验证方法
[如何验证问题已解决]

## 注意事项
[需要注意的事项]

## 下一步
Worker CLI: [具体需要执行的操作]
主CLI: [是否需要持续跟踪]
```

### 阶段4: 集成管理 (T+完成)

#### 步骤4.1: 验证所有Worker CLI完成

**目标**: 确保所有Worker CLI都已完成并满足验收标准

**详细步骤**:

```bash
# ============================================
# 步骤4.1.1: 检查所有worktree的分支状态
# ============================================
cd <project_main>
git branch -vv

# 期望输出: 所有分支都有最新的提交
# 示例:
# feature-auth-system       abcd1234 [origin/feature-auth-system] 认证系统完成
# feature-payment-system     5678abcd [origin/feature-payment-system] 支付系统完成

# 产出物: 所有分支的状态列表

# ============================================
# 步骤4.1.2: 验证每个Worker CLI的交付物
# ============================================

# 为每个Worker CLI运行验证脚本
for worktree in /opt/claude/project_feature_*; do
    echo "=== 验证 $worktree ==="

    # 1. 检查README是否标记为完成
    grep -q "任务完成" "$worktree/README.md" && echo "✅ README已标记完成" || echo "❌ README未标记完成"

    # 2. 检查是否有完成报告
    ls -lh "$worktree/COMPLETION_REPORT.md" && echo "✅ 有完成报告" || echo "❌ 缺少完成报告"

    # 3. 检查是否有其他交付物（根据README中的验收标准）
    # ...
done

# 产出物: 验证结果清单

# ============================================
# 步骤4.1.3: 生成验证报告
# ============================================

cat > /tmp/verification_report.md <<EOF
# Worker CLI交付物验证报告

## 验证时间
YYYY-MM-DD HH:MM

## 验证结果

### Worker CLI-1: <任务名称>
- ✅ README已标记完成
- ✅ 完成报告存在
- ✅ 验收标准1: 已满足
- ✅ 验收标准2: 已满足
- ✅ Git提交成功
**结论**: 通过验证

### Worker CLI-2: <任务名称>
- ✅ README已标记完成
- ✅ 完成报告存在
- ⚠️  验收标准1: 部分满足（说明原因）
- ✅ 验收标准2: 已满足
- ✅ Git提交成功
**结论**: 有条件通过（需要后续跟进）

## 遗留问题
[记录任何遗留问题或需要后续跟进的事项]

## 下一步
[是否可以进行集成]
EOF

# 产出物: 验证报告
```

**验证清单模板**:
```markdown
# Worker CLI交付物验证清单

## Worker CLI-1: <任务名称>

### 基本检查
- [ ] README.md 存在
- [ ] README标记为"任务完成"
- [ ] COMPLETION_REPORT.md 存在

### 验收标准检查
- [ ] 验收标准1: [具体描述] - [通过/不通过]
- [ ] 验收标准2: [具体描述] - [通过/不通过]
- [ ] 验收标准3: [具体描述] - [通过/不通过]

### Git检查
- [ ] 分支有最新提交
- [ ] 提交信息清晰
- [ ] 无未提交的修改
- [ ] 已推送到远程（如果需要）

### 交付物检查
- [ ] [交付物1] - [路径]
- [ ] [交付物2] - [路径]
- [ ] [交付物3] - [路径]

### 测试检查（如果适用）
- [ ] 测试通过率 ≥ 100%
- [ ] 测试覆盖率 ≥ 目标值
- [ ] 性能指标达标

**结论**: [通过/不通过/有条件通过]
**备注**: [任何需要注意的事项]
```

#### 步骤4.2: 合并所有分支到main

**使用Git命令**: `git merge`

**详细步骤**:

```bash
# ============================================
# 步骤4.2.1: 切换到main分支
# ============================================
cd <project_main>
git checkout main

# 产出物: 当前在main分支

# ============================================
# 步骤4.2.2: 确保main分支是最新的
# ============================================
git pull origin main

# 产出物: main分支更新到最新版本

# ============================================
# 步骤4.2.3: 按顺序合并每个分支
# ============================================

# 合并第一个分支
git merge feature-auth-system --no-ff -m "Merge feature-auth-system: 完成用户认证系统

- 实现JWT认证
- 添加用户注册/登录API
- 完成单元测试和集成测试

🤖 Generated with Claude Code
Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# 产出物: 第一个分支合并完成

# 合并第二个分支
git merge feature-payment-system --no-ff -m "Merge feature-payment-system: 完成支付系统

- 实现支付接口集成
- 添加支付回调处理
- 完成支付测试

🤖 Generated with Claude Code
Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# 产出物: 第二个分支合并完成

# ... 合并其他分支

# ============================================
# 步骤4.2.4: 解决合并冲突（如果有）
# ============================================

# Git会提示冲突文件
# 示例:
# Auto-merging src/config.py
# CONFLICT (content): Merge conflict in src/config.py
# Automatic merge failed; fix conflicts and then commit the result.

# 解决冲突步骤:
# 1. 打开冲突文件
vim src/config.py

# 2. 找到冲突标记
# <<<<<<< HEAD
# 当前分支的代码
# =======
# 被合并分支的代码
# >>>>>>> feature-auth-system

# 3. 手动合并代码，保留两个分支的修改
# 4. 删除冲突标记
# 5. 保存文件

# 6. 标记冲突已解决
git add src/config.py

# 7. 完成合并
git commit

# 产出物: 所有分支成功合并到main

# ============================================
# 步骤4.2.5: 推送到远程
# ============================================
git push origin main

# 产出物: 所有合并推送到远程仓库
```

**重要说明**:
- 使用 `--no-ff` 参数保留分支历史
- 如果有冲突，尽量保留两个分支的修改
- 合并提交信息要清晰描述合并的内容

#### 步骤4.3: 清理所有worktree

**使用Git命令**: `git worktree remove`

**详细步骤**:

```bash
# ============================================
# 步骤4.3.1: 列出所有worktree
# ============================================
cd <project_main>
git worktree list

# 产出物: 所有worktree列表

# ============================================
# 步骤4.3.2: 删除每个worktree
# ============================================

# 删除第一个worktree
git worktree remove /opt/claude/project_feature_auth

# 产出物: 第一个worktree已删除

# 删除第二个worktree
git worktree remove /opt/claude/project_feature_payment

# 产出物: 第二个worktree已删除

# ... 删除其他worktree

# ============================================
# 步骤4.3.3: 验证所有worktree已删除
# ============================================
git worktree list

# 期望输出: 只有主worktree
# /opt/claude/project_main    abcd1234 [main]

# ============================================
# 步骤4.3.4: 清理元数据（可选）
# ============================================
# 清理过期的worktree元数据
git worktree prune

# 产出物: 元数据已清理
```

**重要说明**:
- 删除worktree前，确保所有分支已成功合并
- 删除worktree不会删除分支（分支仍然存在于Git中）
- 如果worktree有未提交的修改，使用 `-f` 或 `--force` 强制删除

#### 步骤4.4: 生成完成报告

**目标**: 总结整个多CLI协作的成果

**产出物**: 完成报告markdown文件

**报告模板**:
```markdown
# 多CLI协作完成报告

**项目**: <项目名称>
**完成时间**: YYYY-MM-DD HH:MM
**主CLI**: [主CLI名称]
**协作模式**: Git Worktree多CLI并行协作

---

## 📊 总体成果

### 完成情况
- **Worker CLI数量**: N个
- **总工作量**: X小时
- **实际时间**: Y小时
- **效率提升**: X/Y = Zx加速比

### 任务完成率
- **按时完成**: N个（X%）
- **提前完成**: N个（Y%）
- **延迟完成**: N个（Z%）

---

## ✅ 各Worker CLI成果

### Worker CLI-1: <任务名称>

**分配时间**: YYYY-MM-DD HH:MM
**完成时间**: YYYY-MM-DD HH:MM
**实际用时**: X小时（预计Y小时，提前/延迟Z小时）

**核心成果**:
- ✅ [成果1]
- ✅ [成果2]
- ✅ [成果3]

**交付物**:
- [文件/目录路径]
- [文件/目录路径]
- [报告路径]

**验收标准**:
- ✅ 标准1: [满足情况]
- ✅ 标准2: [满足情况]
- ⚠️  标准3: [部分满足，说明原因]

**Git提交**:
- 分支: <分支名>
- 提交数: X个
- 最新提交: <commit-sha>

---

### Worker CLI-2: <任务名称>

[同上格式]

---

## 📈 性能指标

| 指标 | 目标 | 实际 | 达成率 |
|------|------|------|--------|
| [指标1] | [目标值] | [实际值] | X% |
| [指标2] | [目标值] | [实际值] | Y% |
| [指标3] | [目标值] | [实际值] | Z% |

---

## 🎓 经验总结

### 成功经验
1. **[经验1]**: [描述]
2. **[经验2]**: [描述]
3. **[经验3]**: [描述]

### 改进建议
1. **[建议1]**: [描述]
2. **[建议2]**: [描述]
3. **[建议3]**: [描述]

### 遇到的问题
1. **[问题1]**: [描述] → [解决方案]
2. **[问题2]**: [描述] → [解决方案]
3. **[问题3]**: [描述] → [解决方案]

---

## 🔧 技术栈和工具

### 使用的Git命令
- `git worktree add` - 创建worktree
- `git worktree list` - 列出worktree
- `git worktree remove` - 删除worktree
- `git merge --no-ff` - 合并分支

### 任务管理工具
- [OpenSpec / TaskMaster / 其他]

### 协作模式
- [描述协作模式的特点]

---

## 📝 附录

### Git分支历史
\`\`\`
$ git log --oneline --graph --all -15
* abcd123 (HEAD -> main) Merge feature-report-system: 完成报表系统
|\
| * 5678bcd (feature-report-system) 完成报表系统
| * 1234abc 报表模板创建
|
* 9f0e1a2 Merge feature-payment-system: 完成支付系统
|\
| * 8b33d71 (feature-payment-system) 完成支付系统
| * 4a5b6c7 支付接口集成
|
* 2df09f1 Merge feature-auth-system: 完成认证系统
|\
| * 1a2b3c4 (feature-auth-system) 完成认证系统
* 3d4e5f6 初始提交
\`\`\`

### Worktree创建记录
| Worktree | 分支 | 创建时间 | 删除时间 | 存续时间 |
|----------|------|----------|----------|----------|
| /opt/claude/project_feature_auth | feature-auth-system | YYYY-MM-DD HH:MM | YYYY-MM-DD HH:MM | X小时 |
| /opt/claude/project_feature_payment | feature-payment-system | YYYY-MM-DD HH:MM | YYYY-MM-DD HH:MM | Y小时 |

---

**报告生成时间**: YYYY-MM-DD HH:MM
**报告版本**: v1.0
**主CLI**: [主CLI名称]
**项目**: <项目名称>
```

---

## Worker CLI工作流程

### 完整流程概览

```
时间线（从T+0h开始）:

T+0h    ├─ 阅读README，理解任务
        ├─ 确认验收标准
        └─ 规划工作方式

T+0.5h  ├─ 开始独立执行任务
        │   ├─ 选择技术方案
        │   ├─ 编写代码/测试/文档
        │   └─ 定期Git提交

T+Xh    ├─ 定期更新README进度
        │   ├─ 每完成一个子任务更新一次
        │   ├─ 标记当前状态（进行中/阻塞）
        └─ 遇到问题时请示主CLI

T+完成  ├─ 验证所有验收标准
        ├─ 生成完成报告
        ├─ Git提交
        └─ 通知主CLI
```

### 阶段1: 任务理解 (T+0h)

#### 步骤1.1: 阅读README

**目标**: 充分理解任务目标和验收标准

**详细步骤**:

```bash
# ============================================
# 步骤1.1.1: 定位worktree目录
# ============================================
cd <worktree_path>

# 示例:
cd /opt/claude/project_feature_auth

# ============================================
# 步骤1.1.2: 阅读README
# ============================================
cat README.md

# 产出物: 理解任务目标、验收标准、优先级、工作量

# ============================================
# 步骤1.1.3: 检查验收标准是否清晰
# ============================================

# 检查清单:
- [ ] 任务目标清晰吗？
- [ ] 验收标准具体吗？（可以量化验证）
- [ ] 工作范围明确吗？
- [ ] 预计完成时间合理吗？

# 如果有任何一项为"否"，需要联系主CLI

# ============================================
# 步骤1.1.4: 记录任务理解
# ============================================

# 在README中添加"任务理解"部分
cat >> README.md <<EOF

## 任务理解确认

### 我的理解
- 任务目标: [用我自己的话描述任务目标]
- 核心交付: [列出核心交付物]
- 验收要点: [列出关键的验收要点]

### 我的计划
- 技术方案: [初步计划使用的技术]
- 工作步骤: [计划的执行步骤]
- 风险评估: [可能遇到的风险]

确认时间: YYYY-MM-DD HH:MM
EOF

# 产出物: README中的"任务理解确认"部分
```

#### 步骤1.2: 规划工作方式

**目标**: 制定工作计划，选择技术方案

**详细步骤**:

```bash
# ============================================
# 步骤1.2.1: 分析工作范围
# ============================================

# 列出本worktree范围内可以做的事情
# 列出超出范围需要请示主CLI的事情

# ============================================
# 步骤1.2.2: 选择技术方案
# ============================================

# 选择编程语言、框架、工具库
# 选择测试框架
# 选择代码风格和组织方式

# 产出物: 技术方案（不需要请示主CLI）

# ============================================
# 步骤1.2.3: 制定工作步骤
# ============================================

# 将任务拆分为更小的步骤
# 估算每个步骤的时间
# 标记步骤之间的依赖关系

# 产出物: 工作步骤清单

# ============================================
# 步骤1.2.4: 更新README
# ============================================

cat >> README.md <<EOF

## 工作计划

### 技术方案
- 框架: [选择的框架]
- 语言: [选择的语言版本]
- 工具库: [主要工具库]

### 工作步骤
1. [步骤1] - 预计X小时
2. [步骤2] - 预计Y小时
3. [步骤3] - 预计Z小时

### 里程碑
- T+Xh: 完成步骤1
- T+Yh: 完成步骤2
- T+Zh: 完成步骤3（预计完成）

计划制定时间: YYYY-MM-DD HH:MM
EOF

# 产出物: README中的"工作计划"部分
```

### 阶段2: 独立执行 (T+0h → T+完成)

#### 步骤2.1: 执行工作

**目标**: 在worktree中独立完成任务

**详细步骤**:

```bash
# ============================================
# 步骤2.1.1: 开始工作
# ============================================
cd <worktree_path>

# ============================================
# 步骤2.1.2: 执行第一个步骤
# ============================================

# 示例: 编写代码
vim src/auth.py

# 示例: 编写测试
vim tests/test_auth.py

# 示例: 运行测试
pytest tests/

# ============================================
# 步骤2.1.3: 定期Git提交
# ============================================

# 每完成一个小功能就提交
git add .
git commit -m "feat: 实现用户登录功能

- 添加登录API端点
- 实现JWT token生成
- 添加登录验证逻辑

🤖 Generated with Claude Code
Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# 产出物: Git提交记录

# ============================================
# 步骤2.1.4: 继续执行其他步骤
# ============================================

# 重复步骤2.1.2 - 2.1.3，直到所有步骤完成
```

**关键点**:
- ✅ 自主选择技术方案
- ✅ 频繁提交（每完成一个小功能）
- ✅ 清晰的提交信息
- ❌ 不要修改其他worktree的文件

#### 步骤2.2: 定期更新进度

**目标**: 让主CLI了解工作进展

**详细步骤**:

```bash
# ============================================
# 步骤2.2.1: 完成一个子任务后更新README
# ============================================

# 示例: 完成步骤1
cat >> README.md <<EOF

### T+2h（进度更新）
- 状态: 进行中
- 进度: 25%
- 完成项:
  - ✅ 实现用户注册功能
  - ✅ 实现用户登录功能
- 进行项:
  - 🔄 实现密码重置功能
- 待开始:
  - ⏳ 编写单元测试
  - ⏳ 编写集成测试
- 遇到的问题:
  - 无

EOF

# ============================================
# 步骤2.2.2: 遇到问题时更新README
# ============================================

# 示例: 遇到阻塞问题
cat >> README.md <<EOF

### T+4h（遇到阻塞问题）
- 状态: 阻塞
- 进度: 50%
- 遇到的问题:
  - 🔴 **问题**: 密码重置功能需要发送邮件，但邮件服务配置在主worktree中
  - **已尝试**: 尝试在本地worktree配置邮件服务，但缺少SMTP密钥
  - **影响**: 无法完成密码重置功能测试
  - **请求帮助**: 需要主CLI提供SMTP配置或允许访问主worktree的配置文件

EOF

# ============================================
# 步骤2.2.3: Git提交README更新
# ============================================
git add README.md
git commit -m "docs: 更新进度到T+4h，遇到阻塞问题"
```

**更新频率建议**:
- 每完成一个子任务（25%, 50%, 75%, 100%）
- 遇到问题时立即更新
- 每小时至少更新一次（即使进展很小）

#### 步骤2.3: 请示主CLI（如果需要）

**目标**: 获取超出本worktree范围的协助

**触发条件**:
1. 需要修改其他worktree的文件
2. 需要主CLI提供资源（配置、密钥等）
3. 需要调整任务优先级
4. 发现无法独立解决的技术问题

**请示格式**:
```markdown
## 请示主CLI协助

**时间**: YYYY-MM-DD HH:MM
**级别**: 🔴 阻塞级 / 🟡 警告级 / 🟢 信息级

### 问题描述
[清晰描述问题]

### 影响范围
- 本worktree: [影响描述]
- 其他worktree: [如果影响其他worktree]
- 整体进度: [对整体进度的影响]

### 已尝试的解决方案
1. [尝试1]: [结果]
2. [尝试2]: [结果]

### 请求协助
- [需要主CLI做什么]
- [期望的响应时间]

### 附件
- [相关文件路径]
- [错误日志路径]
```

**示例**:
```markdown
## 请示主CLI协助

**时间**: 2025-12-28 14:00
**级别**: 🔴 阻塞级

### 问题描述
密码重置功能需要发送邮件，但邮件服务配置在主worktree中

### 影响范围
- 本worktree: 无法完成密码重置功能测试
- 其他worktree: 无影响
- 整体进度: 预计延迟2小时

### 已尝试的解决方案
1. 尝试在本地worktree配置邮件服务 - 结果: 缺少SMTP密钥
2. 尝试使用Mock邮件服务 - 结果: 集成测试需要真实邮件服务

### 请求协助
需要主CLI提供以下任一方案：
1. 提供SMTP配置和密钥
2. 允许本worktree读取主worktree的邮件配置文件
3. 在主worktree配置邮件服务，本worktree通过API调用

### 附件
- 相关文件: src/auth/password_reset.py
- 错误日志: /tmp/password_reset_error.log
```

### 阶段3: 提交成果 (T+完成)

#### 步骤3.1: 验证完成度

**目标**: 确保所有验收标准都满足

**详细步骤**:

```bash
# ============================================
# 步骤3.1.1: 对照README中的验收标准检查
# ============================================
cd <worktree_path>

# 逐项检查验收标准
echo "## 验收标准检查" >> COMPLETION_REPORT.md

# 示例:
echo "- [x] 标准1: 实现用户注册功能 - ✅ 已完成" >> COMPLETION_REPORT.md
echo "- [x] 标准2: 实现用户登录功能 - ✅ 已完成" >> COMPLETION_REPORT.md
echo "- [x] 标准3: 单元测试通过率100% - ✅ 已完成 (45/45通过)" >> COMPLETION_REPORT.md

# ============================================
# 步骤3.1.2: 运行测试（如果适用）
# ============================================

# 示例: 运行单元测试
pytest tests/ --verbose --tb=short > test_results.txt 2>&1

# 检查测试结果
grep "passed" test_results.txt

# ============================================
# 步骤3.1.3: 检查是否有未提交的修改
# ============================================
git status --short

# 确保所有修改都已提交

# 产出物: 验证结果清单
```

#### 步骤3.2: 生成完成报告

**目标**: 记录工作成果和经验

**产出物**: COMPLETION_REPORT.md

**报告模板**:
```markdown
# <任务名称> 完成报告

## 完成时间
YYYY-MM-DD HH:MM

## 完成情况

### 验收标准
- ✅ 标准1: [具体描述完成情况]
- ✅ 标准2: [具体描述完成情况]
- ✅ 标准3: [具体描述完成情况]

### 实际工作量
- 预计: X小时
- 实际: Y小时
- 差异: ±Z小时（[说明原因]）

## 交付物

### 代码文件
1. [文件路径] - [行数] - [简要描述]
2. [文件路径] - [行数] - [简要描述]
3. [文件路径] - [行数] - [简要描述]

### 测试文件
1. [文件路径] - [测试数量] - [覆盖率]

### 文档
1. [文件路径] - [文档类型]
2. [文件路径] - [文档类型]

## 技术方案

### 选择的框架/工具
- [框架/工具1]: [选择原因]
- [框架/工具2]: [选择原因]

### 关键设计决策
1. [决策1]: [原因]
2. [决策2]: [原因]

### 代码组织
- [目录结构描述]
- [模块划分说明]

## 测试结果

### 单元测试
- 测试用例数: X
- 通过数: Y
- 失败数: Z
- 通过率: Y/X%

### 集成测试
- 测试用例数: X
- 通过数: Y
- 失败数: Z
- 通过率: Y/X%

### 测试覆盖率
- 行覆盖率: X%
- 分支覆盖率: Y%
- 函数覆盖率: Z%

## 性能指标

### 响应时间
- [API端点1]: Xms
- [API端点2]: Yms

### 资源使用
- CPU: X%
- 内存: YMB

## 问题记录

### 遇到的问题
1. **[问题1]**
   - 描述: [问题描述]
   - 解决方案: [如何解决]
   - 经验教训: [学到了什么]

2. **[问题2]**
   - 描述: [问题描述]
   - 解决方案: [如何解决]
   - 经验教训: [学到了什么]

### 请示主CLI的记录
1. **[请示1]**
   - 时间: YYYY-MM-DD HH:MM
   - 级别: 🔴/🟡/🟢
   - 问题描述: [问题]
   - 主CLI响应: [主CLI如何协助]
   - 解决结果: [最终如何解决]

## Git提交

### 提交统计
- 总提交数: X个
- 第一个提交: <commit-sha> - [时间] - [描述]
- 最后一个提交: <commit-sha> - [时间] - [描述]

### 分支信息
- 分支名: <branch_name>
- 分支状态: [已推送到远程 / 仅本地]

## 改进建议

### 对项目的建议
1. [建议1]
2. [建议2]

### 对工作流程的建议
1. [建议1]
2. [建议2]

## 附录

### 相关文档
- [文档链接1]
- [文档链接2]

### 相关Issue
- [Issue链接1]
- [Issue链接2]

---

**报告生成时间**: YYYY-MM-DD HH:MM
**Worker CLI**: [Worker CLI名称]
**任务**: <任务名称>
```

#### 步骤3.3: Git提交

**目标**: 将所有工作成果提交到分支

**详细步骤**:

```bash
# ============================================
# 步骤3.3.1: 检查Git状态
# ============================================
cd <worktree_path>
git status

# 确保所有文件都已暂存或提交

# ============================================
# 步骤3.3.2: 添加所有文件
# ============================================
git add .

# ============================================
# 步骤3.3.3: 创建最终提交
# ============================================
git commit -m "feat: 完成<任务名称>

## 完成情况
- ✅ 验收标准1: [具体描述]
- ✅ 验收标准2: [具体描述]
- ✅ 验收标准3: [具体描述]

## 交付物
- 代码: X个文件，Y行代码
- 测试: X个测试用例，通过率Y%
- 文档: X个文档

## 测试结果
- 单元测试: Y%通过率
- 集成测试: Z%通过率
- 覆盖率: W%

## 工作量
- 预计: X小时
- 实际: Y小时

🤖 Generated with Claude Code
Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# ============================================
# 步骤3.3.4: 推送到远程（如果需要）
# ============================================
git push origin <branch_name>

# ============================================
# 步骤3.3.5: 更新README标记完成
# ============================================

cat >> README.md <<EOF

## 任务完成确认

**完成时间**: YYYY-MM-DD HH:MM
**Worker CLI**: [Worker CLI名称]

### 验收标准
- ✅ 所有验收标准已满足

### Git提交
- 分支: <branch_name>
- 提交SHA: <commit_sha>
- 已推送到远程: [是/否]

### 交付物
- [列出所有交付物]

EOF

git add README.md
git commit -m "docs: 标记任务完成"
git push origin <branch_name>

# 产出物: 所有工作成果已提交
```

---

## 任务分配方法

### 工作量估算原则

**目标**: 确保任务分配合理，避免Worker CLI等待

**估算方法**:
1. **分解任务**: 将大任务拆分为小子任务（0.5-2小时）
2. **估算每个子任务**: 考虑代码编写、测试、调试、文档
3. **增加缓冲**: 在总时间基础上增加20%作为缓冲
4. **考虑差异**: 如果工作量差异>3小时，需要调整

**工作量差异处理**:
| 差异范围 | 处理方式 |
|---------|---------|
| 0-1小时 | 可接受，无需调整 |
| 1-3小时 | 可接受，考虑让提前完成的CLI协助 |
| >3小时 | 需要调整任务分配或增加辅助任务 |

**示例**:
```markdown
# 工作量估算示例

## 任务拆分
原始任务: 开发电商系统（包含认证、支付、订单、库存）

## 子任务1: 用户认证系统
- 注册功能: 2小时
- 登录功能: 1.5小时
- 密码重置: 2小时
- 单元测试: 1.5小时
- 集成测试: 1小时
- 文档编写: 0.5小时
- 小计: 8.5小时
- 缓冲20%: 1.7小时
- **总计: 10.2小时**

## 子任务2: 支付系统
- 支付接口集成: 3小时
- 支付回调处理: 2小时
- 退款处理: 2小时
- 单元测试: 1.5小时
- 集成测试: 1.5小时
- 文档编写: 0.5小时
- 小计: 10.5小时
- 缓冲20%: 2.1小时
- **总计: 12.6小时**

## 子任务3: 订单系统
- 订单创建: 2小时
- 订单查询: 1小时
- 订单状态更新: 2小时
- 单元测试: 1小时
- 集成测试: 1小时
- 文档编写: 0.5小时
- 小计: 7.5小时
- 缓冲20%: 1.5小时
- **总计: 9小时**

## 工作量平衡分析
- CLI-1: 10.2小时
- CLI-2: 12.6小时
- CLI-3: 9小时
- 最长: 12.6小时
- 最短: 9小时
- 差异: 3.6小时

## 调整建议
CLI-3完成时，CLI-2还在进行中（剩余3.6小时）
建议: CLI-3完成后协助CLI-2进行测试或文档编写
```

### README创建流程

**步骤1: 准备任务信息**
```bash
# 收集以下信息：
- 任务目标
- 验收标准
- 工作范围
- 优先级
- 工作量估算
```

**步骤2: 使用模板创建README**
```bash
# 复制README模板
cp <README模板路径> /opt/claude/project_<worktree>/README.md

# 填写任务信息
vim /opt/claude/project_<worktree>/README.md
```

**步骤3: 验证README完整性**
```bash
# 检查清单
- [ ] 任务目标清晰
- [ ] 验收标准具体（可量化）
- [ ] 工作范围明确（本worktree vs 超出范围）
- [ ] 优先级明确
- [ ] 工作量估算合理
- [ ] 问题请示流程清晰
```

### 任务分配示例

**场景**: MyStocks项目Phase 5 - 回测引擎开发

```bash
# ============================================
# 主CLI: 任务分配
# ============================================

# 1. 分析原始任务
原始任务: 开发回测引擎（包含12个策略、性能优化、文档）

# 2. 拆分为子任务
子任务1: 核心回测引擎（4个基础策略）
子任务2: 高级策略（8个高级策略）
子任务3: 性能优化和文档

# 3. 估算工作量
子任务1: 8小时
子任务2: 10小时
子任务3: 6小时

# 4. 创建worktree
git worktree add /opt/claude/mystocks_phase5_core phase5-backtest-core
git worktree add /opt/claude/mystocks_phase5_advanced phase5-backtest-advanced
git worktree add /opt/claude/mystocks_phase5_opt phase5-backtest-optimization

# 5. 创建README（使用模板）

# ============================================
# Worker CLI-1 README示例
# ============================================
```

```markdown
# MyStocks项目 - Phase 5 核心回测引擎

## 任务目标
开发核心回测引擎，实现4个基础策略的回测功能

## 背景
Phase 5需要开发完整的回测系统，本worktree负责核心引擎和4个基础策略

## 验收标准
- [ ] 实现回测引擎核心框架
- [ ] 实现4个基础策略（均线、突破、动量、均值回归）
- [ ] 单元测试通过率 = 100%
- [ ] 集成测试通过率 = 100%
- [ ] 回测性能: 10年历史数据 < 30秒

## 工作范围
### 本worktree范围内
- ✅ 回测引擎核心代码
- ✅ 4个基础策略实现
- ✅ 单元测试和集成测试
- ✅ 策略文档

### 超出本worktree范围（需要请示主CLI）
- ⚠️ 修改数据访问层（如果需要优化数据加载）
- ⚠️ 修改数据库schema（如果需要新增字段）
- ⚠️ 性能优化涉及其他模块

## 优先级
- 🔴 高（最高优先级，Phase 5的核心任务）

## 预计工作量
- 总计: 8小时
- 核心引擎: 3小时
- 策略实现: 3小时
- 测试: 1.5小时
- 文档: 0.5小时

## 预计完成时间
T+8h（从现在开始计算）

## 技术建议
- 使用Python 3.12+
- 使用pandas进行数据处理
- 使用pytest进行测试
- 数据存储使用PostgreSQL

## 问题请示流程
如果遇到以下情况，请向主CLI请示：
1. 需要修改数据访问层
2. 需要调整数据库schema
3. 发现性能瓶颈需要跨模块优化
4. 需要调整任务优先级

## 进度更新
### T+0h（任务开始）
- 状态: 任务理解中
- 进度: 0%

---

**任务分配信息**
- 分配给: Worker CLI-1
- 分配时间: 2025-12-28 12:00
- 主CLI: Claude Code (Manager)
- 项目: MyStocks Phase 5
- 分支: phase5-backtest-core
```

---

## 权限管理

### 权限范围定义

| 角色 | 本worktree | 其他worktree | 主worktree | Git操作 |
|------|-----------|-------------|-----------|---------|
| **主CLI** | 读+写 | 读+写 | 读+写 | 全部权限 |
| **Worker CLI** | 读+写 | 只读 | 只读 | 本分支提交 |

### 权限边界

**Worker CLI可以做** ✅:
- 在本worktree内创建、修改、删除文件
- 提交到分配的分支
- 创建本worktree内的子目录
- 读取其他worktree的文件（只读）

**Worker CLI不能做** ❌:
- 修改其他worktree的文件
- 修改主worktree的文件
- 提交到其他分支
- 创建额外的worktree
- 删除其他worktree

**例外情况** ⚠️:
- Worker CLI可以**请示主CLI**修改其他worktree的文件
- 主CLI可以**授权**Worker CLI进行跨worktree操作
- 紧急情况下，主CLI可以**直接介入**（需要记录原因）

### 权限申请流程

```bash
# ============================================
# 步骤1: Worker CLI识别需要跨worktree操作
# ============================================

# 示例: Worker CLI-2发现需要修改Worker CLI-1的文件
# 原因: 两个策略共享同一个配置文件

# ============================================
# 步骤2: Worker CLI向主CLI请示
# ============================================

cat >> README.md <<EOF

## 请示主CLI协助

**时间**: YYYY-MM-DD HH:MM
**级别**: 🔴 阻塞级

### 问题描述
策略A和策略B共享配置文件 src/strategies/config.py
策略B需要修改该配置文件，但该文件属于策略A（Worker CLI-1的worktree）

### 影响范围
- 本worktree: 无法完成策略B配置
- Worker CLI-1: 策略A可能受影响
- 整体进度: 预计延迟1小时

### 请求协助
请求主CLI协调以下方案之一：
1. Worker CLI-1修改配置文件，同时支持策略A和策略B
2. 将config.py移到主worktree，作为共享配置
3. 主CLI修改config.py，同时满足两个策略的需求

### 附件
- 相关文件: src/strategies/strategy_b.py
- 错误日志: /tmp/strategy_config_error.log

EOF

# ============================================
# 步骤3: 主CLI评估并响应
# ============================================

# 主CLI分析影响范围
git diff --name-only phase5-backtest-a phase5-backtest-b

# 主CLI决定方案
# 主CLI执行协调操作

# ============================================
# 步骤4: Worker CLI继续工作
# ============================================

# 问题解决后，Worker CLI继续工作
```

### 权限违规处理

**定义**: Worker CLI在未请示主CLI的情况下，修改了其他worktree的文件

**处理流程**:
```bash
# ============================================
# 步骤1: 主CLI发现权限违规
# ============================================

# 示例: 主CLI通过git log发现Worker CLI-2修改了Worker CLI-1的文件
git log --all --full-history --oneline -- "src/strategies/config.py"

# 发现: commit 1234abc (Worker CLI-2) 修改了config.py（属于Worker CLI-1）

# ============================================
# 步骤2: 主CLI评估影响
# ============================================

# 分析影响范围
# 确定是否造成冲突或数据丢失

# ============================================
# 步骤3: 主CLI与Worker CLI沟通
# ============================================

# 了解Worker CLI-2为何修改该文件
# 评估是否有正当理由

# ============================================
# 步骤4: 处理决定
# ============================================

# 如果有正当理由且未造成影响:
# - 记录到进度报告
# - 更新交互规则，避免未来发生

# 如果造成影响或无正当理由:
# - 回滚违规修改
# - 重新执行正确的流程
# - 记录教训，更新交互规则

# ============================================
# 步骤5: 更新文档
# ============================================

cat >> /tmp/progress_report.md <<EOF

## 权限违规事件

**时间**: YYYY-MM-DD HH:MM
**涉及Worker CLI**: CLI-2
**违规操作**: 修改了Worker CLI-1的文件 config.py

### 处理结果
- [处理方式]
- [影响评估]
- [改进措施]

EOF
```

---

## 交互规则

### 规则1: 主CLI只监控不干预

**描述**: 主CLI在进度监控阶段只读取状态，不修改Worker CLI的文件

**正确做法** ✅:
```bash
# 主CLI检查Worker CLI进度
cd /opt/claude/project_<worktree>
git status --short  # 只读取状态
tail -n 20 README.md # 只查看进度更新
git log --oneline -5 # 只查看提交历史
```

**错误做法** ❌:
```bash
# 主CLI直接修改Worker CLI的代码
cd /opt/claude/project_<worktree>
vim src/auth.py  # ❌ 不要这样做
```

### 规则2: Worker CLI主动汇报进度

**描述**: Worker CLI需要定期在README.md中更新进度

**正确做法** ✅:
```markdown
## 进度更新 (T+2h)
- ✅ 完成用户注册功能
- ✅ 完成用户登录功能
- 🔄 正在实现密码重置功能
- ⏳ 待编写单元测试
- 遇到的问题: 当前无阻塞问题
```

**错误做法** ❌:
```markdown
（README中没有进度更新，主CLI无法了解工作状态）
```

### 规则3: 问题分级处理

**描述**: 根据问题级别采取不同的响应时间

**问题级别**:
- 🟢 信息级: 下次定期检查时处理
- 🟡 警告级: 4小时内响应
- 🔴 阻塞级: 1小时内响应

**示例**:
```markdown
## 问题请示（级别：🔴 阻塞级）
**时间**: 2025-12-28 14:00
**问题描述**: 服务启动失败
**期望响应**: 1小时内

主CLI在14:45发现并响应，符合期望 ✅
```

### 规则4: 技术方案自主决策

**描述**: Worker CLI有权自主选择技术实现方案

**Worker CLI的权利** ✅:
- 选择测试框架
- 选择代码风格
- 选择工具库
- 选择实现方式

**主CLI不应该做的事** ❌:
- 指定具体的技术实现方案
- 要求使用特定的库或框架
- 审查Worker CLI的代码风格

**例外情况**:
- 技术方案影响其他worktree（需要主CLI协调）
- 技术方案违反项目架构原则（主CLI应该纠正）
- 技术方案引入安全风险（主CLI应该干预）

---

## 任务管理工具

### OpenSpec

**适用场景**: 变更提案驱动的工作流

**使用方法**:
```bash
# 在worktree中创建变更提案
cd /opt/claude/project_<worktree>
openspec proposal create <name>

# 查看任务列表
openspec list

# 查看具体任务
openspec show <proposal-id>

# 标记任务状态
openspec apply <proposal-id>
```

**与主CLI的集成**:
```markdown
## 任务管理工具
- OpenSpec: 用于变更提案管理
- 命令: `openspec proposal create <name>`
- 提案ID: <proposal-id>
```

### TaskMaster AI

**适用场景**: 从PRD生成任务列表

**使用方法**:
```bash
# 查看所有任务
task-master list

# 查看下一个任务
task-master next

# 查看具体任务
task-master show <task-id>

# 标记任务状态
task-master set-status --id=<task-id> --status=done

# 展开任务为子任务
task-master expand --id=<task-id>
```

**与主CLI的集成**:
```markdown
## 任务管理工具
- TaskMaster: 用于任务列表管理
- 命令: `task-master list`
- 总任务数: X个
- 已完成: Y个
```

**选择建议**:
- 如果项目使用**变更提案流程**（OpenSpec），每个worktree创建一个proposal
- 如果项目从**PRD生成任务**（TaskMaster），主CLI创建任务后分配给worktree
- 如果项目**没有使用工具**，README中的任务清单就是主要管理方式

### 任务管理示例

**场景**: 使用TaskMaster管理worktree任务

```bash
# ============================================
# 主CLI: 创建任务列表
# ============================================

# 1. 从PRD生成任务（如果有PRD）
task-master parse-prd docs/prd.txt

# 2. 查看生成的任务
task-master list

# 3. 分配任务给worktree
# 假设生成的任务1-3属于worktree-1，任务4-6属于worktree-2

# 在worktree-1的README中记录
cat >> /opt/claude/project_<worktree1>/README.md <<EOF

## TaskMaster任务列表
- 任务1: task-master show 1
- 任务2: task-master show 2
- 任务3: task-master show 3

查看命令:
task-master show <id>

更新进度:
task-master update-subtask --id=<id> --prompt="进度更新"
EOF

# ============================================
# Worker CLI: 使用TaskMaster跟踪任务
# ============================================

cd /opt/claude/project_<worktree1>

# 查看当前任务
task-master show 1

# 开始任务
task-master set-status --id=1 --status=in-progress

# 更新任务进度
task-master update-subtask --id=1 --prompt="完成用户注册功能，耗时2小时"

# 完成任务
task-master set-status --id=1 --status=done

# 查看下一个任务
task-master next
```

---

## 快速参考

### 主CLI命令速查

#### 创建worktree
```bash
# 基本语法
git worktree add <路径> <分支名>

# 从新分支创建
git worktree add -b <分支名> <路径>

# 示例
git worktree add /opt/claude/project_auth feature-auth-system
```

#### 检查worktree状态
```bash
# 列出所有worktree
git worktree list

# 检查特定worktree的Git状态
cd /opt/claude/project_<worktree>
git status --short

# 检查最新提交
git log --oneline -3

# 检查README进度
tail -n 30 README.md
```

#### 合并分支
```bash
# 切换到main分支
git checkout main
git pull origin main

# 合并第一个分支
git merge feature-auth-system --no-ff -m "Merge feature-auth-system"

# 合并第二个分支
git merge feature-payment-system --no-ff -m "Merge feature-payment-system"
```

#### 删除worktree
```bash
# 删除单个worktree
git worktree remove /opt/claude/project_<worktree>

# 删除所有worktree（除了main）
git worktree list | grep -v "main" | awk '{print $1}' | while read path; do
    git worktree remove "$path"
done
```

### Worker CLI命令速查

#### 开始工作
```bash
# 进入worktree
cd /opt/claude/project_<worktree>

# 查看任务
cat README.md

# 开始执行任务
# [编写代码、测试、文档]
```

#### Git提交
```bash
# 查看状态
git status

# 添加所有文件
git add .

# 提交
git commit -m "feat: 完成功能

- 功能描述1
- 功能描述2

🤖 Generated with Claude Code
Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# 推送到远程（如果需要）
git push origin <branch_name>
```

#### 请示主CLI
```bash
# 在README中添加请示
cat >> README.md <<EOF

## 请示主CLI协助
[请示内容]

EOF

# 提交README更新
git add README.md
git commit -m "docs: 请示主CLI协助"
```

### 检查清单

#### 主CLI: 任务分配阶段
- [ ] 任务拆分完成
- [ ] 工作量估算完成
- [ ] 所有worktree创建成功
- [ ] 所有README创建成功
- [ ] README包含所有必要信息
- [ ] 通知Worker CLI开始工作

#### 主CLI: 进度监控阶段
- [ ] 每小时检查worktree状态
- [ ] 每2小时生成进度报告
- [ ] 发现问题后及时响应
- [ ] 更新总体进度评估

#### 主CLI: 集成管理阶段
- [ ] 验证所有Worker CLI完成
- [ ] 检查所有验收标准
- [ ] 合并所有分支到main
- [ ] 推送到远程
- [ ] 清理所有worktree
- [ ] 生成完成报告

#### Worker CLI: 任务理解阶段
- [ ] 阅读并理解README
- [ ] 确认验收标准清晰
- [ ] 规划工作方式
- [ ] 记录任务理解

#### Worker CLI: 独立执行阶段
- [ ] 在worktree中独立工作
- [ ] 定期更新README进度
- [ ] 频繁Git提交
- [ ] 遇到问题时及时请示

#### Worker CLI: 提交阶段
- [ ] 验证所有验收标准
- [ ] 生成完成报告
- [ ] Git提交到分支
- [ ] 更新README标记完成
- [ ] 通知主CLI

---

## 附录

### Git Worktree官方文档
- [Git Worktree中文文档](https://git-scm.com/docs/git-worktree/zh_HANS-CN)
- [Git Worktree官方文档](https://git-scm.com/docs/git-worktree)

### 项目特定文档
- `/opt/claude/mystocks_spec/docs/guides/GIT_WORKTREE_MAIN_CLI_MANUAL.md` - Git Worktree命令参考
- `<项目路径>/docs/guides/` - 其他项目指南

### 模板文档
- README模板: 见"任务分配方法"章节
- 完成报告模板: 见"Worker CLI工作流程 > 阶段3"章节
- 进度报告模板: 见"主CLI工作流程 > 阶段2"章节

---

**文档版本**: v2.0
**最后更新**: 2025-12-28
**维护者**: Main CLI (Claude Code)
**适用性**: 任何使用Git Worktree进行多CLI协作的项目
