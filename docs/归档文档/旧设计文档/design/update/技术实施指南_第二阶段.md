# Web功能优化技术实施指南 - 第二阶段

## 阶段概览

**阶段名称**: 智能功能增强
**实施时间**: 第5-7周 (总计: 15-21天)
**主要目标**: 在第一阶段基础上，引入智能问财升级、交易信号识别、智能股票池管理等功能
**技术栈**: Vue 3 + FastAPI + TA-Lib + 机器学习 + Redis

## 核心功能模块

### 1. 智能问财升级系统

#### 1.1 前端组件开发

**组件文件**: `src/views/Market/WencaiEnhanced.vue`

```vue
<template>
  <div class="wencai-enhanced">
    <!-- 智能问财头部 -->
    <div class="wencai-header">
      <div class="header-left">
        <h2>
          <el-icon><Search /></el-icon>
          智能问财筛选系统
        </h2>
        <p class="subtitle">基于AI驱动的自然语言股票筛选引擎</p>
      </div>

      <div class="header-right">
        <el-tag type="success" size="large">
          <el-icon><Lightning /></el-icon>
          AI增强版
        </el-tag>
      </div>
    </div>

    <!-- 智能查询面板 -->
    <el-card class="search-panel" shadow="hover">
      <template #header>
        <div class="card-header">
          <span>智能查询输入</span>
          <div class="query-examples">
            <el-button
              v-for="example in queryExamples"
              :key="example.text"
              size="small"
              @click="setQueryExample(example.query)"
              :type="query === example.query ? 'primary' : 'default'"
            >
              {{ example.text }}
            </el-button>
          </div>
        </div>
      </template>

      <!-- AI问财输入框 -->
      <div class="query-input-container">
        <div class="query-input-wrapper">
          <el-input
            v-model="query"
            type="textarea"
            :rows="3"
            placeholder="请用自然语言描述您的选股需求，例如：'寻找市值大于1000亿、ROE大于15%且近期突破前期高点的医药股'"
            maxlength="500"
            show-word-limit
            class="ai-query-input"
          />
          <div class="input-actions">
            <el-tooltip content="语音输入(开发中)">
              <el-button
                :disabled="!isRecording"
                @click="toggleRecording"
                :type="isRecording ? 'danger' : 'default'"
                size="small"
              >
                <el-icon v-if="isRecording"><Microphone /></el-icon>
                <el-icon v-else><Microphone /></el-icon>
                {{ isRecording ? '停止录制' : '语音输入' }}
              </el-button>
            </el-tooltip>

            <el-button
              @click="analyzeQuery"
              :loading="isAnalyzing"
              type="primary"
              size="small"
            >
              <el-icon><DataAnalysis /></el-icon>
              AI智能分析
            </el-button>

            <el-button
              @click="executeSearch"
              :loading="isSearching"
              type="success"
              size="small"
            >
              <el-icon><Search /></el-icon>
              执行筛选
            </el-button>
          </div>
        </div>
      </div>

      <!-- 查询分析结果 -->
      <div v-if="analysisResult" class="analysis-result">
        <el-alert
          :title="`查询解析结果: ${analysisResult.summary}`"
          type="info"
          :closable="false"
          show-icon
        >
          <template #default>
            <div class="analysis-details">
              <div class="condition-list">
                <h4>解析条件:</h4>
                <el-tag
                  v-for="(condition, index) in analysisResult.conditions"
                  :key="index"
                  class="condition-tag"
                  :type="condition.type"
                >
                  {{ condition.field }} {{ condition.operator }} {{ condition.value }}
                </el-tag>
              </div>

              <div class="field-list" v-if="analysisResult.requestedFields.length">
                <h4>请求数据:</h4>
                <el-tag
                  v-for="field in analysisResult.requestedFields"
                  :key="field"
                  class="field-tag"
                >
                  {{ getFieldDisplayName(field) }}
                </el-tag>
              </div>
            </div>
          </template>
        </el-alert>
      </div>
    </el-card>

    <!-- 高级筛选面板 -->
    <el-card class="advanced-filters" v-if="showAdvancedFilters">
      <template #header>
        <span>高级筛选条件</span>
        <el-button @click="addCustomFilter" size="small" type="primary">
          <el-icon><Plus /></el-icon>
          添加自定义条件
        </el-button>
      </template>

      <div class="filters-content">
        <!-- 技术指标筛选 -->
        <div class="filter-section">
          <h4>技术指标</h4>
          <el-row :gutter="12">
            <el-col :span="8">
              <el-select v-model="technicalFilters.macd" placeholder="MACD状态" clearable>
                <el-option label="金叉" value="golden_cross" />
                <el-option label="死叉" value="death_cross" />
                <el-option label="零轴上方" value="above_zero" />
                <el-option label="零轴下方" value="below_zero" />
              </el-select>
            </el-col>
            <el-col :span="8">
              <el-select v-model="technicalFilters.rsi" placeholder="RSI范围" clearable>
                <el-option label="超买 (>70)" value="overbought" />
                <el-option label="超卖 (<30)" value="oversold" />
                <el-option label="中性 (30-70)" value="neutral" />
              </el-select>
            </el-col>
            <el-col :span="8">
              <el-select v-model="technicalFilters.kdj" placeholder="KDJ状态" clearable>
                <el-option label="金叉" value="golden_cross" />
                <el-option label="死叉" value="death_cross" />
                <el-option label="高位" value="high_zone" />
                <el-option label="低位" value="low_zone" />
              </el-select>
            </el-col>
          </el-row>
        </div>

        <!-- 基本面筛选 -->
        <div class="filter-section">
          <h4>基本面指标</h4>
          <el-row :gutter="12">
            <el-col :span="6">
              <el-input-number v-model="fundamentalFilters.peMin" :min="0" :max="1000" placeholder="最小PE" />
              <span class="field-label">最小PE</span>
            </el-col>
            <el-col :span="6">
              <el-input-number v-model="fundamentalFilters.peMax" :min="0" :max="1000" placeholder="最大PE" />
              <span class="field-label">最大PE</span>
            </el-col>
            <el-col :span="6">
              <el-input-number v-model="fundamentalFilters.roeMin" :min="0" :max="100" :precision="2" placeholder="最小ROE(%)" />
              <span class="field-label">最小ROE(%)</span>
            </el-col>
            <el-col :span="6">
              <el-input-number v-model="fundamentalFilters.roeMax" :min="0" :max="100" :precision="2" placeholder="最大ROE(%)" />
              <span class="field-label">最大ROE(%)</span>
            </el-col>
          </el-row>
        </div>

        <!-- 市场表现筛选 -->
        <div class="filter-section">
          <h4>市场表现</h4>
          <el-row :gutter="12">
            <el-col :span="8">
              <el-select v-model="marketFilters.priceRange" placeholder="价格区间" clearable>
                <el-option label="低价股 (<10元)" value="low_price" />
                <el-option label="中价股 (10-50元)" value="mid_price" />
                <el-option label="高价股 (>50元)" value="high_price" />
              </el-select>
            </el-col>
            <el-col :span="8">
              <el-select v-model="marketFilters.volumePattern" placeholder="成交量特征" clearable>
                <el-option label="放量突破" value="volume_breakthrough" />
                <el-option label("持续放量" value="continuous_volume" />
                <el-option label="缩量整理" value="volume_consolidation" />
              </el-select>
            </el-col>
            <el-col :span="8">
              <el-select v-model="marketFilters.trendPattern" placeholder="趋势模式" clearable>
                <el-option label="上升趋势" value="uptrend" />
                <el-option label="下降趋势" value="downtrend" />
                <el-option label("横盘整理" value="sideways" />
              </el-select>
            </el-col>
          </el-row>
        </div>
      </div>
    </el-card>

    <!-- 筛选结果 -->
    <div class="search-results">
      <el-card>
        <template #header>
          <div class="results-header">
            <span>
              筛选结果
              <el-badge :value="results.length" class="result-count" />
            </span>
            <div class="results-actions">
              <el-button @click="exportResults" size="small" type="primary" plain>
                <el-icon><Download /></el-icon>
                导出结果
              </el-button>
              <el-button @click="saveAsWatchlist" size="small" type="success" plain>
                <el-icon><Star /></el-icon>
                保存到自选股
              </el-button>
            </div>
          </div>
        </template>

        <!-- 结果表格 -->
        <el-table
          :data="results"
          style="width: 100%"
          height="600"
          v-loading="isSearching"
          :default-sort="{ prop: 'matchScore', order: 'descending' }"
        >
          <el-table-column type="index" width="50" />

          <el-table-column prop="code" label="代码" width="100" fixed>
            <template #default="scope">
              <el-link @click="showStockDetail(scope.row)">{{ scope.row.code }}</el-link>
            </template>
          </el-table-column>

          <el-table-column prop="name" label="名称" width="120" fixed />

          <el-table-column prop="currentPrice" label="现价" width="100">
            <template #default="scope">
              <span :class="getPriceClass(scope.row.changePct)">
                {{ scope.row.currentPrice?.toFixed(2) }}
              </span>
            </template>
          </el-table-column>

          <el-table-column prop="changePct" label="涨跌幅" width="100" sortable>
            <template #default="scope">
              <span :class="getChangeClass(scope.row.changePct)">
                {{ scope.row.changePct?.toFixed(2) }}%
              </span>
            </template>
          </el-table-column>

          <el-table-column prop="matchScore" label="匹配度" width="100" sortable>
            <template #default="scope">
              <el-progress
                :percentage="scope.row.matchScore"
                :color="getScoreColor(scope.row.matchScore)"
                :stroke-width="8"
              />
            </template>
          </el-table-column>

          <!-- 动态显示筛选匹配的技术指标 -->
          <el-table-column
            v-for="field in selectedFields"
            :key="field"
            :prop="field"
            :label="getFieldDisplayName(field)"
            :width="getFieldWidth(field)"
          >
            <template #default="scope">
              {{ formatFieldValue(field, scope.row[field]) }}
            </template>
          </el-table-column>

          <!-- 操作列 -->
          <el-table-column label="操作" width="150" fixed="right">
            <template #default="scope">
              <el-button size="small" @click="viewKLine(scope.row)">
                K线图
              </el-button>
              <el-button size="small" @click="addToWatchlist(scope.row)" type="primary" plain>
                关注
              </el-button>
            </template>
          </el-table-column>
        </el-table>

        <!-- 分页 -->
        <div class="pagination-container">
          <el-pagination
            v-model:current-page="currentPage"
            v-model:page-size="pageSize"
            :page-sizes="[10, 20, 50, 100]"
            :total="totalResults"
            layout="total, sizes, prev, pager, next, jumper"
            @size-change="handleSizeChange"
            @current-change="handleCurrentChange"
          />
        </div>
      </el-card>
    </div>
  </div>
</template>

<script>
import { ref, reactive, computed, onMounted, nextTick } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import {
  Search,
  DataAnalysis,
  Lightning,
  Download,
  Star,
  Plus,
  Microphone
} from '@element-plus/icons-vue'

export default {
  name: 'WencaiEnhanced',
  components: {
    Search,
    DataAnalysis,
    Lightning,
    Download,
    Star,
    Plus,
    Microphone
  },
  setup() {
    // 响应式数据
    const query = ref('')
    const isAnalyzing = ref(false)
    const isSearching = ref(false)
    const isRecording = ref(false)
    const showAdvancedFilters = ref(false)
    const results = ref([])
    const analysisResult = ref(null)
    const currentPage = ref(1)
    const pageSize = ref(20)
    const totalResults = ref(0)
    const selectedFields = ref([])

    // 筛选条件
    const technicalFilters = reactive({
      macd: '',
      rsi: '',
      kdj: ''
    })

    const fundamentalFilters = reactive({
      peMin: null,
      peMax: null,
      roeMin: null,
      roeMax: null
    })

    const marketFilters = reactive({
      priceRange: '',
      volumePattern: '',
      trendPattern: ''
    })

    // 查询示例
    const queryExamples = ref([
      {
        text: '白马股筛选',
        query: '寻找ROE连续3年大于15%、净利润增长率大于20%、市盈率小于30的优质上市公司'
      },
      {
        text: '技术突破',
        query: '筛选近期MACD金叉、RSI未超买、成交量放大的股票'
      },
      {
        text: '低估值成长',
        query: '寻找PE小于20、净利润增长率大于30%、市值小于500亿的成长股'
      },
      {
        text: '热点题材',
        query: '在人工智能概念股中，筛选基本面良好的龙头企业'
      }
    ])

    // 计算属性
    const processedQuery = computed(() => {
      return analysisResult.value?.processedQuery || query.value
    })

    // 方法
    const setQueryExample = (exampleQuery) => {
      query.value = exampleQuery
      analyzeQuery()
    }

    const analyzeQuery = async () => {
      if (!query.value.trim()) {
        ElMessage.warning('请输入查询条件')
        return
      }

      isAnalyzing.value = true
      try {
        const response = await fetch('/api/wencai/analyze-query', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            query: query.value
          })
        })

        if (!response.ok) {
          throw new Error('查询分析失败')
        }

        const data = await response.json()
        analysisResult.value = data

        // 根据分析结果自动设置高级筛选
        setAdvancedFiltersFromAnalysis(data)

        ElMessage.success('查询分析完成')
      } catch (error) {
        console.error('分析查询失败:', error)
        ElMessage.error('查询分析失败，请重试')
      } finally {
        isAnalyzing.value = false
      }
    }

    const setAdvancedFiltersFromAnalysis = (analysis) => {
      // 根据分析结果设置高级筛选条件
      if (analysis.conditions) {
        analysis.conditions.forEach(condition => {
          switch (condition.field) {
            case 'pe':
              if (condition.operator === '>=') {
                fundamentalFilters.peMin = condition.value
              } else {
                fundamentalFilters.peMax = condition.value
              }
              break
            case 'roe':
              if (condition.operator === '>=') {
                fundamentalFilters.roeMin = condition.value
              } else {
                fundamentalFilters.roeMax = condition.value
              }
              break
            case 'macd':
              technicalFilters.macd = condition.value
              break
            case 'rsi':
              technicalFilters.rsi = condition.value
              break
            // 更多条件映射...
          }
        })
      }

      // 设置请求的字段
      if (analysis.requestedFields) {
        selectedFields.value = analysis.requestedFields
      }
    }

    const executeSearch = async () => {
      isSearching.value = true

      try {
        const searchParams = {
          query: processedQuery.value,
          advancedFilters: {
            technical: technicalFilters,
            fundamental: fundamentalFilters,
            market: marketFilters
          },
          selectedFields: selectedFields.value,
          page: currentPage.value,
          pageSize: pageSize.value
        }

        const response = await fetch('/api/wencai/search', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(searchParams)
        })

        if (!response.ok) {
          throw new Error('搜索执行失败')
        }

        const data = await response.json()
        results.value = data.results
        totalResults.value = data.total

        ElMessage.success(`找到 ${data.results.length} 只符合条件的股票`)
      } catch (error) {
        console.error('搜索失败:', error)
        ElMessage.error('搜索失败，请重试')
      } finally {
        isSearching.value = false
      }
    }

    const toggleRecording = () => {
      isRecording.value = !isRecording.value

      if (isRecording.value) {
        // 启动语音录制
        ElMessage.info('开始录制，请开始说话...')
        startVoiceRecording()
      } else {
        // 停止语音录制
        ElMessage.info('停止录制，正在识别...')
        stopVoiceRecording()
      }
    }

    const startVoiceRecording = () => {
      // 语音录制逻辑
      if ('webkitSpeechRecognition' in window) {
        const recognition = new webkitSpeechRecognition()
        recognition.lang = 'zh-CN'
        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript
          query.value = transcript
          isRecording.value = false
          ElMessage.success('语音识别完成')
        }
        recognition.onerror = () => {
          isRecording.value = false
          ElMessage.error('语音识别失败')
        }
        recognition.start()
      } else {
        ElMessage.warning('您的浏览器不支持语音识别功能')
        isRecording.value = false
      }
    }

    const stopVoiceRecording = () => {
      // 停止语音录制
      isRecording.value = false
    }

    const showStockDetail = (stock) => {
      // 显示股票详情
      console.log('显示股票详情:', stock)
    }

    const viewKLine = (stock) => {
      // 查看K线图
      window.open(`/market/kline?symbol=${stock.code}`, '_blank')
    }

    const addToWatchlist = async (stock) => {
      try {
        const response = await fetch('/api/watchlist', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            stockCode: stock.code,
            stockName: stock.name
          })
        })

        if (!response.ok) {
          throw new Error('添加失败')
        }

        ElMessage.success(`已添加 ${stock.name} 到自选股`)
      } catch (error) {
        ElMessage.error('添加失败，请重试')
      }
    }

    const exportResults = () => {
      // 导出结果
      const csvContent = "data:text/csv;charset=utf-8," +
        generateCSV(results.value)

      const encodedUri = encodeURI(csvContent)
      const link = document.createElement("a")
      link.setAttribute("href", encodedUri)
      link.setAttribute("download", `问财筛选结果_${new Date().toISOString().split('T')[0]}.csv`)
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }

    const generateCSV = (data) => {
      if (!data.length) return ''

      const headers = Object.keys(data[0])
      const csvRows = [
        headers.join(','),
        ...data.map(row => headers.map(header => `"${row[header] || ''}"`).join(','))
      ]

      return csvRows.join('\n')
    }

    const saveAsWatchlist = async () => {
      try {
        const { value: watchlistName } = await ElMessageBox.prompt('请输入自选股名称', '保存到自选股', {
          confirmButtonText: '保存',
          cancelButtonText: '取消',
          inputPattern: /^.+$/,
          inputErrorMessage: '请输入自选股名称'
        })

        const response = await fetch('/api/watchlist/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: watchlistName,
            stocks: results.value
          })
        })

        if (!response.ok) {
          throw new Error('保存失败')
        }

        ElMessage.success('已保存到自选股')
      } catch (error) {
        if (error !== 'cancel') {
          ElMessage.error('保存失败，请重试')
        }
      }
    }

    // 辅助方法
    const getPriceClass = (changePct) => {
      return changePct >= 0 ? 'price-up' : 'price-down'
    }

    const getChangeClass = (changePct) => {
      return changePct >= 0 ? 'change-up' : 'change-down'
    }

    const getScoreColor = (score) => {
      if (score >= 80) return '#67C23A'
      if (score >= 60) return '#E6A23C'
      return '#F56C6C'
    }

    const getFieldDisplayName = (field) => {
      const fieldMap = {
        'pe': 'PE',
        'pb': 'PB',
        'roe': 'ROE(%)',
        'revenueGrowth': '营收增长率(%)',
        'netProfitGrowth': '净利润增长率(%)',
        'marketCap': '市值(亿)',
        'volume': '成交量',
        'turnoverRate': '换手率(%)'
      }
      return fieldMap[field] || field
    }

    const getFieldWidth = (field) => {
      return 120
    }

    const formatFieldValue = (field, value) => {
      if (value === null || value === undefined) return '-'

      if (field === 'marketCap') {
        return (value / 100000000).toFixed(0) + '亿'
      }
      if (field.includes('Rate') || field.includes('Growth')) {
        return value.toFixed(2) + '%'
      }

      return value.toString()
    }

    const handleSizeChange = (size) => {
      pageSize.value = size
      currentPage.value = 1
      executeSearch()
    }

    const handleCurrentChange = (page) => {
      currentPage.value = page
      executeSearch()
    }

    // 生命周期
    onMounted(() => {
      // 组件挂载时的初始化逻辑
    })

    return {
      // 数据
      query,
      isAnalyzing,
      isSearching,
      isRecording,
      showAdvancedFilters,
      results,
      analysisResult,
      currentPage,
      pageSize,
      totalResults,
      selectedFields,
      technicalFilters,
      fundamentalFilters,
      marketFilters,
      queryExamples,

      // 计算属性
      processedQuery,

      // 方法
      setQueryExample,
      analyzeQuery,
      executeSearch,
      toggleRecording,
      showStockDetail,
      viewKLine,
      addToWatchlist,
      exportResults,
      saveAsWatchlist,
      handleSizeChange,
      handleCurrentChange,

      // 辅助方法
      getPriceClass,
      getChangeClass,
      getScoreColor,
      getFieldDisplayName,
      getFieldWidth,
      formatFieldValue
    }
  }
}
</script>

<style scoped>
.wencai-enhanced {
  padding: 20px;
  background-color: #f5f7fa;
  min-height: 100vh;
}

.wencai-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 12px;
  color: white;
}

.header-left h2 {
  margin: 0;
  font-size: 24px;
  font-weight: bold;
  display: flex;
  align-items: center;
  gap: 10px;
}

.subtitle {
  margin: 5px 0 0 0;
  opacity: 0.9;
  font-size: 14px;
}

.search-panel {
  margin-bottom: 20px;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.query-examples {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.query-input-container {
  margin-bottom: 20px;
}

.query-input-wrapper {
  position: relative;
}

.ai-query-input {
  margin-bottom: 12px;
}

.ai-query-input :deep(.el-textarea__inner) {
  font-size: 14px;
  padding: 12px;
  border: 2px solid #e4e7ed;
  border-radius: 8px;
  transition: border-color 0.3s;
}

.ai-query-input :deep(.el-textarea__inner:focus) {
  border-color: #409EFF;
}

.input-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

.analysis-result {
  margin-top: 16px;
}

.analysis-details h4 {
  margin: 8px 0;
  font-size: 14px;
  color: #606266;
}

.condition-list,
.field-list {
  margin-bottom: 12px;
}

.condition-tag,
.field-tag {
  margin: 2px 4px 2px 0;
}

.advanced-filters {
  margin-bottom: 20px;
}

.filters-content {
  padding: 16px 0;
}

.filter-section {
  margin-bottom: 24px;
}

.filter-section h4 {
  margin-bottom: 12px;
  font-size: 14px;
  color: #303133;
  border-left: 3px solid #409EFF;
  padding-left: 8px;
}

.field-label {
  display: block;
  font-size: 12px;
  color: #909399;
  margin-top: 4px;
}

.search-results {
  margin-top: 20px;
}

.results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.result-count {
  margin-left: 8px;
}

.results-actions {
  display: flex;
  gap: 8px;
}

.price-up {
  color: #F56C6C;
  font-weight: bold;
}

.price-down {
  color: #67C23A;
  font-weight: bold;
}

.change-up {
  color: #F56C6C;
  font-weight: bold;
}

.change-down {
  color: #67C23A;
  font-weight: bold;
}

.pagination-container {
  margin-top: 16px;
  display: flex;
  justify-content: center;
}

@media (max-width: 768px) {
  .wencai-header {
    flex-direction: column;
    gap: 16px;
    text-align: center;
  }

  .input-actions {
    flex-wrap: wrap;
  }

  .query-examples {
    justify-content: center;
  }

  .results-header {
    flex-direction: column;
    gap: 12px;
  }
}
</style>
```

#### 1.2 后端API开发

**API文件**: `app/api/wencai_enhanced.py`

```python
"""
智能问财增强API
基于AI的自然语言股票筛选引擎
"""

from fastapi import APIRouter, HTTPException, Depends
from fastapi.security import HTTPBearer
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import asyncio
import re
import jieba
from datetime import datetime
import structlog

logger = structlog.get_logger(__name__)
router = APIRouter()
security = HTTPBearer()

# 查询解析模型
class QueryAnalysisRequest(BaseModel):
    query: str = Field(..., description="用户输入的查询语句")

class QueryAnalysisResult(BaseModel):
    summary: str = Field(..., description="查询解析摘要")
    conditions: List[Dict[str, Any]] = Field(..., description="解析的条件列表")
    requestedFields: List[str] = Field(..., description="请求的数据字段")
    processedQuery: str = Field(..., description="处理后的查询")
    confidence: float = Field(..., description="解析置信度")

class AdvancedFilters(BaseModel):
    technical: Dict[str, str] = Field(default_factory=dict)
    fundamental: Dict[str, Optional[float]] = Field(default_factory=dict)
    market: Dict[str, str] = Field(default_factory=dict)

class WencaiSearchRequest(BaseModel):
    query: str = Field(..., description="原始查询")
    advancedFilters: AdvancedFilters = Field(..., description="高级筛选条件")
    selectedFields: List[str] = Field(default_factory=list, description="选中的字段")
    page: int = Field(1, description="页码")
    pageSize: int = Field(20, description="每页大小")

class StockResult(BaseModel):
    code: str = Field(..., description="股票代码")
    name: str = Field(..., description="股票名称")
    currentPrice: Optional[float] = Field(None, description="当前价格")
    changePct: Optional[float] = Field(None, description="涨跌幅")
    matchScore: float = Field(..., description="匹配度")
    marketCap: Optional[float] = Field(None, description="市值")
    pe: Optional[float] = Field(None, description="市盈率")
    pb: Optional[float] = Field(None, description="市净率")
    roe: Optional[float] = Field(None, description="ROE")

class SearchResponse(BaseModel):
    results: List[StockResult] = Field(..., description="搜索结果")
    total: int = Field(..., description="总结果数")
    query: str = Field(..., description="处理的查询")
    analysis: Optional[QueryAnalysisResult] = Field(None, description="查询分析结果")

# 关键词映射字典
KEYWORD_MAPPINGS = {
    # 财务指标
    'pe': ['pe', '市盈率', 'pe比', 'pe估值'],
    'pb': ['pb', '市净率', 'pb比', 'pb估值'],
    'roe': ['roe', '净资产收益率', 'roa', 'roic'],
    'revenue_growth': ['营收增长', '营收增长率', '营业收入增长'],
    'net_profit_growth': ['净利润增长', '净利润增长率', '利润增长'],
    'market_cap': ['市值', '流通市值', '总市值'],

    # 技术指标
    'macd': ['macd', '指数平滑异同平均线'],
    'rsi': ['rsi', '相对强弱指数', '强弱指标'],
    'kdj': ['kdj', '随机指标'],
    'golden_cross': ['金叉', '黄金交叉'],
    'death_cross': ['死叉', '死亡交叉'],
    'breakthrough': ['突破', '放量突破'],

    # 市场表现
    'volume': ['成交量', '成交额', '量能'],
    'turnover_rate': ['换手率', '换手'],
    'price': ['价格', '股价'],

    # 行业概念
    'concept': ['概念', '题材', '主题'],
    'industry': ['行业', '板块'],

    # 交易规则
    'stock_type': ['股票类型', '板块分类']
}

# 自然语言处理器
class QueryProcessor:
    def __init__(self):
        self.logger = logger.bind(component="QueryProcessor")

        # 添加自定义词典
        jieba.add_word("白马股")
        jieba.add_word("龙头股")
        jieba.add_word("成长股")
        jieba.add_word("价值股")
        jieba.add_word("概念股")
        jieba.add_word("创业板")
        jieba.add_word("科创板")

    async def analyze_query(self, query: str) -> QueryAnalysisResult:
        """分析用户查询"""
        try:
            # 分词
            words = jieba.lcut(query)
            self.logger.info("Query analyzed", original=query, words=words)

            # 提取条件
            conditions = await self._extract_conditions(words)

            # 确定需要的字段
            requested_fields = await self._determine_fields(conditions)

            # 生成摘要
            summary = self._generate_summary(conditions)

            # 处理查询
            processed_query = await self._process_query(query, conditions)

            # 计算置信度
            confidence = self._calculate_confidence(conditions, len(words))

            return QueryAnalysisResult(
                summary=summary,
                conditions=conditions,
                requestedFields=requested_fields,
                processedQuery=processed_query,
                confidence=confidence
            )

        except Exception as e:
            self.logger.error("Query analysis failed", error=str(e))
            raise HTTPException(status_code=400, detail=f"查询解析失败: {str(e)}")

    async def _extract_conditions(self, words: List[str]) -> List[Dict[str, Any]]:
        """提取查询条件"""
        conditions = []

        # 遍历关键词映射
        for field, keywords in KEYWORD_MAPPINGS.items():
            for word in words:
                if word in keywords:
                    condition = await self._parse_condition(word, words)
                    if condition:
                        conditions.append(condition)
                    break

        return conditions

    async def _parse_condition(self, keyword: str, words: List[str]) -> Optional[Dict[str, Any]]:
        """解析单个条件"""
        try:
            # 查找操作符
            operators = ['>', '<', '>=', '<=', '=', '大于', '小于', '等于', '介于']
            operator = None
            value = None

            # 查找数值
            number_pattern = r'\d+\.?\d*'
            numbers = re.findall(number_pattern, ' '.join(words))

            if numbers:
                value = float(numbers[0])

                # 查找操作符
                for op in operators:
                    if op in ' '.join(words):
                        operator = self._normalize_operator(op)
                        break

                # 如果没有找到操作符，根据关键词推断
                if not operator:
                    if keyword in ['pe', 'pb', 'roe']:
                        operator = '<='  # 默认寻找较小的值
                    elif keyword in ['golden_cross', 'breakthrough']:
                        operator = '='  # 状态类条件
                        value = True

                return {
                    'field': self._map_keyword_to_field(keyword),
                    'operator': operator,
                    'value': value,
                    'keyword': keyword,
                    'original': f"{keyword} {operator} {value}"
                }

            return None

        except Exception as e:
            self.logger.warning("Condition parsing failed", keyword=keyword, error=str(e))
            return None

    def _normalize_operator(self, operator: str) -> str:
        """标准化操作符"""
        operator_map = {
            '>': '>=',
            '<': '<=',
            '大于': '>=',
            '小于': '<=',
            '等于': '=',
            '=': '='
        }
        return operator_map.get(operator, operator)

    def _map_keyword_to_field(self, keyword: str) -> str:
        """将关键词映射到数据库字段"""
        field_map = {
            'pe': 'pe_ratio',
            'pb': 'pb_ratio',
            'roe': 'roe_ratio',
            'revenue_growth': 'revenue_growth_rate',
            'net_profit_growth': 'net_profit_growth_rate',
            'market_cap': 'total_market_cap',
            'macd': 'macd_signal',
            'rsi': 'rsi_value',
            'kdj': 'kdj_signal'
        }
        return field_map.get(keyword, keyword)

    async def _determine_fields(self, conditions: List[Dict[str, Any]]) -> List[str]:
        """确定需要的字段"""
        fields = ['code', 'name', 'current_price', 'change_pct', 'match_score']

        for condition in conditions:
            field = condition['field']
            if field not in fields:
                fields.append(field)

        return fields

    def _generate_summary(self, conditions: List[Dict[str, Any]]) -> str:
        """生成查询摘要"""
        if not conditions:
            return "通用股票筛选"

        summary_parts = []
        for condition in conditions:
            summary_parts.append(f"{condition['field']} {condition['operator']} {condition['value']}")

        return "基于 " + "、".join(summary_parts) + " 的筛选"

    async def _process_query(self, query: str, conditions: List[Dict[str, Any]]) -> str:
        """处理查询"""
        # 简化查询，去除停用词
        processed = query.replace('寻找', '').replace('的', '').replace('股票', '')
        return processed.strip()

    def _calculate_confidence(self, conditions: List[Dict[str, Any]], word_count: int) -> float:
        """计算置信度"""
        if not conditions:
            return 0.5

        # 基础置信度
        base_confidence = min(conditions.__len__() / 3, 1.0)

        # 根据词数调整
        word_factor = min(word_count / 10, 1.0)

        return (base_confidence + word_factor) / 2

# 数据库查询器
class DatabaseQuerier:
    def __init__(self):
        self.logger = logger.bind(component="DatabaseQuerier")

    async def search_stocks(self, request: WencaiSearchRequest) -> SearchResponse:
        """搜索股票"""
        try:
            # 构建查询
            query_builder = StockQueryBuilder()

            # 添加基础条件
            query_builder.add_basic_conditions(request.advancedFilters)

            # 执行查询
            results = await query_builder.execute(request.page, request.pageSize)

            # 计算匹配度
            scored_results = await self._calculate_match_scores(results, request.conditions)

            # 排序
            sorted_results = sorted(scored_results, key=lambda x: x.match_score, reverse=True)

            return SearchResponse(
                results=sorted_results,
                total=len(sorted_results),
                query=request.query,
                analysis=request.analysis
            )

        except Exception as e:
            self.logger.error("Stock search failed", error=str(e))
            raise HTTPException(status_code=500, detail=f"搜索执行失败: {str(e)}")

    async def _calculate_match_scores(self, stocks: List[Dict], conditions: List[Dict]) -> List[StockResult]:
        """计算股票匹配度"""
        scored_stocks = []

        for stock in stocks:
            score = 0
            total_weight = 0

            for condition in conditions:
                field = condition['field']
                operator = condition['operator']
                target_value = condition['value']
                stock_value = stock.get(field)

                if stock_value is not None:
                    # 计算单个条件的匹配度
                    condition_score = self._calculate_condition_score(
                        stock_value, target_value, operator
                    )
                    score += condition_score
                    total_weight += 1

            # 计算总体匹配度
            final_score = (score / total_weight * 100) if total_weight > 0 else 50

            stock_result = StockResult(
                code=stock['code'],
                name=stock['name'],
                currentPrice=stock.get('current_price'),
                changePct=stock.get('change_pct'),
                matchScore=round(final_score, 1),
                marketCap=stock.get('total_market_cap'),
                pe=stock.get('pe_ratio'),
                pb=stock.get('pb_ratio'),
                roe=stock.get('roe_ratio')
            )

            scored_stocks.append(stock_result)

        return scored_stocks

    def _calculate_condition_score(self, stock_value: float, target_value: float, operator: str) -> float:
        """计算单个条件的匹配度"""
        try:
            if operator == '=':
                return 1.0 if stock_value == target_value else 0.0
            elif operator == '>=':
                # 越接近目标值越好，但不低于目标值
                if stock_value >= target_value:
                    ratio = target_value / stock_value if stock_value > 0 else 1
                    return min(ratio, 1.0)
                else:
                    # 低于目标值，分数递减
                    return max(0, stock_value / target_value)
            elif operator == '<=':
                # 越接近目标值越好，但不高于目标值
                if stock_value <= target_value:
                    ratio = stock_value / target_value if target_value > 0 else 1
                    return min(ratio, 1.0)
                else:
                    # 高于目标值，分数递减
                    return max(0, target_value / stock_value)
            else:
                return 0.0
        except:
            return 0.0

# 查询构建器
class StockQueryBuilder:
    def __init__(self):
        self.conditions = []
        self.order_by = "match_score DESC"

    def add_basic_conditions(self, filters: AdvancedFilters):
        """添加基础筛选条件"""
        # 技术指标筛选
        if filters.technical.get('macd'):
            self.conditions.append("macd_signal = '{}'".format(filters.technical['macd']))

        if filters.technical.get('rsi'):
            self.conditions.append("rsi_value = '{}'".format(filters.technical['rsi']))

        # 基本面筛选
        if filters.fundamental.get('peMin') is not None:
            self.conditions.append("pe_ratio >= {}".format(filters.fundamental['peMin']))

        if filters.fundamental.get('peMax') is not None:
            self.conditions.append("pe_ratio <= {}".format(filters.fundamental['peMax']))

        if filters.fundamental.get('roeMin') is not None:
            self.conditions.append("roe_ratio >= {}".format(filters.fundamental['roeMin']))

        if filters.fundamental.get('roeMax') is not None:
            self.conditions.append("roe_ratio <= {}".format(filters.fundamental['roeMax']))

    async def execute(self, page: int, page_size: int) -> List[Dict]:
        """执行查询"""
        # 构建SQL查询
        where_clause = " AND ".join(self.conditions) if self.conditions else "1=1"

        offset = (page - 1) * page_size

        sql = f"""
        SELECT
            code, name, current_price, change_pct,
            total_market_cap, pe_ratio, pb_ratio, roe_ratio,
            macd_signal, rsi_value, kdj_signal
        FROM stocks
        WHERE {where_clause}
        ORDER BY {self.order_by}
        LIMIT {page_size} OFFSET {offset}
        """

        # 执行查询（这里使用模拟数据）
        return await self._execute_mock_query()

    async def _execute_mock_query(self) -> List[Dict]:
        """执行模拟查询"""
        # 模拟股票数据
        mock_stocks = [
            {
                'code': '
