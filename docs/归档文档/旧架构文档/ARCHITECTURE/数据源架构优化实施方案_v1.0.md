# MyStocks 数据源架构优化实施方案 v1.0

> **文档状态**: 待审批
> **创建日期**: 2025-11-21
> **负责人**: Claude Code
> **审批人**: 项目负责人

---

## 📋 执行摘要

基于您的优化建议文档和项目现状分析，本方案旨在建立一个**高度解耦、可配置切换**的数据源架构体系，实现Mock数据与真实数据的无缝切换，支撑8大功能模块的平滑开发和上线。

**核心价值**:
- ✅ 前后端并行开发：Mock数据先行，前端无需等待后端数据库
- ✅ 零风险切换：通过配置切换数据源，无需修改业务代码
- ✅ 双数据库优化：针对TDengine（时序）和PostgreSQL（关系）特性优化
- ✅ 生产级质量：统一异常处理、性能优化、完整测试覆盖

---

## 🎯 一、项目现状评估

### 1.1 已具备的基础设施 ✅

| 组件 | 状态 | 说明 |
|------|------|------|
| 双数据库架构 | ✅ 已完成 | TDengine (时序) + PostgreSQL (关系) |
| 数据分类系统 | ✅ 已完成 | DataClassification (5类) |
| 外部数据适配器 | ✅ 已完成 | 7个数据源适配器 (Akshare, Baostock, TDX等) |
| IDataSource接口 | ✅ 已完成 | 统一外部数据源接口 |
| FastAPI框架 | ✅ 已完成 | 完整的API路由 (38个文件) |
| OpenAPI文档 | ✅ 已完成 | 自动化API文档系统 |
| UnifiedMockDataManager | ✅ 已完成 | 基础数据源切换机制 |
| 测试框架 | ✅ 已完成 | Pytest + 126个单元测试 (100%通过) |

### 1.2 需要补充的核心组件 ⚠️

| 组件 | 优先级 | 预计工作量 |
|------|--------|------------|
| **分层数据接口** | 🔴 P0 | 3天 |
| **完整Mock数据** | 🔴 P0 | 5天 |
| **工厂模式管理** | 🟡 P1 | 2天 |
| **统一异常体系** | 🟡 P1 | 2天 |
| **接口契约测试** | 🟢 P2 | 3天 |
| **性能优化** | 🟢 P2 | 2天 |

**总预计工作量**: 17个工作日（约3.5周）

---

## 🏗️ 二、架构设计方案

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                      前端 (Vue 3)                         │
│  仪表盘 | 市场行情 | 市场数据 | 股票管理 | 数据分析      │
│  风险管理 | 策略回测 | 交易管理                           │
└────────────────────┬────────────────────────────────────┘
                     │ HTTP API
┌────────────────────┼────────────────────────────────────┐
│              FastAPI 路由层                               │
│  /api/dashboard | /api/market | /api/stocks | ...       │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────┼────────────────────────────────────┐
│             数据源工厂 (DataSourceFactory)                │
│          根据环境变量选择数据源类型                        │
│   ┌──────────────┬──────────────┬──────────────┐        │
│   │  Mock数据源   │  DB数据源    │  API数据源   │        │
│   └──────────────┴──────────────┴──────────────┘        │
└────────────────────┬────────────────────────────────────┘
                     │ 实现统一接口
┌────────────────────┼────────────────────────────────────┐
│          抽象接口层 (分层设计)                             │
│  ┌─────────────────────────────────────────────┐        │
│  │ 时序数据接口 (ITimeSeriesDataSource)         │        │
│  │ - 实时行情 - 分时图 - K线 - 资金流向         │        │
│  └─────────────────────────────────────────────┘        │
│  ┌─────────────────────────────────────────────┐        │
│  │ 关系数据接口 (IRelationalDataSource)         │        │
│  │ - 自选股配置 - 策略参数 - 用户设置           │        │
│  └─────────────────────────────────────────────┘        │
│  ┌─────────────────────────────────────────────┐        │
│  │ 业务逻辑接口 (IBusinessDataSource)           │        │
│  │ - 风险指标 - 回测结果 - 交易信号             │        │
│  └─────────────────────────────────────────────┘        │
└────────────────────┬────────────────────────────────────┘
                     │ 实际存储
┌────────────────────┼────────────────────────────────────┐
│              数据存储层                                   │
│  ┌──────────────┐    ┌──────────────┐                   │
│  │  TDengine    │    │ PostgreSQL   │                   │
│  │  (时序数据)   │    │ (关系数据)   │                   │
│  └──────────────┘    └──────────────┘                   │
└─────────────────────────────────────────────────────────┘
```

### 2.2 核心设计原则

#### 2.2.1 分层接口设计

**为什么要分层？**
- TDengine 和 PostgreSQL 的查询模式完全不同
- 时序数据需要时间范围过滤，关系数据需要用户ID/权限过滤
- 避免单一接口臃肿，提高代码可维护性

**三层接口定义**:

```python
# 1. 时序数据接口 (适配 TDengine)
class ITimeSeriesDataSource(ABC):
    """时序数据源接口 - 用于实时行情、分时图、K线、资金流向"""

    @abstractmethod
    def get_realtime_quotes(
        self,
        symbols: Optional[List[str]] = None,
        fields: Optional[List[str]] = None
    ) -> List[Dict]:
        """获取实时行情"""
        pass

    @abstractmethod
    def get_kline_data(
        self,
        symbol: str,
        start_time: datetime,
        end_time: datetime,
        interval: str = "1d"  # 1m, 5m, 15m, 30m, 1h, 1d
    ) -> pd.DataFrame:
        """获取K线数据（支持分钟/日线级别）"""
        pass

    @abstractmethod
    def get_fund_flow(
        self,
        symbol: str,
        start_date: date,
        end_date: date,
        flow_type: str = "main"  # main, super, large, medium, small
    ) -> pd.DataFrame:
        """获取资金流向数据"""
        pass

# 2. 关系数据接口 (适配 PostgreSQL)
class IRelationalDataSource(ABC):
    """关系数据源接口 - 用于配置、用户数据、策略参数"""

    @abstractmethod
    def get_stock_watchlist(
        self,
        user_id: int,
        list_type: str = "favorite"  # favorite, strategy, industry, concept
    ) -> List[Dict]:
        """获取自选股列表"""
        pass

    @abstractmethod
    def get_strategy_configs(
        self,
        user_id: int,
        strategy_type: Optional[str] = None
    ) -> List[Dict]:
        """获取策略配置"""
        pass

    @abstractmethod
    def save_risk_alert(
        self,
        user_id: int,
        alert_config: Dict
    ) -> Dict:
        """保存风险预警配置"""
        pass

# 3. 业务逻辑接口 (混合数据)
class IBusinessDataSource(ABC):
    """业务逻辑数据源接口 - 用于复杂业务场景"""

    @abstractmethod
    def get_dashboard_summary(
        self,
        user_id: int,
        date: Optional[date] = None
    ) -> Dict:
        """获取仪表盘汇总数据（混合时序+关系数据）"""
        pass

    @abstractmethod
    def execute_backtest(
        self,
        strategy_id: int,
        start_date: date,
        end_date: date,
        initial_capital: float
    ) -> Dict:
        """执行策略回测"""
        pass
```

#### 2.2.2 工厂模式实现

```python
# src/data_sources/factory.py
class DataSourceFactory:
    """数据源工厂 - 根据配置返回对应实现"""

    @staticmethod
    def get_timeseries_source() -> ITimeSeriesDataSource:
        """获取时序数据源"""
        source_type = os.getenv('TIMESERIES_DATA_SOURCE', 'mock')

        if source_type == 'mock':
            return MockTimeSeriesDataSource()
        elif source_type == 'tdengine':
            return TDengineTimeSeriesDataSource()
        elif source_type == 'api':
            return APITimeSeriesDataSource()
        else:
            raise ValueError(f"不支持的时序数据源: {source_type}")

    @staticmethod
    def get_relational_source() -> IRelationalDataSource:
        """获取关系数据源"""
        source_type = os.getenv('RELATIONAL_DATA_SOURCE', 'mock')

        if source_type == 'mock':
            return MockRelationalDataSource()
        elif source_type == 'postgresql':
            return PostgreSQLRelationalDataSource()
        else:
            raise ValueError(f"不支持的关系数据源: {source_type}")

    @staticmethod
    def get_business_source() -> IBusinessDataSource:
        """获取业务逻辑数据源"""
        # 业务数据源内部会调用时序和关系数据源
        return BusinessDataSourceImpl(
            timeseries_source=DataSourceFactory.get_timeseries_source(),
            relational_source=DataSourceFactory.get_relational_source()
        )
```

#### 2.2.3 配置驱动切换

```bash
# .env 配置示例
# 开发环境 - 使用Mock数据
TIMESERIES_DATA_SOURCE=mock
RELATIONAL_DATA_SOURCE=mock
API_DATA_SOURCE=mock

# 测试环境 - 混合模式
TIMESERIES_DATA_SOURCE=tdengine
RELATIONAL_DATA_SOURCE=postgresql
API_DATA_SOURCE=mock  # 外部API仍用Mock

# 生产环境 - 真实数据
TIMESERIES_DATA_SOURCE=tdengine
RELATIONAL_DATA_SOURCE=postgresql
API_DATA_SOURCE=api
```

### 2.3 统一异常处理体系

```python
# src/exceptions.py
class DataSourceException(Exception):
    """数据源异常基类"""
    def __init__(
        self,
        message: str,
        error_code: str,
        source_type: str,
        details: Optional[Dict] = None
    ):
        self.message = message
        self.error_code = error_code
        self.source_type = source_type  # mock, db, api
        self.details = details or {}
        super().__init__(self.message)

class DatabaseQueryException(DataSourceException):
    """数据库查询异常"""
    def __init__(self, message: str, db_type: str, query: str):
        super().__init__(
            message=message,
            error_code="DB_QUERY_ERROR",
            source_type=db_type,
            details={"query": query}
        )

class APIRequestException(DataSourceException):
    """API请求异常"""
    def __init__(self, message: str, api_url: str, status_code: int):
        super().__init__(
            message=message,
            error_code="API_REQUEST_ERROR",
            source_type="api",
            details={"url": api_url, "status_code": status_code}
        )

class MockDataNotFoundException(DataSourceException):
    """Mock数据未找到异常"""
    def __init__(self, data_type: str):
        super().__init__(
            message=f"Mock数据未找到: {data_type}",
            error_code="MOCK_DATA_NOT_FOUND",
            source_type="mock",
            details={"data_type": data_type}
        )
```

---

## 📦 三、分阶段实施计划

### Phase 1: 基础架构搭建 (5天) 🔴 P0

**目标**: 建立完整的抽象接口层和工厂模式

#### 任务清单

- [ ] **Day 1-2: 接口定义**
  - [ ] 定义 `ITimeSeriesDataSource` 接口 (10个核心方法)
  - [ ] 定义 `IRelationalDataSource` 接口 (15个核心方法)
  - [ ] 定义 `IBusinessDataSource` 接口 (8个复合方法)
  - [ ] 添加完整的类型注解和文档字符串
  - [ ] 创建接口文档 (`docs/api/DATA_SOURCE_INTERFACES.md`)

- [ ] **Day 3: 工厂模式实现**
  - [ ] 实现 `DataSourceFactory` 工厂类
  - [ ] 环境变量配置管理
  - [ ] 数据源注册和发现机制
  - [ ] 单例模式优化（避免重复创建）

- [ ] **Day 4: 异常体系**
  - [ ] 定义统一异常类层次结构
  - [ ] 实现 FastAPI 全局异常处理器
  - [ ] 添加结构化日志输出
  - [ ] 创建异常处理文档

- [ ] **Day 5: 基础测试**
  - [ ] 接口定义的单元测试
  - [ ] 工厂模式的切换测试
  - [ ] 异常处理的集成测试
  - [ ] 文档验证测试

**交付物**:
- ✅ 完整的接口定义文件
- ✅ 工厂模式实现
- ✅ 异常处理体系
- ✅ 20+个单元测试
- ✅ 技术文档

---

### Phase 2: Mock数据完善 (5天) 🔴 P0

**目标**: 为8大功能模块创建完整的参数化Mock数据

#### 功能模块与Mock数据映射

| 模块 | Mock文件 | 核心功能 | 数据量估算 |
|------|---------|---------|-----------|
| 1. 仪表盘 | `dashboard_mock.py` | 市场概览、资金流向、板块表现 | 15个接口 |
| 2. 市场行情 | `market_mock.py` | 实时行情、分时图、技术指标 | 12个接口 |
| 3. 市场数据 | `market_data_mock.py` | ETF、概念、龙虎榜、机构 | 20个接口 |
| 4. 股票管理 | `stocks_mock.py` | 自选股、策略选股、分组管理 | 10个接口 |
| 5. 数据分析 | `analysis_mock.py` | 指标分析、筛选、行业概念 | 15个接口 |
| 6. 风险管理 | `risk_mock.py` | 预警、监控、因子分析 | 12个接口 |
| 7. 策略回测 | `backtest_mock.py` | 策略设计、回测、GPU加速 | 10个接口 |
| 8. 交易管理 | `trading_mock.py` | 信号、持仓、归因分析 | 10个接口 |

#### 任务清单

- [ ] **Day 1: 仪表盘 + 市场行情 Mock**
  - [ ] `dashboard_mock.py` (15个接口)
    - 市场概览 (上涨/下跌家数、大盘指数)
    - 数据更新状态
    - 市场热度分析 (板块+资金流)
    - N日资金流向排名
    - 板块表现汇总
  - [ ] `market_mock.py` (12个接口)
    - 实时行情 (支持批量查询)
    - 分时图数据 (动态生成)
    - K线数据 (1m/5m/15m/30m/1h/1d)
    - 技术指标 (MA, MACD, KDJ, RSI等)

- [ ] **Day 2: 市场数据 Mock**
  - [ ] `market_data_mock.py` (20个接口)
    - 资金流向 (主力/超大单/大单/中单/小单)
    - ETF行情 (实时+历史)
    - 概念行情 (板块涨跌)
    - 竞价抢筹数据
    - 龙虎榜数据
    - 机构荐股数据
    - 问财筛选结果

- [ ] **Day 3: 股票管理 + 数据分析 Mock**
  - [ ] `stocks_mock.py` (10个接口)
    - 自选股CRUD
    - 策略选股配置
    - 行业选股配置
    - 概念选股配置
    - 分组管理
  - [ ] `analysis_mock.py` (15个接口)
    - 指标分析 (单股/批量)
    - 自定义指标
    - 条件筛选
    - 行业/概念筛选
    - 数据导出

- [ ] **Day 4: 风险管理 + 策略回测 Mock**
  - [ ] `risk_mock.py` (12个接口)
    - 个股预警设置
    - 监控列表
    - 风险指标计算
    - 舆情数据
    - 因子分析
  - [ ] `backtest_mock.py` (10个接口)
    - 策略定义
    - 回测配置
    - 回测结果
    - GPU加速状态
    - 性能指标

- [ ] **Day 5: 交易管理 + 参数化增强**
  - [ ] `trading_mock.py` (10个接口)
    - 交易信号
    - 历史记录
    - 持仓分析
    - 归因分析
  - [ ] 参数化增强
    - 使用 `faker` 库动态生成数据
    - 支持日期范围过滤
    - 支持股票代码过滤
    - 支持自定义数量参数

**交付物**:
- ✅ 8个完整的Mock数据文件
- ✅ 100+个Mock接口函数
- ✅ 参数化和动态生成能力
- ✅ Mock数据使用文档
- ✅ Mock数据单元测试

---

### Phase 3: 数据源实现 (4天) 🟡 P1

**目标**: 实现真实数据库和API数据源

#### 任务清单

- [ ] **Day 1: TDengine时序数据源**
  - [ ] `TDengineTimeSeriesDataSource` 实现
  - [ ] 实时行情查询优化
  - [ ] K线数据聚合查询
  - [ ] 资金流向时间范围查询
  - [ ] 连接池管理

- [ ] **Day 2: PostgreSQL关系数据源**
  - [ ] `PostgreSQLRelationalDataSource` 实现
  - [ ] 自选股CRUD操作
  - [ ] 策略配置管理
  - [ ] 用户权限过滤
  - [ ] 关联查询优化 (joinedload)

- [ ] **Day 3: 业务逻辑数据源**
  - [ ] `BusinessDataSourceImpl` 实现
  - [ ] 仪表盘汇总数据聚合
  - [ ] 策略回测执行逻辑
  - [ ] 风险指标计算
  - [ ] 缓存策略优化

- [ ] **Day 4: API数据源 (可选)**
  - [ ] `APITimeSeriesDataSource` 实现
  - [ ] 第三方API接口封装
  - [ ] 请求重试和超时机制
  - [ ] API限流处理

**交付物**:
- ✅ 完整的数据源实现类
- ✅ 数据库查询优化
- ✅ 性能基准测试
- ✅ 数据源实现文档

---

### Phase 4: 集成测试与文档 (3天) 🟢 P2

**目标**: 确保所有数据源契约一致，完善文档

#### 任务清单

- [ ] **Day 1: 契约测试**
  - [ ] Mock数据 vs 真实数据 结构对比测试
  - [ ] 所有接口的参数验证测试
  - [ ] 返回值格式一致性测试
  - [ ] 异常处理测试
  - [ ] 边界条件测试

- [ ] **Day 2: 端到端测试**
  - [ ] 8个功能模块的完整数据流测试
  - [ ] Mock → DB 切换测试
  - [ ] 并发访问测试
  - [ ] 性能压力测试
  - [ ] 错误恢复测试

- [ ] **Day 3: 文档完善**
  - [ ] API接口文档更新
  - [ ] 数据源使用指南
  - [ ] 配置切换手册
  - [ ] 故障排查文档
  - [ ] 最佳实践文档

**交付物**:
- ✅ 50+个集成测试
- ✅ 性能测试报告
- ✅ 完整的API文档
- ✅ 运维手册

---

## 📊 四、关键技术决策

### 4.1 Mock数据生成策略

**选择**: 使用 `faker` + 参数化函数

**优势**:
- 动态生成真实感数据
- 支持日期范围、股票代码等参数过滤
- 易于扩展和维护

**示例**:
```python
from faker import Faker
import random
from datetime import datetime, timedelta

fake = Faker('zh_CN')

def generate_realtime_quotes(symbols: List[str], count: int = 10) -> List[Dict]:
    """动态生成实时行情Mock数据"""
    quotes = []
    for symbol in symbols[:count]:
        base_price = random.uniform(5.0, 300.0)
        quotes.append({
            "symbol": symbol,
            "name": fake.company(),
            "price": round(base_price, 2),
            "change": round(random.uniform(-10, 10), 2),
            "change_percent": round(random.uniform(-10, 10), 2),
            "volume": random.randint(1000000, 100000000),
            "amount": round(random.uniform(10000000, 1000000000), 2),
            "high": round(base_price * 1.1, 2),
            "low": round(base_price * 0.9, 2),
            "open": round(base_price * random.uniform(0.95, 1.05), 2),
            "timestamp": datetime.now().isoformat()
        })
    return quotes
```

### 4.2 数据库查询优化策略

#### TDengine 优化
```python
# 使用时间范围索引
SELECT * FROM tick_data
WHERE symbol='600000'
  AND ts BETWEEN '2025-01-01 00:00:00' AND '2025-01-31 23:59:59'
ORDER BY ts DESC
LIMIT 1000

# 聚合查询优化
SELECT _wstart, avg(price), sum(volume)
FROM tick_data
WHERE symbol='600000'
  AND ts > now() - 1d
INTERVAL(1m)
FILL(prev)
```

#### PostgreSQL 优化
```python
# 使用 joinedload 避免 N+1 查询
from sqlalchemy.orm import joinedload

watchlist = db.query(UserWatchlist)\
    .filter(UserWatchlist.user_id == user_id)\
    .options(joinedload(UserWatchlist.stock_info))\
    .all()

# 分页查询
from sqlalchemy import func

total = db.query(func.count(Stock.id)).scalar()
stocks = db.query(Stock)\
    .offset((page - 1) * page_size)\
    .limit(page_size)\
    .all()
```

### 4.3 缓存策略

**三级缓存**:
1. **内存缓存** (functools.lru_cache) - 热点数据
2. **Redis缓存** (可选) - 跨进程共享
3. **数据库查询缓存** - 慢查询结果

```python
from functools import lru_cache
from typing import List, Dict
import hashlib
import json

class CachedDataSource:
    """带缓存的数据源装饰器"""

    def __init__(self, ttl: int = 300):
        self.ttl = ttl  # 缓存过期时间（秒）

    @lru_cache(maxsize=1000)
    def get_realtime_quotes(self, symbols_hash: str) -> List[Dict]:
        """缓存实时行情（基于symbols哈希）"""
        # symbols_hash = hashlib.md5(json.dumps(symbols).encode()).hexdigest()
        # 实际查询逻辑
        pass
```

---

## ✅ 五、验收标准

### 5.1 功能验收

- [ ] **接口完整性**: 所有8个功能模块的接口100%实现
- [ ] **数据源切换**: 通过配置文件可无缝切换Mock/DB/API
- [ ] **格式一致性**: Mock数据与真实数据格式100%对齐
- [ ] **异常处理**: 所有数据源异常可追踪和恢复
- [ ] **性能达标**:
  - 实时行情查询 < 100ms
  - K线数据查询 < 500ms
  - 仪表盘汇总 < 1s

### 5.2 测试验收

- [ ] **单元测试覆盖率**: >= 80%
- [ ] **集成测试**: 所有数据流端到端测试通过
- [ ] **契约测试**: Mock与真实数据结构一致性100%
- [ ] **性能测试**: 并发1000用户压力测试通过
- [ ] **兼容性测试**: 开发/测试/生产环境切换无误

### 5.3 文档验收

- [ ] **API文档**: 自动生成的OpenAPI文档完整准确
- [ ] **使用手册**: 数据源切换、配置、故障排查文档齐全
- [ ] **代码注释**: 所有接口和关键函数有完整文档字符串
- [ ] **架构文档**: 架构图、设计决策、技术选型文档完善

---

## 📋 六、风险评估与应对

| 风险项 | 概率 | 影响 | 应对策略 |
|--------|------|------|----------|
| Mock数据与真实数据格式不一致 | 中 | 高 | 建立契约测试，开发阶段严格验证 |
| 数据库性能问题 | 中 | 中 | 提前性能测试，优化慢查询，建立缓存 |
| 第三方API不稳定 | 高 | 中 | 实现重试机制，降级到Mock数据 |
| 开发周期延误 | 中 | 中 | 采用敏捷迭代，优先完成P0任务 |
| 技术债务累积 | 低 | 中 | 代码审查，定期重构，完善测试 |

---

## 📅 七、时间线

```
Week 1: Phase 1 - 基础架构搭建
  Day 1-2 ████████░░ 接口定义
  Day 3   ████░░░░░░ 工厂模式
  Day 4   ████░░░░░░ 异常体系
  Day 5   ████░░░░░░ 基础测试

Week 2: Phase 2 - Mock数据完善
  Day 1   ████████░░ 仪表盘+市场行情
  Day 2   ██████████ 市场数据
  Day 3   ████████░░ 股票管理+数据分析
  Day 4   ████████░░ 风险管理+策略回测
  Day 5   ████████░░ 交易管理+参数化

Week 3: Phase 3 - 数据源实现
  Day 1   ████████░░ TDengine时序
  Day 2   ████████░░ PostgreSQL关系
  Day 3   ████████░░ 业务逻辑
  Day 4   ████░░░░░░ API数据源

Week 3-4: Phase 4 - 集成测试与文档
  Day 1   ████████░░ 契约测试
  Day 2   ████████░░ 端到端测试
  Day 3   ████████░░ 文档完善
```

---

## 🎯 八、成功指标 (KPI)

| 指标 | 目标值 | 当前值 | 完成日期 |
|------|--------|--------|----------|
| 接口定义完成度 | 100% | 30% | Week 1 |
| Mock数据覆盖率 | 100% | 20% | Week 2 |
| 数据源实现完成度 | 100% | 40% | Week 3 |
| 单元测试覆盖率 | 80%+ | 60% | Week 3 |
| 集成测试通过率 | 100% | 0% | Week 4 |
| API文档完整性 | 100% | 95% | Week 4 |
| 性能基准达标 | 100% | - | Week 4 |

---

## 📝 九、后续优化方向

1. **智能Mock数据生成**: 基于真实数据分布训练生成模型
2. **自动化契约测试**: CI/CD集成，每次提交自动验证
3. **性能监控**: 实时监控各数据源性能，自动告警
4. **A/B测试支持**: 支持不同数据源的灰度切换
5. **数据源路由优化**: 根据负载自动选择最优数据源

---

## ✍️ 审批意见

| 审批人 | 角色 | 审批意见 | 签名 | 日期 |
|--------|------|----------|------|------|
| [待填写] | 项目负责人 | □ 批准 □ 修改 □ 拒绝 | | |
| [待填写] | 技术负责人 | □ 批准 □ 修改 □ 拒绝 | | |
| [待填写] | 测试负责人 | □ 批准 □ 修改 □ 拒绝 | | |

**修改建议**:
```
[请在此处填写具体修改建议]
```

---

**文档版本**: v1.0
**最后更新**: 2025-11-21
**下一版本计划**: 根据审批意见修订

---

🤖 Generated with Claude Code

Co-Authored-By: Claude <noreply@anthropic.com>
