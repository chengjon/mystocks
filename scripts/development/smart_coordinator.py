# scripts/dev/smart_coordinator.py

"""
æ™ºèƒ½åè°ƒå™¨ - è®©mainæ›´è½»æ¾

ä½¿ç”¨è§„åˆ™å¼•æ“è‡ªåŠ¨å¤„ç†å¸¸è§åè°ƒåœºæ™¯ï¼š
1. é˜»å¡è‡ªåŠ¨è§£å†³
2. ç©ºé—²èµ„æºè‡ªåŠ¨åˆ†é…
3. å†²çªè‡ªåŠ¨é¢„é˜²
"""

import sys
import os
import time
from pathlib import Path
from datetime import datetime

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# å¯¼å…¥åŸºç¡€åè°ƒå™¨
try:
    from cli_coordinator import CLICoordinator
except ImportError:
    # å¦‚æœå¯¼å…¥å¤±è´¥ï¼Œå®šä¹‰åŸºç¡€ç±»
    class CLICoordinator:
        def __init__(self, clis_dir="CLIS"):
            self.clis_dir = Path(clis_dir)

        def scan_all_status(self):
            statuses = {}
            for cli_dir in self.clis_dir.iterdir():
                if cli_dir.is_dir() and cli_dir.name != 'main':
                    status_file = cli_dir / "STATUS.md"
                    if status_file.exists():
                        statuses[cli_dir.name] = self._parse_status(status_file)
            return statuses

        def _parse_status(self, status_file):
            content = status_file.read_text()
            # ç®€åŒ–çš„çŠ¶æ€è§£æ
            return {
                'name': status_file.parent.name,
                'state': 'unknown',
                'current_task': None,
                'last_update': None,
                'blocked_on': None,
                'waiting_time': 0
            }


class SmartCoordinator(CLICoordinator):
    """æ™ºèƒ½åè°ƒå™¨ - è§„åˆ™å¼•æ“"""

    def __init__(self, clis_dir="CLIS"):
        super().__init__(clis_dir)
        self.coordination_log = self.clis_dir / "SHARED" / "COORDINATION_LOG.md"
        self.coordination_log.parent.mkdir(parents=True, exist_ok=True)

        # åˆå§‹åŒ–è§„åˆ™
        self.rules = [
            BlockageResolutionRule(self),
            IdleResourceRule(self),
            ConflictPreventionRule(self),
            HealthCheckRule(self)
        ]

    def auto_coordinate(self):
        """è‡ªåŠ¨æ‰§è¡Œåè°ƒè§„åˆ™"""
        print("\nğŸ¤– æ™ºèƒ½åè°ƒå™¨å¯åŠ¨...")

        # æ‰«ææ‰€æœ‰CLIçŠ¶æ€
        statuses = self.scan_all_status()

        print(f"æ‰«æåˆ° {len(statuses)} ä¸ªCLI")

        # æ‰§è¡Œæ‰€æœ‰è§„åˆ™
        all_actions = []
        for rule in self.rules:
            actions = rule.evaluate(statuses)
            all_actions.extend(actions)

        # æ‰§è¡ŒåŠ¨ä½œ
        if all_actions:
            print(f"\nç”Ÿæˆ {len(all_actions)} ä¸ªåè°ƒåŠ¨ä½œ...")

            for i, action in enumerate(all_actions, 1):
                print(f"\n[{i}/{len(all_actions)}] æ‰§è¡Œ: {action.type}")
                self.execute_action(action)

            # è®°å½•åè°ƒæ—¥å¿—
            self.log_coordination(all_actions)

            return len(all_actions)
        else:
            print("âœ… æ— éœ€åè°ƒï¼Œç³»ç»Ÿè¿è¡Œæ­£å¸¸")
            return 0

    def execute_action(self, action):
        """æ‰§è¡Œåè°ƒåŠ¨ä½œ"""
        if action.type == 'reassign':
            self.send_reassign_message(action)
        elif action.type == 'alert':
            self.send_alert_message(action)
        elif action.type == 'notify':
            self.send_notify_message(action)

    def send_reassign_message(self, action):
        """å‘é€é‡æ–°åˆ†é…æ¶ˆæ¯"""
        message = f"""---
**From**: CLI-main
**To**: {action.to_cli}
**Type**: REQUEST
**Priority**: HIGH
**Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**AutoGenerated**: true

**Subject**: åä½œè¯·æ±‚ï¼šååŠ©{action.from_cli}

**Description**:
{action.reason}

**Blocked Task**: {action.blocked_task}

**Action Required**:
è¯·è¯„ä¼°æ˜¯å¦å¯ä»¥ååŠ©å®Œæˆä¾èµ–ä»»åŠ¡ï¼Œæˆ–è€…æ‰§è¡Œä»¥ä¸‹ç‹¬ç«‹ä»»åŠ¡ï¼š
{action.suggested_task}

**Expected Response**: 15åˆ†é’Ÿå†…

æ­¤æ¶ˆæ¯ç”±æ™ºèƒ½åè°ƒå™¨è‡ªåŠ¨ç”Ÿæˆï¼Œå¦‚æ— æ³•ååŠ©ï¼Œè¯·å›å¤mainã€‚
"""

        # å‘é€æ¶ˆæ¯
        self._send_message(action.to_cli, message)
        print(f"ğŸ“§ å·²å‘é€åè°ƒæ¶ˆæ¯åˆ° {action.to_cli}")

    def send_alert_message(self, action):
        """å‘é€å‘Šè­¦æ¶ˆæ¯"""
        message = f"""---
**From**: CLI-main
**To**: {action.to_cli}
**Type**: ALERT
**Priority**: HIGH
**Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**AutoGenerated**: true

**Subject**: æ–‡ä»¶é”æŒæœ‰æ—¶é—´è¿‡é•¿æé†’

**Description**:
{action.reason}

**Action Required**:
è¯·å°½å¿«å®Œæˆå½“å‰å·¥ä½œå¹¶é‡Šæ”¾æ–‡ä»¶é”ã€‚

æ­¤æ¶ˆæ¯ç”±æ™ºèƒ½åè°ƒå™¨è‡ªåŠ¨ç”Ÿæˆã€‚
"""

        self._send_message(action.to_cli, message)
        print(f"ğŸš¨ å·²å‘é€å‘Šè­¦åˆ° {action.to_cli}")

    def send_notify_message(self, action):
        """å‘é€é€šçŸ¥æ¶ˆæ¯"""
        message = f"""---
**From**: CLI-main
**To**: {action.to_cli}
**Type**: NOTIFICATION
**Priority**: MEDIUM
**Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**AutoGenerated**: true

**Subject**: {action.reason}

æ­¤æ¶ˆæ¯ç”±æ™ºèƒ½åè°ƒå™¨è‡ªåŠ¨ç”Ÿæˆã€‚
"""

        self._send_message(action.to_cli, message)
        print(f"ğŸ“¢ å·²å‘é€é€šçŸ¥åˆ° {action.to_cli}")

    def _send_message(self, to_cli, message):
        """å‘é€æ¶ˆæ¯åˆ°æŒ‡å®šCLI"""
        mailbox_dir = self.clis_dir / to_cli / "mailbox"
        mailbox_dir.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        message_file = mailbox_dir / f"main_auto_{timestamp}.md"

        with open(message_file, 'w', encoding='utf-8') as f:
            f.write(message)

    def log_coordination(self, actions):
        """è®°å½•åè°ƒæ—¥å¿—"""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        with open(self.coordination_log, 'a', encoding='utf-8') as f:
            f.write(f"\n## è‡ªåŠ¨åè°ƒ: {timestamp}\n\n")

            for action in actions:
                f.write(f"- **ç±»å‹**: {action.type}\n")
                f.write(f"- **æ¶‰åŠCLI**: {action.from_cli} â†’ {action.to_cli}\n")
                f.write(f"- **åŸå› **: {action.reason}\n")
                f.write(f"- **çŠ¶æ€**: {'âœ… å·²æ‰§è¡Œ' if action.executed else 'â¸ï¸ å¾…æ‰§è¡Œ'}\n")
                f.write("\n")


class CoordinationAction:
    """åè°ƒåŠ¨ä½œ"""

    def __init__(self, type, from_cli, to_cli, reason, **kwargs):
        self.type = type
        self.from_cli = from_cli
        self.to_cli = to_cli
        self.reason = reason
        self.executed = False

        for key, value in kwargs.items():
            setattr(self, key, value)


class BlockageResolutionRule:
    """é˜»å¡è‡ªåŠ¨è§£å†³è§„åˆ™"""

    def __init__(self, coordinator):
        self.coordinator = coordinator

    def evaluate(self, statuses):
        """è¯„ä¼°é˜»å¡æƒ…å†µå¹¶ç”ŸæˆåŠ¨ä½œ"""
        actions = []

        for cli, status in statuses.items():
            if status['state'] == 'blocked':
                # è®¡ç®—ç­‰å¾…æ—¶é—´
                if status['last_update']:
                    try:
                        last_update = datetime.strptime(status['last_update'], '%Y-%m-%d %H:%M:%S')
                        waiting_time = (datetime.now() - last_update).total_seconds() / 60
                    except:
                        waiting_time = 0
                else:
                    waiting_time = 0

                # è§„åˆ™1: ç­‰å¾…æ—¶é—´ > 60åˆ†é’Ÿï¼Œè‡ªåŠ¨åˆ†é…ååŠ©
                if waiting_time > 60:
                    idle_cli = self._find_idle_cli(statuses)
                    if idle_cli:
                        actions.append(CoordinationAction(
                            type='reassign',
                            from_cli=cli,
                            to_cli=idle_cli,
                            reason=f"è‡ªåŠ¨åè°ƒ: {cli}è¢«é˜»å¡{waiting_time:.0f}åˆ†é’Ÿ",
                            blocked_task=status['current_task'],
                            suggested_task="æ‰§è¡Œç‹¬ç«‹ä»»åŠ¡æ± ä¸­çš„ä»»åŠ¡æˆ–ååŠ©ä¾èµ–ä»»åŠ¡"
                        ))

        return actions

    def _find_idle_cli(self, statuses):
        """æŸ¥æ‰¾ç©ºé—²CLI"""
        for cli, status in statuses.items():
            if status['state'] == 'idle':
                return cli
        return None


class IdleResourceRule:
    """ç©ºé—²èµ„æºè‡ªåŠ¨åˆ†é…è§„åˆ™"""

    def __init__(self, coordinator):
        self.coordinator = coordinator

    def evaluate(self, statuses):
        """è¯„ä¼°ç©ºé—²èµ„æºå¹¶ç”ŸæˆåŠ¨ä½œ"""
        actions = []

        idle_clis = [cli for cli, status in statuses.items() if status['state'] == 'idle']

        if not idle_clis:
            return actions

        # è¯»å–ç‹¬ç«‹ä»»åŠ¡æ± 
        tasks_pool = self.coordinator.clis_dir / "SHARED" / "TASKS_POOL.md"
        if tasks_pool.exists():
            with open(tasks_pool, 'r') as f:
                content = f.read()

            # è§£æç‹¬ç«‹ä»»åŠ¡
            available_tasks = self._parse_tasks_pool(content)

            # ä¸ºç©ºé—²CLIåˆ†é…ä»»åŠ¡
            for i, idle_cli in enumerate(idle_clis):
                if i < len(available_tasks):
                    task = available_tasks[i]

                    actions.append(CoordinationAction(
                        type='notify',
                        from_cli='main',
                        to_cli=idle_cli,
                        reason=f"æ‚¨å½“å‰ç©ºé—²ï¼Œå»ºè®®æ‰§è¡Œç‹¬ç«‹ä»»åŠ¡: {task['name']}",
                        suggested_task=task
                    ))

        return actions

    def _parse_tasks_pool(self, content):
        """è§£æä»»åŠ¡æ± """
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è§£æmarkdown
        return []


class ConflictPreventionRule:
    """å†²çªè‡ªåŠ¨é¢„é˜²è§„åˆ™"""

    def __init__(self, coordinator):
        self.coordinator = coordinator

    def evaluate(self, statuses):
        """è¯„ä¼°æ½œåœ¨å†²çªå¹¶ç”ŸæˆåŠ¨ä½œ"""
        actions = []

        # æ£€æŸ¥æ–‡ä»¶é”
        locks_dir = self.coordinator.clis_dir / "locks"

        if locks_dir.exists():
            for lock_file in locks_dir.glob("*.lock"):
                try:
                    with open(lock_file, 'r') as f:
                        content = f.read()
                        holder = content.split('\n')[0]
                        waiting_time = time.time() - float(content.split('\n')[1])

                    # è§„åˆ™: é”å®šæ—¶é—´ > 30åˆ†é’Ÿï¼Œå‘é€æé†’
                    if waiting_time > 1800:  # 30åˆ†é’Ÿ
                        actions.append(CoordinationAction(
                            type='alert',
                            from_cli='main',
                            to_cli=holder,
                            reason=f"æ–‡ä»¶é”æŒæœ‰æ—¶é—´è¿‡é•¿({waiting_time/60:.0f}åˆ†é’Ÿ)ï¼Œè¯·å°½å¿«å®Œæˆå¹¶é‡Šæ”¾é”",
                            lock_file=lock_file.name
                        ))

                except:
                    pass

        return actions


class HealthCheckRule:
    """å¥åº·æ£€æŸ¥è§„åˆ™"""

    def __init__(self, coordinator):
        self.coordinator = coordinator

    def evaluate(self, statuses):
        """è¯„ä¼°CLIå¥åº·çŠ¶æ€å¹¶ç”ŸæˆåŠ¨ä½œ"""
        actions = []

        for cli, status in statuses.items():
            # æ£€æŸ¥æœ€åæ›´æ–°æ—¶é—´
            if status['last_update']:
                try:
                    last_update = datetime.strptime(status['last_update'], '%Y-%m-%d %H:%M:%S')
                    idle_time = (datetime.now() - last_update).total_seconds() / 60

                    # è§„åˆ™: è¶…è¿‡10åˆ†é’Ÿæœªæ›´æ–°ï¼Œå‘é€æé†’
                    if idle_time > 10:
                        actions.append(CoordinationAction(
                            type='notify',
                            from_cli='main',
                            to_cli=cli,
                            reason=f"STATUS.mdå·²{idle_time:.0f}åˆ†é’Ÿæœªæ›´æ–°ï¼Œè¯·åŠæ—¶æ›´æ–°"
                        ))

                except:
                    pass

        return actions


def main():
    """ä¸»å‡½æ•°"""
    import argparse

    parser = argparse.ArgumentParser(description='æ™ºèƒ½CLIåè°ƒå™¨')
    parser.add_argument('--auto', action='store_true', help='è‡ªåŠ¨æ‰§è¡Œåè°ƒ')
    parser.add_argument('--clis-dir', default='CLIS', help='CLIç›®å½•')

    args = parser.parse_args()

    coordinator = SmartCoordinator(args.clis_dir)

    if args.auto:
        action_count = coordinator.auto_coordinate()
        print(f"\nâœ… åè°ƒå®Œæˆï¼Œæ‰§è¡Œäº† {action_count} ä¸ªåŠ¨ä½œ")


if __name__ == '__main__':
    main()
